<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Costs and Benefits</title>
<style>
  body { font-family: sans-serif; margin: 20px; }
  .container { display: grid; grid-template-columns: 1fr 1fr; gap: 20px; }
  canvas { border: 1px solid #999; border-radius: 6px; }
  label { display: block; margin-top: 8px; }
  input[type=range] { width: 100%; }
  .tooltip { position: absolute; font-size: 12px; background: rgba(255,255,255,0.9); border: 1px solid #ccc; border-radius: 4px; padding: 3px 6px; pointer-events: none; }
</style>
</head>
<body>
<h1>Costs and Benefits</h1>
<div class="container">
  <div>
    <label>Reference model
      <select id="rocSelect"></select>
    </label>
    <label>Proportion positive: <span id="pPosLabel"></span>
      <input type="range" id="pPos" min="0.01" max="0.99" step="0.01" value="0.5">
    </label>
    <div id="sliders"></div>
    <div id="bestUtility" style="margin-top:1em;font-weight:bold;"></div>
  </div>
  <div style="position:relative;">
    <canvas id="canvas" width="600" height="600"></canvas>
    <div id="tooltip" class="tooltip" style="display:none;"></div>
  </div>
</div>
<script>
let rocCurves = {};

function loadROCData(data) {
  rocCurves = data;
  const rocSelect = document.getElementById('rocSelect');
  rocSelect.innerHTML = '';
  Object.keys(rocCurves).forEach(k => {
    const opt = document.createElement('option');
    opt.text = k;
    rocSelect.appendChild(opt);
  });
  rocSelect.selectedIndex = 0;
  draw();
}

const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
const tooltip = document.getElementById('tooltip');
const pPosSlider = document.getElementById('pPos');
const pPosLabel = document.getElementById('pPosLabel');
const rocSelect = document.getElementById('rocSelect');
const slidersDiv = document.getElementById('sliders');
const bestUtilityDiv = document.getElementById('bestUtility');

const values={TP:50,FP:-70,TN:0,FN:0};
for (const k of ['TP','FP','TN','FN']) {
  const label=document.createElement('label');
  label.innerHTML=`${k} value: <span id="${k}Val">${values[k]}</span>`;
  const range=document.createElement('input');
  range.type='range'; range.min=-100; range.max=100; range.step=1; range.value=values[k];
  range.oninput=()=>{values[k]=+range.value;document.getElementById(k+'Val').textContent=range.value;draw();};
  label.appendChild(range);
  slidersDiv.appendChild(label);
}

pPosSlider.oninput=()=>{draw();};
rocSelect.onchange=()=>{draw();};

function hslToRgb(h,s,l){const a=s*Math.min(l,1-l);const f=n=>{const k=(n+h*12)%12;const color=l-a*Math.max(Math.min(k-3,9-k,1),-1);return Math.round(255*color);};return [f(0),f(8),f(4)];}
function heatColor(s){const h=240-240*s;const [r,g,b]=hslToRgb(h/360,0.6,0.85);return [r,g,b];}

function draw(){
  const rocName=rocSelect.value;
  if(!rocName || !rocCurves[rocName]) return;
  const roc=rocCurves[rocName];
  const fpr=roc.fpr, tpr=roc.tpr, lower=roc.tpr_lower, upper=roc.tpr_upper;
  const pPos=parseFloat(pPosSlider.value);pPosLabel.textContent=pPos.toFixed(2);
  const N=1000;const {TP,FP,TN,FN}=values;
  const width=canvas.width, height=canvas.height;

  const margin=0.05; const labelOffsetFactor = 0.6; const labelOffset = labelOffsetFactor * margin;
  const x0=margin*width; const y0=margin*height; const plotW=width*(1-2*margin); const plotH=height*(1-2*margin);
  const xScale=(xf)=>x0+xf*plotW; const yScale=(yt)=>y0+(1-yt)*plotH;
  const clamp01=(v)=>Math.max(0,Math.min(1,v));

  const utility=(fpr,tpr,P)=>{const ap=N*P,an=N*(1-P);const tp=tpr*ap,fn=(1-tpr)*ap,fp=fpr*an,tn=an-fp;return FP*fp+TN*tn+TP*tp+FN*fn;};
  const constants=(P)=>{const ap=N*P,an=N*(1-P);return {a:TN*an+FN*ap,b:FP*an-TN*an,c:TP*ap-FN*ap};};
  const {a,b,c}=constants(pPos);

  ctx.clearRect(0,0,width,height);

  const iw=Math.max(2,Math.floor(plotW)); const ih=Math.max(2,Math.floor(plotH));
  const img=ctx.createImageData(iw,ih); const data=img.data; let minU=Infinity,maxU=-Infinity; const utilities=[];
  for(let j=0;j<ih;j++){const tprVal=1-j/(ih-1);for(let i=0;i<iw;i++){const fprVal=i/(iw-1);const u=utility(fprVal,tprVal,pPos);utilities.push(u);if(u<minU)minU=u;if(u>maxU)maxU=u;}}
  const scale=v=>(v-minU)/(maxU-minU||1);
  let k=0;for(let j=0;j<ih;j++){for(let i=0;i<iw;i++){const s=scale(utilities[j*iw+i]);const [r,g,b2]=heatColor(s);data[k++]=r;data[k++]=g;data[k++]=b2;data[k++]=255;}}
  ctx.putImageData(img,Math.round(x0),Math.round(y0));

  ctx.save();
  ctx.beginPath(); ctx.rect(x0,y0,plotW,plotH); ctx.clip();

  const nLines=10,step=(maxU-minU)/(nLines+1||1);
  ctx.strokeStyle='rgba(0,0,0,0.4)'; ctx.lineWidth=1; ctx.setLineDash([4,4]);
  ctx.font='12px sans-serif'; ctx.fillStyle='black'; ctx.textBaseline='middle';
  for(let i=1;i<=nLines;i++){
    const level=minU+i*step;
    const tpr0=(level-a-b*0)/c; const tpr1=(level-a-b*1)/c;
    const yA=yScale(tpr0), yB=yScale(tpr1);
    ctx.beginPath(); ctx.moveTo(xScale(0),yA); ctx.lineTo(xScale(1),yB); ctx.stroke();

    // Label positioning proportional to margin
    const tprLeft=(level-a)/c;
    const fprBottom=(level-a)/b;
    const offsetX = labelOffset * plotW; const offsetY = labelOffset * plotH;
    if(tprLeft>=0 && tprLeft<=1){
      const xL=xScale(0)+offsetX; const yL=yScale(tprLeft);
      ctx.fillText(Math.round(level),xL,yL);
    } else if(fprBottom>=0 && fprBottom<=1){
      const xB=xScale(clamp01(fprBottom)); const yBtm=yScale(0)-offsetY;
      ctx.textAlign='center'; ctx.fillText(Math.round(level),xB,yBtm); ctx.textAlign='left';
    }
  }
  ctx.setLineDash([]);

  const s=((1-pPos)*(TN-FP))/(pPos*(TP-FN));
  ctx.strokeStyle='limegreen'; ctx.lineWidth=3; ctx.setLineDash([10,10]);
  const drawOne=(intercept)=>{ctx.beginPath();ctx.moveTo(xScale(0),yScale(intercept));ctx.lineTo(xScale(1),yScale(s+intercept));ctx.stroke();};
  drawOne(0); drawOne(1-s); ctx.setLineDash([]);

  ctx.restore();

  if(lower && upper){
    ctx.beginPath(); ctx.moveTo(xScale(fpr[0]),yScale(upper[0])); for(let i=1;i<fpr.length;i++)ctx.lineTo(xScale(fpr[i]),yScale(upper[i])); for(let i=fpr.length-1;i>=0;i--)ctx.lineTo(xScale(fpr[i]),yScale(lower[i])); ctx.closePath(); ctx.fillStyle='rgba(0,0,255,0.2)'; ctx.fill();
    ctx.beginPath(); ctx.strokeStyle='rgba(0,0,180,0.6)'; ctx.lineWidth=1;
    for(let i=0;i<fpr.length;i++){if(i===0)ctx.moveTo(xScale(fpr[i]),yScale(upper[i]));else ctx.lineTo(xScale(fpr[i]),yScale(upper[i]));} ctx.stroke();
    ctx.beginPath(); for(let i=0;i<fpr.length;i++){if(i===0)ctx.moveTo(xScale(fpr[i]),yScale(lower[i]));else ctx.lineTo(xScale(fpr[i]),yScale(lower[i]));} ctx.stroke();
  }

  let bestU=-Infinity,bestPt=null; ctx.beginPath(); ctx.strokeStyle='blue'; ctx.lineWidth=2;
  for(let i=0;i<fpr.length;i++){const x=xScale(fpr[i]),y=yScale(tpr[i]);if(i===0)ctx.moveTo(x,y); else ctx.lineTo(x,y);const u=utility(fpr[i],tpr[i],pPos);if(u>bestU){bestU=u;bestPt={x,y};}}
  ctx.stroke();
  if(bestPt){ctx.beginPath();ctx.arc(bestPt.x,bestPt.y,6,0,2*Math.PI);ctx.fillStyle='yellow';ctx.strokeStyle='red';ctx.fill();ctx.stroke();bestUtilityDiv.textContent='Best utility = '+Math.round(bestU);}

  ctx.strokeStyle='#666'; ctx.lineWidth=1; ctx.strokeRect(x0,y0,plotW,plotH);
}

canvas.addEventListener('mousemove',e=>{
  const rect=canvas.getBoundingClientRect(); const x=e.clientX-rect.left,y=e.clientY-rect.top;
  const width=canvas.width,height=canvas.height,margin=0.05,x0=margin*width,y0=margin*height,plotW=width*(1-2*margin),plotH=height*(1-2*margin);
  if(x<x0||x>x0+plotW||y<y0||y>y0+plotH){tooltip.style.display='none';return;}
  const fpr=(x-x0)/plotW,tpr=1-(y-y0)/plotH;
  const pPos=parseFloat(pPosSlider.value);const N=1000;const {TP,FP,TN,FN}=values;const ap=N*pPos,an=N*(1-pPos),tp=tpr*ap,fn=(1-tpr)*ap,fp=fpr*an,tn=an-fp;const u=FP*fp+TN*tn+TP*tp+FN*fn;
  const tooltipWidth=140,tooltipHeight=48;
  tooltip.style.left=(x-tooltipWidth-10)+'px'; tooltip.style.top=(y-tooltipHeight-10)+'px'; tooltip.textContent=`FPR: ${fpr.toFixed(2)}, TPR: ${tpr.toFixed(2)}, U: ${Math.round(u)}`; tooltip.style.display='block';
});
canvas.addEventListener('mouseleave',()=>tooltip.style.display='none');

window.addEventListener('DOMContentLoaded',()=>{
  loadROCData({
    randomForest:{name:'randomForest',type:'ROC',fpr:[0,0.2,0.4,0.6,0.8,1],tpr:[0,0.5,0.7,0.85,0.9,1],metadata:{auc:0.87,method:'randomForest'}},
    logistic:{name:'logistic',type:'ROC',fpr:[0,0.2,0.4,0.6,0.8,1],tpr:[0,0.4,0.65,0.8,0.9,1],metadata:{auc:0.84,method:'logistic regression'}},
    bayesian_model:{name:'bayesian_model',type:'ROC',fpr:[0,0.2,0.4,0.6,0.8,1],tpr:[0,0.45,0.7,0.85,0.9,1],tpr_lower:[0,0.35,0.6,0.75,0.85,0.95],tpr_upper:[0,0.55,0.8,0.9,0.95,1],metadata:{auc:0.86,method:'Bayesian binormal',credible_level:0.95}}
  });
});
</script>
</body>
</html>
