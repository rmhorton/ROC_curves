<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Costs and Benefits</title>
<style>
  body { font-family: sans-serif; margin: 20px; }
  .container { display: grid; grid-template-columns: 1fr 1fr; gap: 20px; }
  canvas { border: 1px solid #999; border-radius: 6px; }
  label { display: block; margin-top: 8px; }
  input[type=range] { width: 100%; }
  .tooltip { position: absolute; font-size: 12px; background: rgba(255,255,255,0.9); border: 1px solid #ccc; border-radius: 4px; padding: 3px 6px; pointer-events: none; }
</style>
</head>
<body>
<h1>Costs and Benefits</h1>
<div class="container">
  <div>
    <label>Reference model
      <select id="rocSelect"></select>
    </label>
    <label>Proportion positive: <span id="pPosLabel"></span>
      <input type="range" id="pPos" min="0.01" max="0.99" step="0.01" value="0.5">
    </label>
    <div id="sliders"></div>
    <div id="bestUtility" style="margin-top:1em;font-weight:bold;"></div>
  </div>
  <div style="position:relative;">
    <canvas id="canvas" width="600" height="600"></canvas>
    <div id="tooltip" class="tooltip" style="display:none;"></div>
  </div>
</div>
<script>
let rocCurves = {};

function loadROCData(data) {
  rocCurves = data;
  const rocSelect = document.getElementById('rocSelect');
  rocSelect.innerHTML = '';
  Object.keys(rocCurves).forEach(k => {
    const opt = document.createElement('option');
    opt.text = k;
    rocSelect.appendChild(opt);
  });
  rocSelect.selectedIndex = 0;
  draw();
}

const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
const tooltip = document.getElementById('tooltip');
const pPosSlider = document.getElementById('pPos');
const pPosLabel = document.getElementById('pPosLabel');
const rocSelect = document.getElementById('rocSelect');
const slidersDiv = document.getElementById('sliders');
const bestUtilityDiv = document.getElementById('bestUtility');

const values={TP:50,FP:-70,TN:0,FN:0};
for (const k of ['TP','FP','TN','FN']) {
  const label=document.createElement('label');
  label.innerHTML=`${k} value: <span id="${k}Val">${values[k]}</span>`;
  const range=document.createElement('input');
  range.type='range'; range.min=-100; range.max=100; range.step=1; range.value=values[k];
  range.oninput=()=>{values[k]=+range.value;document.getElementById(k+'Val').textContent=range.value;draw();};
  label.appendChild(range);
  slidersDiv.appendChild(label);
}

pPosSlider.oninput=()=>{draw();};
rocSelect.onchange=()=>{draw();};

function hslToRgb(h,s,l){const a=s*Math.min(l,1-l);const f=n=>{const k=(n+h*12)%12;const color=l-a*Math.max(Math.min(k-3,9-k,1),-1);return Math.round(255*color);};return [f(0),f(8),f(4)];}
function heatColor(s){const h=240-240*s;const [r,g,b]=hslToRgb(h/360,0.6,0.85);return [r,g,b];}

function draw(){
  const rocName=rocSelect.value;
  if(!rocName || !rocCurves[rocName]) return;
  const roc=rocCurves[rocName];
  const pPos=parseFloat(pPosSlider.value);pPosLabel.textContent=pPos.toFixed(2);
  const N=1000;const {TP,FP,TN,FN}=values;const width=canvas.width,height=canvas.height;

  const utility=(fpr,tpr,P)=>{const ap=N*P,an=N*(1-P);const tp=tpr*ap,fn=(1-tpr)*ap,fp=fpr*an,tn=an-fp;return FP*fp+TN*tn+TP*tp+FN*fn;};
  const constants=(P)=>{const ap=N*P,an=N*(1-P);return {a:TN*an+FN*ap,b:FP*an-TN*an,c:TP*ap-FN*ap};};

  const {a,b,c}=constants(pPos);
  const img=ctx.createImageData(width,height);
  const data=img.data;let minU=Infinity,maxU=-Infinity;const utilities=[];
  for(let j=0;j<height;j++){const tpr=1-j/height;for(let i=0;i<width;i++){const fpr=i/width;const u=utility(fpr,tpr,pPos);utilities.push(u);if(u<minU)minU=u;if(u>maxU)maxU=u;}}
  const scale=v=>(v-minU)/(maxU-minU);
  let k=0;for(let j=0;j<height;j++){for(let i=0;i<width;i++){const s=scale(utilities[j*width+i]);const [r,g,b2]=heatColor(s);data[k++]=r;data[k++]=g;data[k++]=b2;data[k++]=255;}}
  ctx.putImageData(img,0,0);

  const nLines=10,step=(maxU-minU)/(nLines+1);
  ctx.strokeStyle='rgba(0,0,0,0.4)';ctx.lineWidth=1;ctx.setLineDash([4,4]);
  ctx.font='12px sans-serif';ctx.fillStyle='black';ctx.textBaseline='middle';
  for(let i=1;i<=nLines;i++){
    const level=minU+i*step;
    const tpr0=(level-a-b*0)/c,tpr1=(level-a-b*1)/c;
    const y0=height*(1-tpr0),y1=height*(1-tpr1);
    ctx.beginPath();ctx.moveTo(0,y0);ctx.lineTo(width,y1);ctx.stroke();

    const angle=Math.atan2(y1-y0,width);
    let xLabel=30; let fpr=xLabel/width; let tpr=(level-a-b*fpr)/c; let yLabel=height*(1-tpr);
    if(yLabel<10||yLabel>height-10){yLabel=height-15; fpr=(level-a-b*(yLabel/height))/c; xLabel=fpr*width; }
    ctx.save();ctx.translate(xLabel,yLabel);ctx.rotate(angle);
    ctx.fillText(Math.round(level),0,0);ctx.restore();
  }
  ctx.setLineDash([]);

  const s=((1-pPos)*(TN-FP))/(pPos*(TP-FN));
  ctx.strokeStyle='limegreen';ctx.lineWidth=3;ctx.setLineDash([10,10]);
  const drawOne=int=>{ctx.beginPath();ctx.moveTo(0,height*(1-int));ctx.lineTo(width,height*(1-(s+int)));ctx.stroke();};
  drawOne(0);drawOne(1-s);ctx.setLineDash([]);

  let bestU=-Infinity,bestPt=null;
  ctx.beginPath();ctx.strokeStyle='blue';ctx.lineWidth=2;
  roc.forEach((p,i)=>{const x=p.fpr*width,y=height*(1-p.tpr);if(i===0)ctx.moveTo(x,y);else ctx.lineTo(x,y);const u=utility(p.fpr,p.tpr,pPos);if(u>bestU){bestU=u;bestPt={x,y};}});
  ctx.stroke();
  if(bestPt){ctx.beginPath();ctx.arc(bestPt.x,bestPt.y,6,0,2*Math.PI);ctx.fillStyle='yellow';ctx.strokeStyle='red';ctx.fill();ctx.stroke();bestUtilityDiv.textContent='Best utility = '+Math.round(bestU);}
}

canvas.addEventListener('mousemove',e=>{
  const rect=canvas.getBoundingClientRect();const x=e.clientX-rect.left,y=e.clientY-rect.top;
  const fpr=Math.min(Math.max(x/canvas.width,0),1),tpr=Math.min(Math.max(1-y/canvas.height,0),1);
  const pPos=parseFloat(pPosSlider.value);const N=1000;const {TP,FP,TN,FN}=values;
  const ap=N*pPos,an=N*(1-pPos);const tp=tpr*ap,fn=(1-tpr)*ap,fp=fpr*an,tn=an-fp;
  const u=FP*fp+TN*tn+TP*tp+FN*fn;
  const tooltipWidth=120, tooltipHeight=40;
  tooltip.style.left=(x - tooltipWidth - 10)+'px';
  tooltip.style.top=(y - tooltipHeight - 10)+'px';
  tooltip.textContent=`FPR: ${fpr.toFixed(2)}, TPR: ${tpr.toFixed(2)}, U: ${Math.round(u)}`;
  tooltip.style.display='block';
});
canvas.addEventListener('mouseleave',()=>tooltip.style.display='none');

window.addEventListener('DOMContentLoaded', () => {
  loadROCData({
    randomForest: [{fpr:0,tpr:0},{fpr:0.5,tpr:0.8},{fpr:1,tpr:1}],
    logistic: [{fpr:0,tpr:0},{fpr:0.5,tpr:0.7},{fpr:1,tpr:1}],
    svm: [{fpr:0,tpr:0},{fpr:0.5,tpr:0.6},{fpr:1,tpr:1}]
  });
});
</script>
</body>
</html>
