<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Costs and Benefits</title>
<style>
  body { font-family: sans-serif; margin: 20px; }
  .container { display: grid; grid-template-columns: 1fr 1fr; gap: 20px; }
  canvas { border: 1px solid #999; border-radius: 6px; }
  label { display: block; margin-top: 8px; }
  input[type=range] { width: 100%; }
  .tooltip { position: absolute; font-size: 12px; background: rgba(255,255,255,0.9); border: 1px solid #ccc; border-radius: 4px; padding: 3px 6px; pointer-events: none; }
  .payoff-grid { border-collapse: collapse; width: 100%; max-width: 360px; }
  .payoff-grid th, .payoff-grid td { border: 1px solid #ccc; padding: 6px; text-align: center; }
  .payoff-grid th { background: #f5f5f5; font-weight: 600; }
  .payoff-cell { display: flex; flex-direction: column; align-items: center; gap: 4px; }
  .slider-input-row { display: flex; align-items: center; gap: 10px; width: 100%; }
  .slider-input-column { display: flex; flex-direction: column; gap: 6px; width: 100%; align-items: stretch; }
  .payoff-cell-label { font-size: 12px; font-weight: 600; }
  .payoff-input-number { width: 80px; }
  .control-container { max-width: 360px; width: 100%; margin: 0 auto; }
</style>
</head>
<body>
<h1 id="appTitle">Costs and Benefits</h1>
<div class="container">
  <div>
    <label id="dropdownLabel"><span id="dropdownLabelText">Reference model</span>
      <select id="rocSelect"></select>
    </label>
    <div class="control-container">
      <div id="importControls" style="margin-top:12px; display:flex; flex-direction:column; gap:6px;">
        <label><span id="importLabelText">Import ROC Data</span>
          <input type="file" id="rocFileInput" accept=".csv,.json,application/json,text/csv">
        </label>
        <button type="button" id="downloadCurveBtn">Download Selected Curve JSON</button>
      </div>
    </div>
    <div id="slidersSection">
      <div class="control-container">
        <div id="priorControls"></div>
      </div>
      <div class="control-container">
        <div id="payoffGridSection" style="margin-top:12px;"></div>
      </div>
      <div class="control-container">
        <div id="confusionMatrixContainer" style="margin-top:12px;"></div>
      </div>
    </div>
    <div id="bestUtility" style="margin-top:1em;font-weight:bold;"></div>
  </div>
  <div id="rocPlotContainer" style="position:relative;">
    <canvas id="canvas" width="600" height="600"></canvas>
    <div id="tooltip" class="tooltip" style="display:none;"></div>
    <canvas id="gainCanvas" width="600" height="600" style="margin-top:16px; border:1px solid #999; border-radius:6px;"></canvas>
    <canvas id="prCanvas" width="600" height="600" style="margin-top:16px; border:1px solid #999; border-radius:6px;"></canvas>
  </div>
</div>
<div id="thresholdSection" style="margin-top:20px;">
  <h2 id="thresholdTitle">Payoff vs Threshold</h2>
  <canvas id="thresholdCanvas" width="800" height="320" style="border:1px solid #999; border-radius:6px;"></canvas>
</div>
<script>
const defaultConfig = {
  strings: {
    pageTitle: "ROC Utility",
    appTitle: "Costs and Benefits",
    dropdownLabel: "Reference model",
    importLabel: "Import ROC Data",
    downloadButton: "Download Selected Curve JSON",
    thresholdTitle: "Payoff vs Threshold",
    rocPlotTitle: "Receiver Operating Characteristic Curve",
    rocXAxisLabel: "False Positive Rate",
    rocYAxisLabel: "True Positive Rate",
    gainPlotTitle: "Gain Curve",
    gainXAxisLabel: "Fraction of the Entire Test Set",
    gainYAxisLabel: "True Positive Rate",
    prPlotTitle: "Precision–Recall Curve",
    prXAxisLabel: "Recall",
    prYAxisLabel: "Precision",
    confusionMatrixTitle: "Confusion Matrix (best operating point)",
    liftAxisLabel: "Lift (independent scale; not a linear transform of gain)",
    liftCurveLabel: "Lift Curve",
    bestUtilityPrefix: "Best utility = ",
    bestUtilityUnavailable: "Best utility = —",
    noThresholdData: "No threshold data available for payoff plot.",
    axisThreshold: "Threshold",
    axisUtility: "Expected Utility",
    legendSelectedSuffix: " (selected)",
    legendDerivedSuffix: " (derived thresholds)",
    variantLabelFormat: "{original} ({source})",
    variantSourceFallback: "variant",
    tooltipFormat: "FPR: {fpr}, TPR: {tpr}, U: {utility}",
    payoffGrid: {
      actualPositive: "Actual Positive",
      actualNegative: "Actual Negative",
      predictedPositive: "Predicted Positive",
      predictedNegative: "Predicted Negative",
      TP: "True Positive",
      FN: "False Negative",
      FP: "False Positive",
      TN: "True Negative"
    },
    alerts: {
      noCurvesFound: "No ROC curves found in the selected file.",
      failImport: "Failed to import ROC data: {message}",
      failRead: "Unable to read the selected file.",
      noCurveSelectedDownload: "No ROC curve selected to download.",
      failStaticLoad: "Failed to load static ROC file \"{path}\": {message}",
      failConfigLoad: "Failed to load configuration: {message}"
    },
    plots: {
      gain: {
        randomModelLabel: "Random Model (Diagonal)",
        prevalenceLabel: "Prevalence",
        baselineLegendTitle: "Baselines"
      }
    }
  },
  ui: {
    showRocPlot: true,
    showThresholdPlot: true,
    showSliders: true,
    showImport: true,
    showDownloadButton: true,
    showBestUtility: true,
    showGainPlot: true,
    showPRPlot: true,
    showConfusionMatrix: true,
    showGainDiagonalLine: true,
    showGainPrevalenceLine: true,
    showGainBaselineLegend: false,
    showGainCurveInGainPlot: true,
    showLiftCurveInGainPlot: false,
    liftAxisMaxMultiplier: 1.2,
    thresholdXAxisMode: "quantile", // "threshold" or "quantile"
    showAllCurvesInThresholdPlot: true,
    payoffInputMode: "slider"
  },
  style: {
    gainDiagonalLine: { color: "#666", width: 1, dash: [] },
    gainPrevalenceLine: { color: "#1e88e5", width: 1, dash: [5,3] }
  },
  sliders: {
    P_POS: {label: "Proportion positive", min: 0.01, max: 0.99, step: 0.01, value: 0.5},
    N: {label: "Sample size (N)", min: 10, max: 100000, step: 10, value: 1000}
  },
  payoffs: {
    TP: {label: "TP", value: 50, min: -100, max: 100, step: 1},
    FP: {label: "FP", value: -70, min: -100, max: 100, step: 1},
    TN: {label: "TN", value: 0, min: -100, max: 100, step: 1},
    FN: {label: "FN", value: 0, min: -100, max: 100, step: 1}
  },
  data: {
    staticFiles: [
      'roc_data/roadmap_logistic.csv',
      'roc_data/random_forest_baseline.csv',
      'roc_data/logistic_baseline.csv',
      'roc_data/bayesian_model_baseline.csv',
      'roc_data/roadmap_logistic.json',
      'roc_data/random_forest_baseline.json',
      'roc_data/logistic_baseline.json',
      'roc_data/bayesian_model_baseline.json'
    ]
  }
};

const STATIC_DATA_FILES = [...defaultConfig.data.staticFiles];

const HARDCODED_FALLBACK_CURVES = {
  random_forest_baseline: {
    name: 'random_forest_baseline',
    type: 'ROC',
    fpr: [0, 0.2, 0.4, 0.6, 0.8, 1],
    tpr: [0, 0.5, 0.7, 0.85, 0.9, 1],
    metadata: {source: 'embedded', note: 'Random forest demo curve'}
  },
  logistic_baseline: {
    name: 'logistic_baseline',
    type: 'ROC',
    fpr: [0, 0.2, 0.4, 0.6, 0.8, 1],
    tpr: [0, 0.4, 0.65, 0.8, 0.9, 1],
    metadata: {source: 'embedded', note: 'Logistic regression demo curve'}
  },
  bayesian_model_baseline: {
    name: 'bayesian_model_baseline',
    type: 'ROC',
    fpr: [0, 0.2, 0.4, 0.6, 0.8, 1],
    tpr: [0, 0.45, 0.7, 0.85, 0.9, 1],
    tpr_lower: [0, 0.35, 0.6, 0.75, 0.85, 0.95],
    tpr_upper: [0, 0.55, 0.8, 0.9, 0.95, 1],
    metadata: {source: 'embedded', note: 'Bayesian model demo curve'}
  }
};

let rocCurves = {};
let appConfig = cloneDeep(defaultConfig);
let strings = appConfig.strings;
let uiSettings = appConfig.ui;
let lastRocBestUtility = null;
let lastRocBestIdx = null;
let gainPlotCache = {points:[], utilities:[], thresholds:[], geometry:null};
let lastBestPoint = {fpr:null,tpr:null};

const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
const thresholdCanvas = document.getElementById('thresholdCanvas');
const thresholdCtx = thresholdCanvas ? thresholdCanvas.getContext('2d') : null;
const tooltip = document.getElementById('tooltip');
const rocSelect = document.getElementById('rocSelect');
const priorControls = document.getElementById('priorControls');
const payoffGridSection = document.getElementById('payoffGridSection');
const gainCanvas = document.getElementById('gainCanvas');
const gainCtx = gainCanvas ? gainCanvas.getContext('2d') : null;
const prCanvas = document.getElementById('prCanvas');
const prCtx = prCanvas ? prCanvas.getContext('2d') : null;
const rocFileInput = document.getElementById('rocFileInput');
const downloadCurveBtn = document.getElementById('downloadCurveBtn');
const bestUtilityDiv = document.getElementById('bestUtility');
const appTitleEl = document.getElementById('appTitle');
const dropdownLabelText = document.getElementById('dropdownLabelText');
const importControls = document.getElementById('importControls');
const importLabelText = document.getElementById('importLabelText');
const slidersSection = document.getElementById('slidersSection');
const confusionMatrixContainer = document.getElementById('confusionMatrixContainer');
const rocPlotContainer = document.getElementById('rocPlotContainer');
const thresholdSection = document.getElementById('thresholdSection');
const thresholdTitleEl = document.getElementById('thresholdTitle');

const values = {};
const isFileProtocol = typeof location !== 'undefined' && location.protocol === 'file:';

function cloneDeep(obj){
  return JSON.parse(JSON.stringify(obj));
}

function mergeDeep(target, source){
  if(!source || typeof source !== 'object') return target;
  Object.keys(source).forEach(key=>{
    const sourceValue = source[key];
    if(Array.isArray(sourceValue)){
      target[key] = sourceValue.slice();
    }else if(sourceValue && typeof sourceValue === 'object'){
      if(!target[key] || typeof target[key] !== 'object'){
        target[key] = {};
      }
      mergeDeep(target[key], sourceValue);
    }else{
      target[key] = sourceValue;
    }
  });
  return target;
}

function formatString(template, replacements = {}){
  if(!template || typeof template !== 'string') return '';
  return template.replace(/\{([^}]+)\}/g, (_, key)=>{
    const value = key in replacements ? replacements[key] : '';
    return value === undefined || value === null ? '' : String(value);
  });
}

function updateConfigReferences(){
  strings = appConfig && appConfig.strings ? appConfig.strings : defaultConfig.strings;
  uiSettings = appConfig && appConfig.ui ? appConfig.ui : defaultConfig.ui;
}

updateConfigReferences();

function getAlertTemplate(key){
  const primary = (strings && strings.alerts) ? strings.alerts : {};
  const fallback = (defaultConfig.strings && defaultConfig.strings.alerts) ? defaultConfig.strings.alerts : {};
  return primary[key] || fallback[key] || key;
}

function alertFromConfig(key, params = {}){
  const template = getAlertTemplate(key);
  alert(formatString(template, params));
}

function warnFromConfig(key, params = {}){
  const template = getAlertTemplate(key);
  console.warn(formatString(template, params));
}

function applyConfigToUI(){
  if(strings.pageTitle || strings.appTitle){
    document.title = strings.pageTitle || strings.appTitle;
  }
  if(appTitleEl) appTitleEl.textContent = strings.appTitle || defaultConfig.strings.appTitle;
  if(dropdownLabelText) dropdownLabelText.textContent = strings.dropdownLabel || defaultConfig.strings.dropdownLabel;
  if(importLabelText) importLabelText.textContent = strings.importLabel || defaultConfig.strings.importLabel;
  if(downloadCurveBtn) downloadCurveBtn.textContent = strings.downloadButton || defaultConfig.strings.downloadButton;
  if(thresholdTitleEl) thresholdTitleEl.textContent = strings.thresholdTitle || defaultConfig.strings.thresholdTitle;
  if(importControls) importControls.style.display = isImportVisible() ? 'flex' : 'none';
  if(downloadCurveBtn) downloadCurveBtn.style.display = isDownloadVisible() ? 'inline-block' : 'none';
  if(slidersSection) slidersSection.style.display = isSlidersVisible() ? 'block' : 'none';
  if(rocPlotContainer) rocPlotContainer.style.display = (isRocPlotVisible() || isGainPlotVisible() || isPRPlotVisible()) ? 'block' : 'none';
  if(canvas) canvas.style.display = isRocPlotVisible() ? 'block' : 'none';
  if(gainCanvas) gainCanvas.style.display = isGainPlotVisible() ? 'block' : 'none';
  if(prCanvas) prCanvas.style.display = isPRPlotVisible() ? 'block' : 'none';
  if(thresholdSection) thresholdSection.style.display = isThresholdPlotVisible() ? 'block' : 'none';
  if(confusionMatrixContainer) confusionMatrixContainer.style.display = (uiSettings && uiSettings.showConfusionMatrix===false) ? 'none' : 'block';
  if(bestUtilityDiv){
    if(isBestUtilityVisible()){
      bestUtilityDiv.style.display = '';
      if(!bestUtilityDiv.textContent){
        bestUtilityDiv.textContent = strings.bestUtilityUnavailable || defaultConfig.strings.bestUtilityUnavailable;
      }
    }else{
      bestUtilityDiv.style.display = 'none';
      bestUtilityDiv.textContent = '';
    }
  }
}

async function loadAppConfig(){
  if(isFileProtocol){
    appConfig = cloneDeep(defaultConfig);
    updateConfigReferences();
    applyConfigToUI();
    buildControlPanels();
    return;
  }
  let fetchedConfig = null;
  try{
    const response = await fetch('roc_config.json');
    if(!response.ok) throw new Error(`HTTP ${response.status}`);
    fetchedConfig = await response.json();
  }catch(err){
    warnFromConfig('failConfigLoad', {message: err.message || err});
  }
  appConfig = cloneDeep(defaultConfig);
  if(fetchedConfig){
    mergeDeep(appConfig, fetchedConfig);
  }
  updateConfigReferences();
  applyConfigToUI();
  buildControlPanels();
}

function isRocPlotVisible(){ return !(uiSettings && uiSettings.showRocPlot === false); }
function isThresholdPlotVisible(){ return !(uiSettings && uiSettings.showThresholdPlot === false); }
function isGainPlotVisible(){ return !(uiSettings && uiSettings.showGainPlot === false); }
function isPRPlotVisible(){ return !(uiSettings && uiSettings.showPRPlot === false); }
function isSlidersVisible(){ return !(uiSettings && uiSettings.showSliders === false); }
function isImportVisible(){ return !(uiSettings && uiSettings.showImport === false); }
function isDownloadVisible(){ return !(uiSettings && uiSettings.showDownloadButton === false); }
function isBestUtilityVisible(){ return !(uiSettings && uiSettings.showBestUtility === false); }

function resolveVariantLabel(curveId, meta){
  if(!meta || !meta.original_curve_id || meta.original_curve_id === curveId) return curveId;
  const format = strings.variantLabelFormat || "{original} ({source})";
  const sourceLabel = meta.loaded_via || meta.source || strings.variantSourceFallback || defaultConfig.strings.variantSourceFallback;
  return formatString(format, {original: meta.original_curve_id, source: sourceLabel});
}

function loadROCData(data, preferredSelection) {
  const previousSelection = preferredSelection || rocSelect.value;
  rocCurves = data;
  rocSelect.innerHTML = '';
  const curveNames = Object.keys(rocCurves).sort((a,b)=>a.localeCompare(b));
  curveNames.forEach(k => {
    const opt = document.createElement('option');
    opt.value = k;
    const curve = rocCurves[k];
    const meta = curve && curve.metadata;
    opt.textContent = resolveVariantLabel(k, meta);
    rocSelect.appendChild(opt);
  });
  if (previousSelection && rocCurves[previousSelection]) {
    rocSelect.value = previousSelection;
  } else if (rocSelect.options.length) {
    rocSelect.selectedIndex = 0;
  }
  drawAll();
}

function getPayoffParams(){
  return {
    P_POS: values.P_POS,
    TP: values.TP,
    FP: values.FP,
    TN: values.TN,
    FN: values.FN
  };
}

function formatCount(val){
  if(!Number.isFinite(val)) return '—';
  const fixed = val.toFixed(3);
  return fixed.replace(/\.?0+$/,'');
}

function renderConfusionMatrixCounts(opts){
  if(!confusionMatrixContainer) return;
  if(uiSettings && uiSettings.showConfusionMatrix===false){
    confusionMatrixContainer.innerHTML='';
    return;
  }
  const {tp, fp, tn, fn} = opts || {};
  const gridStrings = strings.payoffGrid || defaultConfig.strings.payoffGrid || {};
  const title = strings.confusionMatrixTitle || defaultConfig.strings.confusionMatrixTitle || 'Confusion Matrix';
  confusionMatrixContainer.innerHTML = '';
  const titleEl = document.createElement('h3');
  titleEl.textContent = title;
  confusionMatrixContainer.appendChild(titleEl);

  const table = document.createElement('table');
  table.className = 'payoff-grid';
  const thead = document.createElement('thead');
  const headerRow = document.createElement('tr');
  headerRow.appendChild(document.createElement('th'));
  const colPos = document.createElement('th');
  colPos.textContent = gridStrings.predictedPositive || 'Predicted Positive';
  const colNeg = document.createElement('th');
  colNeg.textContent = gridStrings.predictedNegative || 'Predicted Negative';
  headerRow.appendChild(colPos);
  headerRow.appendChild(colNeg);
  thead.appendChild(headerRow);
  table.appendChild(thead);

  const tbody = document.createElement('tbody');
  const rowPos = document.createElement('tr');
  const rowPosHeader = document.createElement('th');
  rowPosHeader.textContent = gridStrings.actualPositive || 'Actual Positive';
  rowPos.appendChild(rowPosHeader);
  const tpCell = document.createElement('td');
  tpCell.textContent = formatCount(tp);
  const fnCell = document.createElement('td');
  fnCell.textContent = formatCount(fn);
  rowPos.appendChild(tpCell);
  rowPos.appendChild(fnCell);
  tbody.appendChild(rowPos);

  const rowNeg = document.createElement('tr');
  const rowNegHeader = document.createElement('th');
  rowNegHeader.textContent = gridStrings.actualNegative || 'Actual Negative';
  rowNeg.appendChild(rowNegHeader);
  const fpCell = document.createElement('td');
  fpCell.textContent = formatCount(fp);
  const tnCell = document.createElement('td');
  tnCell.textContent = formatCount(tn);
  rowNeg.appendChild(fpCell);
  rowNeg.appendChild(tnCell);
  tbody.appendChild(rowNeg);

  table.appendChild(tbody);
  confusionMatrixContainer.appendChild(table);
}

function updateConfusionMatrix(){
  if(!confusionMatrixContainer || (uiSettings && uiSettings.showConfusionMatrix===false)){
    return;
  }
  const rocName=rocSelect.value;
  if(!rocName || !rocCurves[rocName] || lastBestPoint.tpr===null || lastBestPoint.fpr===null){
    renderConfusionMatrixCounts({tp:null,fp:null,tn:null,fn:null});
    return;
  }
  const payoffs=getPayoffParams();
  const pPos=payoffs.P_POS;
  const N=getPopulationSize();
  const tpr=lastBestPoint.tpr;
  const fpr=lastBestPoint.fpr;
  const tp = tpr * pPos * N;
  const fn = (1 - tpr) * pPos * N;
  const fp = fpr * (1 - pPos) * N;
  const tn = (1 - fpr) * (1 - pPos) * N;
  renderConfusionMatrixCounts({tp,fp,tn,fn});
}

function getPopulationSize(){
  const sampleCfg = getSampleSizeConfig();
  const defaultVal = Number(sampleCfg && sampleCfg.value);
  ensureValue('N', Number.isFinite(defaultVal) ? defaultVal : 1000);
  return values.N;
}

function utilityAtRates(fpr,tpr,payoffs){
  if(!Number.isFinite(fpr) || !Number.isFinite(tpr)) return NaN;
  const {P_POS, TP, FP, TN, FN} = payoffs;
  const N = getPopulationSize();
  const ap = N * P_POS;
  const an = N * (1 - P_POS);
  const tp = tpr * ap;
  const fn = (1 - tpr) * ap;
  const fp = fpr * an;
  const tn = an - fp;
  return FP * fp + TN * tn + TP * tp + FN * fn;
}

function getIsoCoefficients(payoffs){
  const {P_POS, TP, FP, TN, FN} = payoffs;
  const N = getPopulationSize();
  const ap = N * P_POS;
  const an = N * (1 - P_POS);
  return {
    a: TN * an + FN * ap,
    b: FP * an - TN * an,
    c: TP * ap - FN * ap
  };
}

function getCurveColor(index,total){
  const hue = (index * 360 / Math.max(total, 1)) % 360;
  return `hsl(${hue},70%,45%)`;
}

function getPriorConfig(){
  const sliderDefs = (appConfig && appConfig.sliders) ? appConfig.sliders : defaultConfig.sliders;
  return sliderDefs && sliderDefs.P_POS ? sliderDefs.P_POS : defaultConfig.sliders.P_POS;
}

function getSampleSizeConfig(){
  const sliderDefs = (appConfig && appConfig.sliders) ? appConfig.sliders : defaultConfig.sliders;
  return sliderDefs && sliderDefs.N ? sliderDefs.N : defaultConfig.sliders.N;
}

function getPayoffConfig(){
  const base = defaultConfig.payoffs || {};
  const override = (appConfig && appConfig.payoffs) ? appConfig.payoffs : {};
  const keys = ['TP','FP','TN','FN'];
  const merged = {};
  keys.forEach(key=>{
    merged[key] = Object.assign({}, base[key] || {}, override[key] || {});
  });
  return merged;
}

function getPayoffInputMode(){
  const mode = uiSettings && uiSettings.payoffInputMode;
  return mode === 'text' ? 'text' : 'slider';
}

function ensureValue(key, defaultVal){
  if(!Number.isFinite(values[key])){
    values[key] = Number.isFinite(defaultVal) ? defaultVal : 0;
  }
}

function clampValue(value, min, max){
  if(!Number.isFinite(value)) return null;
  const minNum = Number(min);
  const maxNum = Number(max);
  let result = value;
  if(Number.isFinite(minNum)) result = Math.max(result, minNum);
  if(Number.isFinite(maxNum)) result = Math.min(result, maxNum);
  return result;
}

function bindSliderWithNumber({slider, numberInput, valueSpan, key}){
  if(!slider || !numberInput) return;
  const updateFromSlider = ()=>{
    const val = Number(slider.value);
    values[key] = val;
    numberInput.value = slider.value;
    if(valueSpan) valueSpan.textContent = slider.value;
    drawAll();
  };
  const updateFromNumber = ()=>{
    const parsed = Number(numberInput.value);
    if(!Number.isFinite(parsed)) return;
    const clamped = clampValue(parsed, slider.min, slider.max);
    if(clamped === null) return;
    slider.value = clamped;
    numberInput.value = clamped;
    values[key] = clamped;
    if(valueSpan) valueSpan.textContent = slider.value;
    drawAll();
  };
  slider.addEventListener('input', updateFromSlider);
  numberInput.addEventListener('change', updateFromNumber);
  numberInput.addEventListener('input', ()=>{
    if(Number.isFinite(Number(numberInput.value))){
      updateFromNumber();
    }
  });
  numberInput.addEventListener('blur', ()=>{
    if(!Number.isFinite(Number(numberInput.value))){
      numberInput.value = slider.value;
      return;
    }
    updateFromNumber();
  });
  numberInput.value = slider.value;
  if(valueSpan) valueSpan.textContent = slider.value;
}

function buildControlPanels(){
  buildPriorSlider();
  buildPayoffGrid();
  updateConfusionMatrix();
}

function buildPriorSlider(){
  if(!priorControls) return;
  priorControls.innerHTML = '';
  const priorCfg = getPriorConfig();
  const defaultVal = Number(priorCfg && priorCfg.value);
  ensureValue('P_POS', Number.isFinite(defaultVal) ? defaultVal : 0.5);
  const sampleCfg = getSampleSizeConfig();
  const defaultSampleVal = Number(sampleCfg && sampleCfg.value);
  ensureValue('N', Number.isFinite(defaultSampleVal) ? defaultSampleVal : 1000);
  if(!isSlidersVisible()) return;

  const wrapper = document.createElement('div');
  wrapper.className = 'prior-slider';
  const headerRow = document.createElement('div');
  headerRow.style.display = 'flex';
  headerRow.style.justifyContent = 'space-between';
  headerRow.style.alignItems = 'center';

  const labelSpan = document.createElement('span');
  labelSpan.textContent = (priorCfg && priorCfg.label) || (defaultConfig.sliders.P_POS && defaultConfig.sliders.P_POS.label) || 'Proportion positive';

  const valueSpan = document.createElement('span');
  valueSpan.id = 'P_POSVal';
  valueSpan.textContent = values.P_POS;

  headerRow.appendChild(labelSpan);
  headerRow.appendChild(valueSpan);

  const range = document.createElement('input');
  range.type = 'range';
  range.id = 'P_POS';
  range.min = priorCfg && priorCfg.min !== undefined ? priorCfg.min : 0;
  range.max = priorCfg && priorCfg.max !== undefined ? priorCfg.max : 1;
  range.step = priorCfg && priorCfg.step !== undefined ? priorCfg.step : 0.01;
  range.value = values.P_POS;
  range.style.flex = '1';

  const numberInput = document.createElement('input');
  numberInput.type = 'number';
  numberInput.className = 'payoff-input-number';
  numberInput.min = range.min;
  numberInput.max = range.max;
  numberInput.step = range.step;
  numberInput.value = values.P_POS;

  const sliderRow = document.createElement('div');
  sliderRow.className = 'slider-input-row';
  sliderRow.appendChild(range);
  sliderRow.appendChild(numberInput);

  wrapper.appendChild(headerRow);
  wrapper.appendChild(sliderRow);
  bindSliderWithNumber({slider: range, numberInput, valueSpan, key: 'P_POS'});

  const nWrapper = document.createElement('div');
  nWrapper.style.marginTop = '12px';
  const nHeader = document.createElement('div');
  nHeader.style.display = 'flex';
  nHeader.style.justifyContent = 'space-between';
  nHeader.style.alignItems = 'center';
  const nLabel = document.createElement('span');
  nLabel.textContent = (sampleCfg && sampleCfg.label) || 'Sample size (N)';
  const nValueSpan = document.createElement('span');
  nValueSpan.id = 'NVal';
  nValueSpan.textContent = values.N;
  nHeader.appendChild(nLabel);
  nHeader.appendChild(nValueSpan);

  const nRange = document.createElement('input');
  nRange.type = 'range';
  nRange.id = 'N';
  nRange.min = sampleCfg && sampleCfg.min !== undefined ? sampleCfg.min : 10;
  nRange.max = sampleCfg && sampleCfg.max !== undefined ? sampleCfg.max : 100000;
  nRange.step = sampleCfg && sampleCfg.step !== undefined ? sampleCfg.step : 10;
  nRange.value = values.N;
  nRange.style.flex = '1';

  const nNumberInput = document.createElement('input');
  nNumberInput.type = 'number';
  nNumberInput.className = 'payoff-input-number';
  nNumberInput.min = nRange.min;
  nNumberInput.max = nRange.max;
  nNumberInput.step = nRange.step;
  nNumberInput.value = values.N;

  const nSliderRow = document.createElement('div');
  nSliderRow.className = 'slider-input-row';
  nSliderRow.appendChild(nRange);
  nSliderRow.appendChild(nNumberInput);

  nWrapper.appendChild(nHeader);
  nWrapper.appendChild(nSliderRow);
  bindSliderWithNumber({slider: nRange, numberInput: nNumberInput, valueSpan: nValueSpan, key: 'N'});

  priorControls.appendChild(wrapper);
  priorControls.appendChild(nWrapper);
}

function buildPayoffGrid(){
  if(!payoffGridSection) return;
  const payoffCfg = getPayoffConfig();
  const payoffKeys = ['TP','FN','FP','TN'];
  payoffKeys.forEach(key=>{
    const cfg = payoffCfg[key] || {};
    const defaultVal = Number(cfg.value);
    ensureValue(key, Number.isFinite(defaultVal) ? defaultVal : 0);
  });
  payoffGridSection.innerHTML = '';
  if(!isSlidersVisible()) return;

  const gridStrings = strings.payoffGrid || defaultConfig.strings.payoffGrid || {};
  const mode = getPayoffInputMode();

  const table = document.createElement('table');
  table.className = 'payoff-grid';

  const thead = document.createElement('thead');
  const headerRow = document.createElement('tr');
  headerRow.appendChild(document.createElement('th'));
  const colPos = document.createElement('th');
  colPos.textContent = gridStrings.predictedPositive || 'Predicted Positive';
  headerRow.appendChild(colPos);
  const colNeg = document.createElement('th');
  colNeg.textContent = gridStrings.predictedNegative || 'Predicted Negative';
  headerRow.appendChild(colNeg);
  thead.appendChild(headerRow);
  table.appendChild(thead);

  const tbody = document.createElement('tbody');

  const rowPos = document.createElement('tr');
  const rowPosHeader = document.createElement('th');
  rowPosHeader.textContent = gridStrings.actualPositive || 'Actual Positive';
  rowPos.appendChild(rowPosHeader);
  rowPos.appendChild(createPayoffCell('TP', payoffCfg, mode));
  rowPos.appendChild(createPayoffCell('FN', payoffCfg, mode));
  tbody.appendChild(rowPos);

  const rowNeg = document.createElement('tr');
  const rowNegHeader = document.createElement('th');
  rowNegHeader.textContent = gridStrings.actualNegative || 'Actual Negative';
  rowNeg.appendChild(rowNegHeader);
  rowNeg.appendChild(createPayoffCell('FP', payoffCfg, mode));
  rowNeg.appendChild(createPayoffCell('TN', payoffCfg, mode));
  tbody.appendChild(rowNeg);

  table.appendChild(tbody);
  payoffGridSection.appendChild(table);
}

function createPayoffCell(key, payoffCfg, mode){
  const cfg = payoffCfg[key] || {};
  const gridStrings = strings.payoffGrid || defaultConfig.strings.payoffGrid || {};
  const cell = document.createElement('td');
  const wrapper = document.createElement('div');
  wrapper.className = 'payoff-cell';

  const label = document.createElement('div');
  label.className = 'payoff-cell-label';
  label.textContent = cfg.label || gridStrings[key] || key;
  wrapper.appendChild(label);

  if(mode === 'text'){
    const input = document.createElement('input');
    input.type = 'number';
    input.className = 'payoff-input-number';
    if(cfg.min !== undefined) input.min = cfg.min;
    if(cfg.max !== undefined) input.max = cfg.max;
    if(cfg.step !== undefined) input.step = cfg.step;
    input.value = values[key];
    input.addEventListener('input',()=>{
      const parsed = Number(input.value);
      if(Number.isFinite(parsed)){
        values[key] = parsed;
        drawAll();
      }
    });
    input.addEventListener('blur',()=>{
      if(!Number.isFinite(Number(input.value))){
        input.value = values[key];
      }
    });
    wrapper.appendChild(input);
  }else{
    const range = document.createElement('input');
    range.type = 'range';
    range.min = cfg.min ?? -100;
    range.max = cfg.max ?? 100;
    range.step = cfg.step ?? 1;
    range.value = values[key];
    range.style.width = '100%';
    const numberInput = document.createElement('input');
    numberInput.type = 'number';
    numberInput.className = 'payoff-input-number';
    numberInput.min = range.min;
    numberInput.max = range.max;
    numberInput.step = range.step;
    numberInput.value = values[key];

    const sliderStack = document.createElement('div');
    sliderStack.className = 'slider-input-column';
    sliderStack.appendChild(range);
    sliderStack.appendChild(numberInput);

    wrapper.appendChild(sliderStack);
    bindSliderWithNumber({slider: range, numberInput, valueSpan: null, key});
  }

  cell.appendChild(wrapper);
  return cell;
}

rocSelect.onchange = () => drawAll();
rocFileInput.addEventListener('change', handleDataFileSelection);
downloadCurveBtn.addEventListener('click', downloadSelectedCurveAsJson);

function handleDataFileSelection(evt){
  const inputEl=evt.target;
  const file=inputEl.files && inputEl.files[0];
  if(!file) return;
  const reader=new FileReader();
  reader.onload=()=>{
    try{
      const text=reader.result;
      const ext=(file.name.split('.').pop()||'').toLowerCase();
      const {data:parsed, sourceType}=parseRocDataFromText(text, ext);
      if(!parsed || !Object.keys(parsed).length){
        alertFromConfig('noCurvesFound');
        return;
      }
      const mergedMetadataKey=file.name || (sourceType==='json'?'import.json':'import.csv');
      const merged={...rocCurves};
      const addedIds=addCurvesToCollection(merged, parsed, {sourceType, sourceFile: mergedMetadataKey});
      if(!addedIds.length){
        alertFromConfig('noCurvesFound');
        return;
      }
      loadROCData(merged,addedIds[0]);
    }catch(err){
      console.error(err);
      alertFromConfig('failImport', {message: err.message});
    }finally{
      inputEl.value='';
    }
  };
  reader.onerror=()=>{
    console.error(reader.error);
    alertFromConfig('failRead', {message: reader.error ? reader.error.message : ''});
    inputEl.value='';
  };
  reader.readAsText(file);
}

function downloadSelectedCurveAsJson(){
  const curveName=rocSelect.value;
  if(!curveName || !rocCurves[curveName]){
    alertFromConfig('noCurveSelectedDownload');
    return;
  }
  const curve=rocCurves[curveName];
  const serialized=JSON.stringify(curve,null,2);
  const blob=new Blob([serialized],{type:'application/json'});
  const url=URL.createObjectURL(blob);
  const link=document.createElement('a');
  link.href=url;
  link.download=`${curveName}.json`;
  document.body.appendChild(link);
  link.click();
  setTimeout(()=>{document.body.removeChild(link);URL.revokeObjectURL(url);},0);
}

function drawAll(){
  if(isRocPlotVisible()){
    drawRocPlot();
  }else{
    ctx.clearRect(0,0,canvas.width,canvas.height);
  }
  if(isGainPlotVisible()){
    drawGainPlot();
  }else if(gainCtx){
    gainCtx.clearRect(0,0,gainCanvas.width,gainCanvas.height);
  }
  if(isPRPlotVisible()){
    drawPRPlot();
  }else if(prCtx){
    prCtx.clearRect(0,0,prCanvas.width,prCanvas.height);
  }
  updateConfusionMatrix();
  if(isThresholdPlotVisible()){
    drawThresholdPlot();
  }else if(thresholdCtx){
    thresholdCtx.clearRect(0,0,thresholdCanvas.width,thresholdCanvas.height);
  }
}

function parseRocDataFromText(text, extHint){
  const normalizedExt = (extHint || '').toLowerCase();
  const parserOrder = normalizedExt==='json'
    ? ['json','csv']
    : normalizedExt==='csv'
      ? ['csv','json']
      : ['json','csv'];
  let lastError=null;
  for(const parser of parserOrder){
    try{
      if(parser==='json'){
        const raw=JSON.parse(text);
        const parsed=normalizeRocJson(raw);
        if(parsed && Object.keys(parsed).length){
          return {data:parsed, sourceType:'json'};
        }
      }else if(parser==='csv'){
        const parsed=parseRocCsv(text);
        if(parsed && Object.keys(parsed).length){
          return {data:parsed, sourceType:'csv'};
        }
      }
    }catch(err){
      lastError=err;
    }
  }
  if(lastError) throw lastError;
  throw new Error(getAlertTemplate('noCurvesFound'));
}

function slugifyLabel(value){
  return String(value||'curve').toLowerCase().replace(/[^a-z0-9]+/g,'-').replace(/^-+|-+$/g,'')||'curve';
}

function addCurvesToCollection(target, parsed, {sourceType, sourceFile} = {}){
  const addedIds=[];
  if(!parsed || typeof parsed!=='object') return addedIds;
  const suffixRoot=slugifyLabel(sourceFile ? sourceFile.split('/').pop().replace(/\.[^.]+$/,'') : '');
  Object.keys(parsed).forEach(originalId=>{
    const baseCurve=parsed[originalId];
    if(!baseCurve) return;
    const curve={...baseCurve};
    const metadata={...(curve.metadata||{})};
    if(sourceType){
      metadata.loaded_via=sourceType;
      if(!metadata.source) metadata.source=sourceType;
    }
    if(sourceFile){
      metadata.source_file=sourceFile;
      metadata.loaded_file=sourceFile;
    }
    if(originalId && metadata.original_curve_id===undefined) metadata.original_curve_id=originalId;
    let baseId=curve.name || originalId || (suffixRoot || 'curve');
    baseId=String(baseId);
    let finalId=baseId;
    if(target[finalId]){
      const baseSlug=slugifyLabel(baseId);
      const suffixBaseRaw = (suffixRoot && suffixRoot !== baseSlug) ? suffixRoot : (sourceType ? slugifyLabel(sourceType) : 'alt');
      const suffixBase = suffixBaseRaw || 'alt';
      let candidate=`${baseId}__${suffixBase}`;
      let counter=2;
      while(target[candidate]){
        candidate=`${baseId}__${suffixBase}_${counter}`;
        counter++;
      }
      finalId=candidate;
    }
    curve.name=finalId;
    curve.metadata=metadata;
    target[finalId]=curve;
    addedIds.push(finalId);
  });
  return addedIds;
}

async function loadStaticRocFiles(){
  if(isFileProtocol){
    console.warn('Skipping static ROC file loads in file:// context; using embedded/fallback curves only.');
    return false;
  }
  let preferredSelection=null;
  let loadedAny=false;
  const merged={...rocCurves};
  const fileList = (appConfig && appConfig.data && Array.isArray(appConfig.data.staticFiles) && appConfig.data.staticFiles.length)
    ? appConfig.data.staticFiles
    : STATIC_DATA_FILES;
  for(const filePath of fileList){
    if(typeof filePath!=='string' || !filePath.trim()) continue;
    const trimmedPath=filePath.trim();
    try{
      const response=await fetch(trimmedPath);
      if(!response.ok) throw new Error(`HTTP ${response.status}`);
      const text=await response.text();
      const {data:parsed, sourceType}=parseRocDataFromText(text, trimmedPath.split('.').pop());
      const addedIds=addCurvesToCollection(merged, parsed, {sourceType, sourceFile: trimmedPath});
      if(addedIds.length){
        loadedAny=true;
        if(!preferredSelection) preferredSelection=addedIds[0];
      }
    }catch(err){
      console.error(err);
      warnFromConfig('failStaticLoad', {path: trimmedPath, message: err.message || err});
    }
  }
  if(loadedAny){
    loadROCData(merged,preferredSelection);
  }
  return loadedAny;
}

function parseRocCsv(text){
  if(!text || !text.trim()) throw new Error('CSV file is empty.');
  const rawLines=text.split(/\r?\n/);
  const lines=[];
  for(const line of rawLines){
    if(!line) continue;
    const trimmed=line.trim();
    if(!trimmed || trimmed.startsWith('#')) continue;
    lines.push(line);
  }
  if(lines.length<2) throw new Error('CSV must include a header row and at least one data row.');

  const headers=splitCsvLine(lines[0]).map(h=>h.trim());
  if(!headers.length) throw new Error('CSV header row is empty.');
  const indexMap={};
  headers.forEach((header,idx)=>{ if(header) indexMap[header]=idx; });

  const required=['curve_id','fpr','tpr'];
  const missing=required.filter(name=>!(name in indexMap));
  if(missing.length) throw new Error(`Missing required column(s): ${missing.join(', ')}`);

  const curveIdx=indexMap.curve_id;
  const fprIdx=indexMap.fpr;
  const tprIdx=indexMap.tpr;
  const thresholdIdx=Object.prototype.hasOwnProperty.call(indexMap,'threshold')?indexMap.threshold:-1;
  const simpleLowerIdx=Object.prototype.hasOwnProperty.call(indexMap,'tpr_lower')?indexMap.tpr_lower:-1;
  const simpleUpperIdx=Object.prototype.hasOwnProperty.call(indexMap,'tpr_upper')?indexMap.tpr_upper:-1;

  const bandIndexMap={};
  headers.forEach((header,idx)=>{
    const match=header.match(/^tpr_(lower|upper)_(\d+(?:\.\d+)*)$/);
    if(match){
      const type=match[1];
      const levelKey=match[2];
      if(!bandIndexMap[levelKey]) bandIndexMap[levelKey]={};
      bandIndexMap[levelKey][type]=idx;
    }
  });

  const usedIndexes=new Set([curveIdx,fprIdx,tprIdx]);
  if(thresholdIdx!==-1) usedIndexes.add(thresholdIdx);
  if(simpleLowerIdx!==-1) usedIndexes.add(simpleLowerIdx);
  if(simpleUpperIdx!==-1) usedIndexes.add(simpleUpperIdx);
  Object.values(bandIndexMap).forEach(cols=>{
    if(typeof cols.lower==='number') usedIndexes.add(cols.lower);
    if(typeof cols.upper==='number') usedIndexes.add(cols.upper);
  });

  const extraColumns=headers
    .map((header,idx)=>({header,idx}))
    .filter(item=>!usedIndexes.has(item.idx));

  const groups={};
  for(let i=1;i<lines.length;i++){
    const row=splitCsvLine(lines[i]);
    if(!row.length || row.every(cell=>cell.trim()==='')) continue;
    const curveIdRaw=row[curveIdx]!==undefined?row[curveIdx].trim():'';
    if(!curveIdRaw) continue;
    const fpr=toNumber(row[fprIdx]);
    const tpr=toNumber(row[tprIdx]);
    if(!Number.isFinite(fpr)||!Number.isFinite(tpr)) continue;

    let group=groups[curveIdRaw];
    if(!group){
      group={
        fpr:[],
        tpr:[],
        threshold:thresholdIdx!==-1?[]:null,
        simpleLower:simpleLowerIdx!==-1?[]:null,
        simpleUpper:simpleUpperIdx!==-1?[]:null,
        bands:{},
        metadataValues:{}
      };
      Object.keys(bandIndexMap).forEach(levelKey=>{
        group.bands[levelKey]={lower:[],upper:[]};
      });
      groups[curveIdRaw]=group;
    }

    group.fpr.push(fpr);
    group.tpr.push(tpr);

    if(group.threshold){
      const value=toNumber(row[thresholdIdx]);
      group.threshold.push(Number.isFinite(value)?value:null);
    }
    if(group.simpleLower){
      const value=toNumber(row[simpleLowerIdx]);
      group.simpleLower.push(Number.isFinite(value)?value:null);
    }
    if(group.simpleUpper){
      const value=toNumber(row[simpleUpperIdx]);
      group.simpleUpper.push(Number.isFinite(value)?value:null);
    }

    Object.keys(bandIndexMap).forEach(levelKey=>{
      const band=group.bands[levelKey];
      const lowerIdx=bandIndexMap[levelKey].lower;
      const upperIdx=bandIndexMap[levelKey].upper;
      if(typeof lowerIdx==='number'){
        const value=toNumber(row[lowerIdx]);
        band.lower.push(Number.isFinite(value)?value:null);
      }else{
        band.lower.push(null);
      }
      if(typeof upperIdx==='number'){
        const value=toNumber(row[upperIdx]);
        band.upper.push(Number.isFinite(value)?value:null);
      }else{
        band.upper.push(null);
      }
    });

    extraColumns.forEach(({header,idx})=>{
      const value=row[idx];
      if(value===undefined) return;
      const trimmed=value.trim();
      if(!trimmed) return;
      if(!group.metadataValues[header]) group.metadataValues[header]=new Set();
      group.metadataValues[header].add(trimmed);
    });
  }

  const result={};
  Object.keys(groups).forEach(curveId=>{
    const group=groups[curveId];
    if(!group.fpr.length || !group.tpr.length) return;
    const curve={name:curveId,type:'ROC',fpr:group.fpr,tpr:group.tpr};

    if(group.threshold && group.threshold.some(Number.isFinite)){
      curve.threshold=group.threshold;
    }
    if(group.simpleLower && group.simpleUpper && group.simpleLower.some(Number.isFinite) && group.simpleUpper.some(Number.isFinite)){
      curve.tpr_lower=group.simpleLower;
      curve.tpr_upper=group.simpleUpper;
    }

    const bandEntries=Object.keys(group.bands).map(levelKey=>{
      const level=parseFloat(levelKey);
      const lowerArr=group.bands[levelKey].lower;
      const upperArr=group.bands[levelKey].upper;
      const hasLower=lowerArr.some(Number.isFinite);
      const hasUpper=upperArr.some(Number.isFinite);
      return {
        level:Number.isFinite(level)?level:levelKey,
        lower:hasLower?lowerArr:[],
        upper:hasUpper?upperArr:[]
      };
    }).filter(b=>b.lower.length||b.upper.length);

    if(bandEntries.length){
      bandEntries.sort((a,b)=>{
        const aVal=typeof a.level==='number'?a.level:parseFloat(a.level)||0;
        const bVal=typeof b.level==='number'?b.level:parseFloat(b.level)||0;
        return aVal-bVal;
      });
      curve.bands=bandEntries;
      if(!curve.tpr_lower && !curve.tpr_upper){
        const fallback=bandEntries[bandEntries.length-1];
        if(fallback){
          if(fallback.lower.length) curve.tpr_lower=fallback.lower;
          if(fallback.upper.length) curve.tpr_upper=fallback.upper;
        }
      }
    }

    const metadata={source:'csv'};
    Object.keys(group.metadataValues).forEach(key=>{
      const values=Array.from(group.metadataValues[key]);
      if(values.length===1){
        metadata[key]=values[0];
      }
    });
    curve.metadata=metadata;

    result[curveId]=curve;
  });

  return result;
}

function normalizeRocJson(raw){
  if(raw===null || raw===undefined) throw new Error('JSON content is empty.');
  const result={};

  const coerceNumericArray=(arr,{allowNull=false,label})=>{
    if(!Array.isArray(arr)) throw new Error(`${label} must be an array.`);
    return arr.map((value,idx)=>{
      if(value===null || value===undefined || value===''){
        if(allowNull) return null;
        throw new Error(`${label} has missing value at index ${idx}.`);
      }
      if(typeof value==='number' && Number.isFinite(value)) return value;
      const num=toNumber(value);
      if(Number.isFinite(num)) return num;
      if(allowNull) return null;
      throw new Error(`${label} has non-numeric value at index ${idx}.`);
    });
  };

  const addCurve=(curveObj,keyHint)=>{
    if(!curveObj || typeof curveObj!=='object' || Array.isArray(curveObj)){
      throw new Error(`Curve entry "${keyHint}" must be an object.`);
    }
    const curveId=curveObj.name || curveObj.curve_id || keyHint;
    if(!curveId) throw new Error('Curve entry is missing a name or curve_id.');
    if(!Array.isArray(curveObj.fpr)) throw new Error(`${curveId}.fpr must be an array.`);
    if(!Array.isArray(curveObj.tpr)) throw new Error(`${curveId}.tpr must be an array.`);
    const fpr=coerceNumericArray(curveObj.fpr,{allowNull:false,label:`${curveId}.fpr`});
    const tpr=coerceNumericArray(curveObj.tpr,{allowNull:false,label:`${curveId}.tpr`});
    if(fpr.length!==tpr.length) throw new Error(`${curveId} has mismatched fpr/tpr lengths.`);

    const normalized={
      name: curveId,
      type: curveObj.type || 'ROC',
      fpr,
      tpr
    };

    if(curveObj.threshold!==undefined){
      if(!Array.isArray(curveObj.threshold)) throw new Error(`${curveId}.threshold must be an array.`);
      const threshold=coerceNumericArray(curveObj.threshold,{allowNull:true,label:`${curveId}.threshold`});
      if(threshold.length!==fpr.length) throw new Error(`${curveId}.threshold length must match fpr/tpr.`);
      normalized.threshold=threshold;
    }
    if(curveObj.tpr_lower!==undefined){
      if(!Array.isArray(curveObj.tpr_lower)) throw new Error(`${curveId}.tpr_lower must be an array.`);
      const lower=coerceNumericArray(curveObj.tpr_lower,{allowNull:true,label:`${curveId}.tpr_lower`});
      if(lower.length!==fpr.length) throw new Error(`${curveId}.tpr_lower length must match fpr/tpr.`);
      normalized.tpr_lower=lower;
    }
    if(curveObj.tpr_upper!==undefined){
      if(!Array.isArray(curveObj.tpr_upper)) throw new Error(`${curveId}.tpr_upper must be an array.`);
      const upper=coerceNumericArray(curveObj.tpr_upper,{allowNull:true,label:`${curveId}.tpr_upper`});
      if(upper.length!==fpr.length) throw new Error(`${curveId}.tpr_upper length must match fpr/tpr.`);
      normalized.tpr_upper=upper;
    }
    if(Array.isArray(curveObj.bands)){
      const bands=curveObj.bands.map((band,index)=>{
        if(!band || typeof band!=='object' || Array.isArray(band)){
          throw new Error(`${curveId}.bands[${index}] must be an object.`);
        }
        const level=band.level!==undefined?band.level:(band.credible_level!==undefined?band.credible_level:band.confidence_level!==undefined?band.confidence_level:(index+1));
        const lower=band.lower!==undefined?coerceNumericArray(band.lower,{allowNull:true,label:`${curveId}.bands[${index}].lower`}):[];
        const upper=band.upper!==undefined?coerceNumericArray(band.upper,{allowNull:true,label:`${curveId}.bands[${index}].upper`}):[];
        if(lower.length && lower.length!==fpr.length) throw new Error(`${curveId}.bands[${index}].lower length must match fpr/tpr.`);
        if(upper.length && upper.length!==fpr.length) throw new Error(`${curveId}.bands[${index}].upper length must match fpr/tpr.`);
        return {
          level,
          lower,
          upper
        };
      }).filter(band=>band.lower.length || band.upper.length);
      if(bands.length) normalized.bands=bands;
    }
    if(curveObj.metadata && typeof curveObj.metadata==='object' && !Array.isArray(curveObj.metadata)){
      normalized.metadata={...curveObj.metadata};
    }
    result[curveId]=normalized;
  };

  if(Array.isArray(raw)){
    raw.forEach((curve,idx)=>{
      if(curve && typeof curve==='object' && Array.isArray(curve.fpr) && Array.isArray(curve.tpr)){
        addCurve(curve, curve.name || curve.curve_id || `curve_${idx}`);
      }
    });
  }else if(typeof raw==='object'){
    if(Array.isArray(raw.curves)){
      raw.curves.forEach((curve,idx)=>{
        if(curve && typeof curve==='object' && Array.isArray(curve.fpr) && Array.isArray(curve.tpr)){
          addCurve(curve, curve.name || curve.curve_id || `curve_${idx}`);
        }
      });
    }
    Object.keys(raw).forEach(key=>{
      if(key==='curves' && Array.isArray(raw[key])) return;
      const candidate=raw[key];
      if(candidate && typeof candidate==='object' && Array.isArray(candidate.fpr) && Array.isArray(candidate.tpr)){
        addCurve(candidate, key);
      }
    });
  }else{
    throw new Error('JSON root must be an array or object.');
  }

  return result;
}

function splitCsvLine(line){
  const result=[];
  let current='';
  let inQuotes=false;
  for(let i=0;i<line.length;i++){
    const char=line[i];
    if(char==='\"'){
      if(inQuotes && line[i+1]==='\"'){
        current+='\"';
        i++;
      }else{
        inQuotes=!inQuotes;
      }
    }else if(char===',' && !inQuotes){
      result.push(current);
      current='';
    }else{
      current+=char;
    }
  }
  result.push(current);
  return result;
}

function toNumber(value){
  if(value===undefined || value===null) return NaN;
  const trimmed=typeof value==='string'?value.trim():value;
  if(trimmed==='') return NaN;
  const num=Number(trimmed);
  return Number.isFinite(num)?num:NaN;
}

function hslToRgb(h,s,l){const a=s*Math.min(l,1-l);const f=n=>{const k=(n+h*12)%12;const color=l-a*Math.max(Math.min(k-3,9-k,1),-1);return Math.round(255*color);};return [f(0),f(8),f(4)];}
function heatColor(s){const h=240-240*s;const [r,g,b]=hslToRgb(h/360,0.6,0.85);return [r,g,b];}

function marchingSquares(grid,width,height,levels){
  const segments=[];
  const lerp=(a,b,t)=>a+(b-a)*t;
  const sample=(i,j)=>grid[j*width+i];
  const toCoord=(i,j)=>({x:i/(width-1), y:1 - j/(height-1)});
  levels.forEach(level=>{
    for(let j=0;j<height-1;j++){
      for(let i=0;i<width-1;i++){
        const tl=sample(i,j)>=level;
        const tr=sample(i+1,j)>=level;
        const br=sample(i+1,j+1)>=level;
        const bl=sample(i,j+1)>=level;
        const idx=(tl<<3)|(tr<<2)|(br<<1)|bl;
        if(idx===0||idx===15) continue;
        const vTL=sample(i,j), vTR=sample(i+1,j), vBR=sample(i+1,j+1), vBL=sample(i,j+1);
        const leftT=lerp(j,j+1,(level-vTL)/((vBL-vTL)||1));
        const rightT=lerp(j,j+1,(level-vTR)/((vBR-vTR)||1));
        const topT=lerp(i,i+1,(level-vTL)/((vTR-vTL)||1));
        const bottomT=lerp(i,i+1,(level-vBL)/((vBR-vBL)||1));
        const pLeft=toCoord(i,leftT);
        const pRight=toCoord(i+1,rightT);
        const pTop=toCoord(topT,j);
        const pBottom=toCoord(bottomT,j+1);
        const addSeg=(a,b)=>segments.push([a,b]);
        switch(idx){
          case 1: addSeg(pLeft,pBottom); break;
          case 2: addSeg(pBottom,pRight); break;
          case 3: addSeg(pLeft,pRight); break;
          case 4: addSeg(pTop,pRight); break;
          case 5: addSeg(pTop,pBottom); addSeg(pLeft,pRight); break;
          case 6: addSeg(pTop,pBottom); break;
          case 7: addSeg(pTop,pLeft); break;
          case 8: addSeg(pTop,pLeft); break;
          case 9: addSeg(pTop,pBottom); break;
          case 10: addSeg(pTop,pRight); addSeg(pLeft,pBottom); break;
          case 11: addSeg(pTop,pRight); break;
          case 12: addSeg(pLeft,pRight); break;
          case 13: addSeg(pBottom,pRight); break;
          case 14: addSeg(pLeft,pBottom); break;
        }
      }
    }
  });
  return segments;
}

function getRocPlotGeometry(width,height){
  const marginLeft=0.08*width;
  const marginRight=0.05*width;
  const marginTop=0.12*height;
  const marginBottom=0.10*height;
  const availableW=width - marginLeft - marginRight;
  const availableH=height - marginTop - marginBottom;
  const plotSize=Math.min(availableW, availableH);
  const x0=marginLeft + (availableW-plotSize)/2;
  const y0=marginTop + (availableH-plotSize)/2;
  const plotW=plotSize;
  const plotH=plotSize;
  const titleY = marginTop * 0.5;
  const subtitleY = titleY + 18;
  return {x0,y0,plotW,plotH,titleY,subtitleY};
}

function drawRocPlot(){
  const rocName=rocSelect.value;
  if(!rocName || !rocCurves[rocName]){
    ctx.clearRect(0,0,canvas.width,canvas.height);
    if(bestUtilityDiv && isBestUtilityVisible()){
      bestUtilityDiv.textContent = strings.bestUtilityUnavailable || defaultConfig.strings.bestUtilityUnavailable;
    }
    return;
  }
  const roc=rocCurves[rocName];
  const fpr=roc.fpr, tpr=roc.tpr;
  let lower=roc.tpr_lower, upper=roc.tpr_upper;
  if((!lower || !upper) && Array.isArray(roc.bands) && roc.bands.length){
    const sortedBands=[...roc.bands].sort((a,b)=>{
      const aVal=typeof a.level==='number'?a.level:parseFloat(a.level)||0;
      const bVal=typeof b.level==='number'?b.level:parseFloat(b.level)||0;
      return aVal-bVal;
    });
    const fallback=sortedBands[sortedBands.length-1];
    if(fallback){
      if(!lower) lower=fallback.lower;
      if(!upper) upper=fallback.upper;
    }
  }
  const payoffs=getPayoffParams();
  const {P_POS: pPos, TP, FP, TN, FN} = payoffs;
  const width=canvas.width, height=canvas.height;

  const {x0,y0,plotW,plotH,titleY,subtitleY}=getRocPlotGeometry(width,height);
  const labelOffsetFactor = 0.6; const labelOffset = labelOffsetFactor * 0.05;
  const xScale=(xf)=>x0+xf*plotW; const yScale=(yt)=>y0+(1-yt)*plotH;
  const clamp01=(v)=>Math.max(0,Math.min(1,v));

  const {a,b,c}=getIsoCoefficients(payoffs);
  const isoEnabled=Number.isFinite(c) && Math.abs(c)>1e-9;

  ctx.clearRect(0,0,width,height);

  const titleText = strings.rocPlotTitle || defaultConfig.strings.rocPlotTitle || '';
  const subtitleText = resolveVariantLabel(rocName, roc.metadata || {});
  ctx.fillStyle = '#000';
  ctx.textAlign = 'center';
  ctx.font = '16px sans-serif';
  ctx.fillText(titleText, width/2, titleY);
  ctx.font = '13px sans-serif';
  ctx.fillText(subtitleText, width/2, subtitleY);

  const iw=Math.max(2,Math.floor(plotW)); const ih=Math.max(2,Math.floor(plotH));
  const img=ctx.createImageData(iw,ih); const data=img.data; let minU=Infinity,maxU=-Infinity; const utilities=[];
  for(let j=0;j<ih;j++){
    const tprVal=1-j/(ih-1);
    for(let i=0;i<iw;i++){
      const fprVal=i/(iw-1);
      const u=utilityAtRates(fprVal,tprVal,payoffs);
      utilities.push(u);
      if(u<minU)minU=u;
      if(u>maxU)maxU=u;
    }
  }
  const scale=v=>(v-minU)/(maxU-minU||1);
  let k=0;for(let j=0;j<ih;j++){for(let i=0;i<iw;i++){const s=scale(utilities[j*iw+i]);const [r,g,b2]=heatColor(s);data[k++]=r;data[k++]=g;data[k++]=b2;data[k++]=255;}}
  ctx.putImageData(img,Math.round(x0),Math.round(y0));

  ctx.save();
  ctx.beginPath(); ctx.rect(x0,y0,plotW,plotH); ctx.clip();

  if(isoEnabled){
    const nLines=10;
    const step=(maxU-minU)/(nLines+1||1);
    ctx.strokeStyle='rgba(0,0,0,0.4)'; ctx.lineWidth=1; ctx.setLineDash([4,4]);
    ctx.font='12px sans-serif'; ctx.fillStyle='black'; ctx.textBaseline='middle';
    for(let i=1;i<=nLines;i++){
      const level=minU+i*step;
      const tpr0=(level-a-b*0)/c; const tpr1=(level-a-b*1)/c;
      if(!Number.isFinite(tpr0) || !Number.isFinite(tpr1)) continue;
      const yA=yScale(tpr0), yB=yScale(tpr1);
      ctx.beginPath(); ctx.moveTo(xScale(0),yA); ctx.lineTo(xScale(1),yB); ctx.stroke();

      const tprLeft=(level-a)/c;
      const fprBottom=(level-a)/b;
      const offsetX = labelOffset * plotW; const offsetY = labelOffset * plotH;
      if(Number.isFinite(tprLeft) && tprLeft>=0 && tprLeft<=1){
        const xL=xScale(0)+offsetX; const yL=yScale(tprLeft);
        ctx.fillText(Math.round(level),xL,yL);
      } else if(Number.isFinite(fprBottom) && fprBottom>=0 && fprBottom<=1){
        const xB=xScale(clamp01(fprBottom)); const yBtm=yScale(0)-offsetY;
        ctx.textAlign='center'; ctx.fillText(Math.round(level),xB,yBtm); ctx.textAlign='left';
      }
    }
    ctx.setLineDash([]);
  }
  else{
    ctx.setLineDash([]);
  }

  const denominator = (pPos*(TP-FN));
  if(denominator){
    const s=((1-pPos)*(TN-FP))/denominator;
    ctx.strokeStyle='limegreen'; ctx.lineWidth=3; ctx.setLineDash([10,10]);
    const drawOne=(intercept)=>{ctx.beginPath();ctx.moveTo(xScale(0),yScale(intercept));ctx.lineTo(xScale(1),yScale(s+intercept));ctx.stroke();};
    drawOne(0); drawOne(1-s); ctx.setLineDash([]);
  }

  ctx.restore();

  if(Array.isArray(lower) && Array.isArray(upper) && lower.length===fpr.length && upper.length===fpr.length){
    ctx.beginPath(); ctx.moveTo(xScale(fpr[0]),yScale(upper[0])); for(let i=1;i<fpr.length;i++)ctx.lineTo(xScale(fpr[i]),yScale(upper[i])); for(let i=fpr.length-1;i>=0;i--)ctx.lineTo(xScale(fpr[i]),yScale(lower[i])); ctx.closePath(); ctx.fillStyle='rgba(0,0,255,0.2)'; ctx.fill();
    ctx.beginPath(); ctx.strokeStyle='rgba(0,0,180,0.6)'; ctx.lineWidth=1;
    for(let i=0;i<fpr.length;i++){if(i===0)ctx.moveTo(xScale(fpr[i]),yScale(upper[i]));else ctx.lineTo(xScale(fpr[i]),yScale(upper[i]));} ctx.stroke();
    ctx.beginPath(); for(let i=0;i<fpr.length;i++){if(i===0)ctx.moveTo(xScale(fpr[i]),yScale(lower[i]));else ctx.lineTo(xScale(fpr[i]),yScale(lower[i]));} ctx.stroke();
  }

  let bestU=-Infinity,bestPt=null,bestIdx=-1;
  ctx.beginPath(); ctx.strokeStyle='blue'; ctx.lineWidth=2;
  let firstPoint=true;
  for(let i=0;i<fpr.length;i++){
    const fVal=Number(fpr[i]);
    const tVal=Number(tpr[i]);
    if(!Number.isFinite(fVal) || !Number.isFinite(tVal)) continue;
    const x=xScale(fVal),y=yScale(tVal);
    if(firstPoint){ctx.moveTo(x,y); firstPoint=false;} else ctx.lineTo(x,y);
    const u=utilityAtRates(fVal,tVal,payoffs);
    if(Number.isFinite(u) && u>bestU){bestU=u;bestPt={x,y};bestIdx=i;}
  }
  if(!firstPoint) ctx.stroke();
  if(bestPt){
    ctx.beginPath();ctx.arc(bestPt.x,bestPt.y,6,0,2*Math.PI);
    ctx.fillStyle='yellow';ctx.strokeStyle='red';ctx.fill();ctx.stroke();
    lastRocBestUtility = bestU;
    lastRocBestIdx = bestIdx;
    lastBestPoint = {fpr: Number(fpr[bestIdx]), tpr: Number(tpr[bestIdx])};
    if(bestUtilityDiv && isBestUtilityVisible()){
      const prefix = strings.bestUtilityPrefix || defaultConfig.strings.bestUtilityPrefix;
      bestUtilityDiv.textContent = `${prefix}${Math.round(bestU)}`;
    }
  } else if(bestUtilityDiv && isBestUtilityVisible()){
    bestUtilityDiv.textContent = strings.bestUtilityUnavailable || defaultConfig.strings.bestUtilityUnavailable;
  }

  ctx.strokeStyle='#666'; ctx.lineWidth=1; ctx.strokeRect(x0,y0,plotW,plotH);

  ctx.strokeStyle='#333'; ctx.fillStyle='#333'; ctx.lineWidth=1;
  ctx.font='11px sans-serif'; ctx.textAlign='center'; ctx.textBaseline='top';
  const tickCount=11;
  for(let i=0;i<tickCount;i++){
    const val=i/10;
    const x=xScale(val);
    const yBottom=yScale(0);
    ctx.beginPath(); ctx.moveTo(x,yBottom); ctx.lineTo(x,yBottom+6); ctx.stroke();
    ctx.fillText(val.toFixed(1), x, yBottom+8);
  }
  ctx.textAlign='right'; ctx.textBaseline='middle';
  for(let i=0;i<tickCount;i++){
    const val=i/10;
    const y=yScale(val);
    const xLeft=xScale(0);
    ctx.beginPath(); ctx.moveTo(xLeft-6,y); ctx.lineTo(xLeft,y); ctx.stroke();
    ctx.fillText(val.toFixed(1), xLeft-8, y);
  }

  ctx.font='13px sans-serif'; ctx.textAlign='center'; ctx.textBaseline='top';
  const xAxisLabel=strings.rocXAxisLabel || defaultConfig.strings.rocXAxisLabel || '';
  ctx.fillText(xAxisLabel, x0 + plotW/2, y0 + plotH + 28);
  ctx.save();
  ctx.translate(x0 - 36, y0 + plotH/2);
  ctx.rotate(-Math.PI/2);
  const yAxisLabel=strings.rocYAxisLabel || defaultConfig.strings.rocYAxisLabel || '';
  ctx.textBaseline='top'; ctx.fillText(yAxisLabel, 0, 0);
  ctx.restore();
}

function drawGainPlot(){
  if(!gainCanvas || !gainCtx) return;
  const width=gainCanvas.width, height=gainCanvas.height;
  gainCtx.clearRect(0,0,width,height);
  if(!isGainPlotVisible()) return;
  const rocName=rocSelect.value;
  if(!rocName || !rocCurves[rocName]) return;
  const roc=rocCurves[rocName];
  const fprArr=roc.fpr, tprArr=roc.tpr;
  if(!Array.isArray(fprArr) || !Array.isArray(tprArr) || fprArr.length!==tprArr.length) return;
  const payoffs=getPayoffParams();
  const pPos=payoffs.P_POS;
  const {x0,y0,plotW,plotH,titleY,subtitleY}=getRocPlotGeometry(width,height);
  const xScale=(xf)=>x0+xf*plotW; const yScale=(yt)=>y0+(1-yt)*plotH;

  const iw=Math.max(2,Math.floor(plotW)); const ih=Math.max(2,Math.floor(plotH));
  const img=gainCtx.createImageData(iw,ih); const data=img.data;
  const utilityGrid=new Array(iw*ih);
  let minU=Infinity,maxU=-Infinity;
  for(let j=0;j<ih;j++){
    const tprVal=1-j/(ih-1);
    for(let i=0;i<iw;i++){
      const popFrac=i/(iw-1);
      const denom=Math.max(1e-9,1-pPos);
      let fprVal=(popFrac - pPos*tprVal)/denom;
      fprVal=Math.max(0,Math.min(1,fprVal));
      const u=utilityAtRates(fprVal,tprVal,payoffs);
      const idx=j*iw+i;
      utilityGrid[idx]=u;
      if(u<minU)minU=u;
      if(u>maxU)maxU=u;
    }
  }
  const scale=v=>(v-minU)/(maxU-minU||1);
  let k=0;for(let j=0;j<ih;j++){for(let i=0;i<iw;i++){const s=scale(utilityGrid[j*iw+i]);const [r,g,b]=heatColor(s);data[k++]=r;data[k++]=g;data[k++]=b;data[k++]=255;}}
  gainCtx.putImageData(img,Math.round(x0),Math.round(y0));

  gainCtx.fillStyle = '#000';
  gainCtx.textAlign = 'center';
  gainCtx.font = '16px sans-serif';
  const titleText = strings.gainPlotTitle || defaultConfig.strings.gainPlotTitle || '';
  gainCtx.fillText(titleText, width/2, titleY);
  gainCtx.font = '13px sans-serif';
  const subtitleText = resolveVariantLabel(rocName, roc.metadata || {});
  gainCtx.fillText(subtitleText, width/2, subtitleY);

  gainCtx.save();
  gainCtx.beginPath(); gainCtx.rect(x0,y0,plotW,plotH); gainCtx.clip();
  const styleCfg = (appConfig && appConfig.style) ? appConfig.style : (defaultConfig.style || {});
  const diagStyle = styleCfg.gainDiagonalLine || (defaultConfig.style && defaultConfig.style.gainDiagonalLine) || {color:'#666',width:1,dash:[]};
  const prevStyle = styleCfg.gainPrevalenceLine || (defaultConfig.style && defaultConfig.style.gainPrevalenceLine) || {color:'#1e88e5',width:1,dash:[5,3]};

  const gainPoints=[];
  const gainUtilities=[];
  const bestInfo={u:-Infinity, idx:-1, point:null};
  let forcedBestPoint=null;
  if(Number.isInteger(lastRocBestIdx) && lastRocBestIdx>=0 && lastRocBestIdx<fprArr.length){
    const fprVal=Number(fprArr[lastRocBestIdx]);
    const tprVal=Number(tprArr[lastRocBestIdx]);
    const popFrac=pPos*tprVal + (1-pPos)*fprVal;
    forcedBestPoint={x:popFrac,y:tprVal,fpr:fprVal,tpr:tprVal};
  }
  for(let i=0;i<fprArr.length;i++){
    const fprVal=Number(fprArr[i]);
    const tprVal=Number(tprArr[i]);
    if(!Number.isFinite(fprVal) || !Number.isFinite(tprVal)) continue;
    const popFrac=pPos*tprVal + (1-pPos)*fprVal;
    const uVal=utilityAtRates(fprVal,tprVal,payoffs);
    gainPoints.push({x:popFrac,y:tprVal,fpr:fprVal,tpr:tprVal});
    gainUtilities.push(uVal);
    if(Number.isFinite(uVal) && uVal>bestInfo.u){
      bestInfo.u=uVal; bestInfo.idx=gainPoints.length-1; bestInfo.point={x:popFrac,y:tprVal};
    }
  }
  const contourLevels=[];
  const contourCount=8;
  for(let i=1;i<=contourCount;i++){
    contourLevels.push(minU + (i/(contourCount+1))*(maxU-minU));
  }
  const contourSegments=marchingSquares(utilityGrid, iw, ih, contourLevels);
  gainCtx.strokeStyle='rgba(0,0,0,0.35)';
  gainCtx.lineWidth=1;
  contourSegments.forEach(seg=>{
    const [a,b]=seg;
    gainCtx.beginPath();
    gainCtx.moveTo(xScale(a.x), yScale(a.y));
    gainCtx.lineTo(xScale(b.x), yScale(b.y));
    gainCtx.stroke();
  });

  const drawGainCurve = !(uiSettings && uiSettings.showGainCurveInGainPlot===false);
  const drawLiftCurve = uiSettings && uiSettings.showLiftCurveInGainPlot;

  if(!(uiSettings && uiSettings.showGainDiagonalLine===false)){
    gainCtx.strokeStyle=diagStyle.color || '#666';
    gainCtx.lineWidth=diagStyle.width || 1;
    gainCtx.setLineDash(Array.isArray(diagStyle.dash)?diagStyle.dash:[]);
    gainCtx.beginPath(); gainCtx.moveTo(xScale(0), yScale(0)); gainCtx.lineTo(xScale(1), yScale(1)); gainCtx.stroke();
    gainCtx.setLineDash([]);
  }

  if(drawLiftCurve && !(uiSettings && uiSettings.showGainPrevalenceLine===false)){
    gainCtx.strokeStyle=prevStyle.color || '#1e88e5';
    gainCtx.lineWidth=prevStyle.width || 1;
    gainCtx.setLineDash(Array.isArray(prevStyle.dash)?prevStyle.dash:[5,3]);
    const yPrev=yScale(pPos);
    gainCtx.beginPath(); gainCtx.moveTo(xScale(0), yPrev); gainCtx.lineTo(xScale(1), yPrev); gainCtx.stroke();
    gainCtx.setLineDash([]);
  }

  const sortedPoints=[...gainPoints].sort((a,b)=>a.x-b.x);
  let maxLift=0;
  if(sortedPoints.length){
    sortedPoints.forEach(pt=>{
      const liftVal=pt.x>0 ? pt.y/pt.x : 0;
      if(liftVal>maxLift) maxLift=liftVal;
    });
  }
  const liftMultiplier = uiSettings && uiSettings.liftAxisMaxMultiplier ? uiSettings.liftAxisMaxMultiplier : defaultConfig.ui.liftAxisMaxMultiplier || 1.2;
  const liftMax = maxLift * (liftMultiplier || 1);

  if(drawGainCurve && sortedPoints.length){
    gainCtx.beginPath();
    sortedPoints.forEach((pt,idx)=>{
      const px=xScale(pt.x);
      const py=yScale(pt.y);
      if(idx===0) gainCtx.moveTo(px,py);
      else gainCtx.lineTo(px,py);
    });
    gainCtx.strokeStyle='blue';
    gainCtx.lineWidth=2;
    gainCtx.stroke();
  }

  if(drawLiftCurve && sortedPoints.length && liftMax>0){
    gainCtx.beginPath();
    sortedPoints.forEach((pt,idx)=>{
      const liftVal=pt.x>0 ? pt.y/pt.x : 0;
      const px=xScale(pt.x);
      const py=yScale(Math.min(1, liftVal / liftMax));
      if(idx===0) gainCtx.moveTo(px,py);
      else gainCtx.lineTo(px,py);
    });
    gainCtx.strokeStyle='#a52a2a';
    gainCtx.lineWidth=2;
    gainCtx.stroke();
  }

  const bestPointToDraw = drawGainCurve ? (forcedBestPoint || bestInfo.point) : null;
  if(bestPointToDraw){
    gainCtx.beginPath();
    gainCtx.arc(xScale(bestPointToDraw.x), yScale(bestPointToDraw.y), 6, 0, Math.PI*2);
    gainCtx.fillStyle='yellow';
    gainCtx.strokeStyle='red';
    gainCtx.fill();
    gainCtx.stroke();
  }

  gainCtx.restore();

  gainCtx.strokeStyle='#666'; gainCtx.lineWidth=1; gainCtx.strokeRect(x0,y0,plotW,plotH);

  if(drawLiftCurve && liftMax>0){
    gainCtx.strokeStyle='#333'; gainCtx.fillStyle='#333'; gainCtx.lineWidth=1;
    gainCtx.font='11px sans-serif'; gainCtx.textAlign='center'; gainCtx.textBaseline='middle';
    const tickCount=6;
    for(let i=0;i<tickCount;i++){
      const frac=i/(tickCount-1||1);
      const liftVal=frac*liftMax;
      const yTick=yScale(Math.min(1, liftVal/liftMax));
      gainCtx.beginPath(); gainCtx.moveTo(x0+plotW, yTick); gainCtx.lineTo(x0+plotW+6, yTick); gainCtx.stroke();
      gainCtx.textAlign='left';
      gainCtx.fillText(liftVal.toFixed(2), x0+plotW+8, yTick);
      gainCtx.textAlign='center';
    }
    const liftAxisLabel = (strings.plots && strings.plots.gain && strings.plots.gain.liftAxisLabel) || defaultConfig.strings.liftAxisLabel || (defaultConfig.strings.plots && defaultConfig.strings.plots.gain && defaultConfig.strings.plots.gain.liftAxisLabel) || '';
    gainCtx.save();
    gainCtx.translate(x0+plotW+40, y0+plotH/2);
    gainCtx.rotate(Math.PI/2);
    gainCtx.textBaseline='top';
    gainCtx.fillText(liftAxisLabel, 0, 0);
    gainCtx.restore();
  }

  gainCtx.strokeStyle='#333'; gainCtx.fillStyle='#333'; gainCtx.lineWidth=1;
  gainCtx.font='11px sans-serif'; gainCtx.textAlign='center'; gainCtx.textBaseline='top';
  const tickCount=11;
  for(let i=0;i<tickCount;i++){
    const val=i/10;
    const x=xScale(val);
    const yBottom=yScale(0);
    gainCtx.beginPath(); gainCtx.moveTo(x,yBottom); gainCtx.lineTo(x,yBottom+6); gainCtx.stroke();
    gainCtx.fillText(val.toFixed(1), x, yBottom+8);
  }
  gainCtx.textAlign='right'; gainCtx.textBaseline='middle';
  for(let i=0;i<tickCount;i++){
    const val=i/10;
    const y=yScale(val);
    const xLeft=xScale(0);
    gainCtx.beginPath(); gainCtx.moveTo(xLeft-6,y); gainCtx.lineTo(xLeft,y); gainCtx.stroke();
    gainCtx.fillText(val.toFixed(1), xLeft-8, y);
  }

  gainCtx.font='13px sans-serif'; gainCtx.textAlign='center'; gainCtx.textBaseline='top';
  const xAxisLabel=strings.gainXAxisLabel || defaultConfig.strings.gainXAxisLabel || '';
  gainCtx.fillText(xAxisLabel, x0 + plotW/2, y0 + plotH + 28);
  gainCtx.save();
  gainCtx.translate(x0 - 36, y0 + plotH/2);
  gainCtx.rotate(-Math.PI/2);
  const yAxisLabel=strings.gainYAxisLabel || defaultConfig.strings.gainYAxisLabel || '';
  gainCtx.textBaseline='top'; gainCtx.fillText(yAxisLabel, 0, 0);
  gainCtx.restore();

  if(gainUtilities.length){
    const gainMax=Math.max(...gainUtilities, -Infinity);
    if(lastRocBestUtility!==null && Math.abs(gainMax - lastRocBestUtility)>1e-6){
      console.warn('Gain plot best utility differs from ROC best utility', {gainMax, rocBest:lastRocBestUtility});
    }
  }

  gainPlotCache = {
    points: gainPoints,
    utilities: gainUtilities,
    thresholds: Array.isArray(roc.threshold) ? roc.threshold.slice() : [],
    geometry: {x0,y0,plotW,plotH,width,height},
    liftMax: typeof liftMax==='number'?liftMax:0,
    liftEnabled: !!drawLiftCurve
  };

  if(!(uiSettings && uiSettings.showGainBaselineLegend===false)){
    const legendItems=[];
    const gainStrings = (strings && strings.plots && strings.plots.gain) || (defaultConfig.strings && defaultConfig.strings.plots && defaultConfig.strings.plots.gain) || {};
    if(!(uiSettings && uiSettings.showGainDiagonalLine===false)){
      legendItems.push({label: gainStrings.randomModelLabel || 'Random Model (Diagonal)', color: (styleCfg && styleCfg.gainDiagonalLine && styleCfg.gainDiagonalLine.color) || '#666', dash: (styleCfg && styleCfg.gainDiagonalLine && styleCfg.gainDiagonalLine.dash) || []});
    }
    if(!(uiSettings && uiSettings.showGainPrevalenceLine===false)){
      legendItems.push({label: gainStrings.prevalenceLabel || 'Prevalence', color: (styleCfg && styleCfg.gainPrevalenceLine && styleCfg.gainPrevalenceLine.color) || '#1e88e5', dash: (styleCfg && styleCfg.gainPrevalenceLine && styleCfg.gainPrevalenceLine.dash) || [5,3]});
    }
    if(legendItems.length){
      const legendTitle = gainStrings.baselineLegendTitle || 'Baselines';
      const padding=8;
      const swatchSize=12;
      const spacing=6;
      gainCtx.font='11px sans-serif';
      const lineHeight=16;
      let maxTextWidth=gainCtx.measureText(legendTitle).width;
      legendItems.forEach(item=>{
        const w=gainCtx.measureText(item.label).width;
        if(w>maxTextWidth) maxTextWidth=w;
      });
      const legendWidth=padding*2 + swatchSize + spacing + maxTextWidth;
      const legendHeight=padding*2 + lineHeight*(legendItems.length+1);
      const legendX=x0 + plotW - legendWidth - 10;
      const legendY=y0 + 10;
      gainCtx.fillStyle='rgba(255,255,255,0.9)';
      gainCtx.strokeStyle='rgba(0,0,0,0.15)';
      gainCtx.lineWidth=1;
      gainCtx.fillRect(legendX, legendY, legendWidth, legendHeight);
      gainCtx.strokeRect(legendX, legendY, legendWidth, legendHeight);
      gainCtx.fillStyle='#000';
      gainCtx.textBaseline='top';
      gainCtx.fillText(legendTitle, legendX+padding, legendY+padding);
      legendItems.forEach((item,idx)=>{
        const y=legendY+padding+lineHeight*(idx+1);
        gainCtx.strokeStyle=item.color;
        gainCtx.lineWidth=2;
        gainCtx.setLineDash(Array.isArray(item.dash)?item.dash:[]);
        gainCtx.beginPath();
        gainCtx.moveTo(legendX+padding, y+swatchSize/2);
        gainCtx.lineTo(legendX+padding+swatchSize, y+swatchSize/2);
        gainCtx.stroke();
        gainCtx.setLineDash([]);
        gainCtx.fillStyle='#000';
        gainCtx.fillText(item.label, legendX+padding+swatchSize+spacing, y);
      });
    }
  }

  updateConfusionMatrix();
}

function drawPRPlot(){
  if(!prCanvas || !prCtx) return;
  const width=prCanvas.width, height=prCanvas.height;
  prCtx.clearRect(0,0,width,height);
  if(!isPRPlotVisible()) return;
  const rocName=rocSelect.value;
  if(!rocName || !rocCurves[rocName]) return;
  const roc=rocCurves[rocName];
  const fprArr=roc.fpr, tprArr=roc.tpr;
  if(!Array.isArray(fprArr) || !Array.isArray(tprArr) || fprArr.length!==tprArr.length) return;
  const payoffs=getPayoffParams();
  const pPos=payoffs.P_POS;
  const {x0,y0,plotW,plotH,titleY,subtitleY}=getRocPlotGeometry(width,height);
  const xScale=(xf)=>x0+xf*plotW; const yScale=(yt)=>y0+(1-yt)*plotH;

  const iw=Math.max(2,Math.floor(plotW)); const ih=Math.max(2,Math.floor(plotH));
  const img=prCtx.createImageData(iw,ih); const data=img.data;
  let minU=Infinity,maxU=-Infinity;
  for(let j=0;j<ih;j++){
    const recall=1-j/(ih-1);
    for(let i=0;i<iw;i++){
      const precision=i/(iw-1);
      const denom=Math.max(1e-9,1-pPos);
      let fprVal=precision>0 ? (recall*(1/precision -1)*pPos)/denom : 1;
      fprVal=Math.max(0,Math.min(1,fprVal));
      const u=utilityAtRates(fprVal,recall,payoffs);
      const idx=j*iw+i;
      data[idx*4+3]=255;
      if(u<minU) minU=u;
      if(u>maxU) maxU=u;
    }
  }
  const scale=v=>(v-minU)/(maxU-minU||1);
  for(let j=0;j<ih;j++){
    for(let i=0;i<iw;i++){
      const recall=1-j/(ih-1);
      const precision=i/(iw-1);
      const denom=Math.max(1e-9,1-pPos);
      let fprVal=precision>0 ? (recall*(1/precision -1)*pPos)/denom : 1;
      fprVal=Math.max(0,Math.min(1,fprVal));
      const u=utilityAtRates(fprVal,recall,payoffs);
      const s=scale(u);
      const [r,g,b]=heatColor(s);
      const idx=j*iw+i;
      data[idx*4]=r; data[idx*4+1]=g; data[idx*4+2]=b; data[idx*4+3]=255;
    }
  }
  prCtx.putImageData(img,Math.round(x0),Math.round(y0));

  prCtx.fillStyle = '#000';
  prCtx.textAlign = 'center';
  prCtx.font = '16px sans-serif';
  const titleText = strings.prPlotTitle || defaultConfig.strings.prPlotTitle || '';
  prCtx.fillText(titleText, width/2, titleY);
  prCtx.font = '13px sans-serif';
  const subtitleText = resolveVariantLabel(rocName, roc.metadata || {});
  prCtx.fillText(subtitleText, width/2, subtitleY);

  prCtx.save();
  prCtx.beginPath(); prCtx.rect(x0,y0,plotW,plotH); prCtx.clip();

  const prPoints=[];
  for(let i=0;i<fprArr.length;i++){
    const fprVal=Number(fprArr[i]);
    const tprVal=Number(tprArr[i]);
    if(!Number.isFinite(fprVal) || !Number.isFinite(tprVal)) continue;
    if(fprVal===0 && tprVal===0) continue;
    const precision = (tprVal*pPos)/Math.max(1e-9, tprVal*pPos + fprVal*(1-pPos));
    prPoints.push({recall:tprVal, precision});
  }
  prPoints.sort((a,b)=>a.recall-b.recall);
  if(prPoints.length){
    prCtx.beginPath();
    prPoints.forEach((pt,idx)=>{
      const px=xScale(pt.recall);
      const py=yScale(pt.precision);
      if(idx===0) prCtx.moveTo(px,py);
      else prCtx.lineTo(px,py);
    });
    prCtx.strokeStyle='blue';
    prCtx.lineWidth=2;
    prCtx.stroke();
  }

  prCtx.restore();

  prCtx.strokeStyle='#666'; prCtx.lineWidth=1; prCtx.strokeRect(x0,y0,plotW,plotH);

  prCtx.strokeStyle='#333'; prCtx.fillStyle='#333'; prCtx.lineWidth=1;
  prCtx.font='11px sans-serif'; prCtx.textAlign='center'; prCtx.textBaseline='top';
  const tickCount=11;
  for(let i=0;i<tickCount;i++){
    const val=i/10;
    const x=xScale(val);
    const yBottom=yScale(0);
    prCtx.beginPath(); prCtx.moveTo(x,yBottom); prCtx.lineTo(x,yBottom+6); prCtx.stroke();
    prCtx.fillText(val.toFixed(1), x, yBottom+8);
  }
  prCtx.textAlign='right'; prCtx.textBaseline='middle';
  for(let i=0;i<tickCount;i++){
    const val=i/10;
    const y=yScale(val);
    const xLeft=xScale(0);
    prCtx.beginPath(); prCtx.moveTo(xLeft-6,y); prCtx.lineTo(xLeft,y); prCtx.stroke();
    prCtx.fillText(val.toFixed(1), xLeft-8, y);
  }

  prCtx.font='13px sans-serif'; prCtx.textAlign='center'; prCtx.textBaseline='top';
  const xAxisLabel=strings.prXAxisLabel || defaultConfig.strings.prXAxisLabel || '';
  prCtx.fillText(xAxisLabel, x0 + plotW/2, y0 + plotH + 28);
  prCtx.save();
  prCtx.translate(x0 - 36, y0 + plotH/2);
  prCtx.rotate(-Math.PI/2);
  const yAxisLabel=strings.prYAxisLabel || defaultConfig.strings.prYAxisLabel || '';
  prCtx.textBaseline='top'; prCtx.fillText(yAxisLabel, 0, 0);
  prCtx.restore();
}

function drawThresholdPlot(){
  if(!thresholdCanvas || !thresholdCtx){
    return;
  }
  const width=thresholdCanvas.width;
  const height=thresholdCanvas.height;
  thresholdCtx.clearRect(0,0,width,height);
  if(!isThresholdPlotVisible()){
    return;
  }

  const payoffs=getPayoffParams();
  const pPos = payoffs.P_POS;
  const curveIds=Object.keys(rocCurves).sort((a,b)=>a.localeCompare(b));
  const selectedId=rocSelect.value;
  const showAll = !(uiSettings && uiSettings.showAllCurvesInThresholdPlot===false);
  const xMode = (uiSettings && uiSettings.thresholdXAxisMode==='quantile') ? 'quantile' : 'threshold';
  const curveIdsToPlot = showAll ? curveIds : (selectedId ? [selectedId] : []);

  const datasets=[];
  let minThreshold=Infinity,maxThreshold=-Infinity,minUtility=Infinity,maxUtility=-Infinity;

  const buildThresholdSeries=(curve,length)=>{
    if(Array.isArray(curve.threshold) && curve.threshold.length>=length){
      const values=[];
      let valid=true;
      for(let i=0;i<length;i++){
        const value=Number(curve.threshold[i]);
        if(Number.isFinite(value)){
          values.push(value);
        }else{
          valid=false;
          break;
        }
      }
      if(valid){
        return {values, synthetic:false, source:'threshold'};
      }
    }
    if(Array.isArray(curve.fpr) && curve.fpr.length>=length){
      const values=[];
      let valid=true;
      for(let i=0;i<length;i++){
        const value=Number(curve.fpr[i]);
        if(Number.isFinite(value)){
          values.push(value);
        }else{
          valid=false;
          break;
        }
      }
      if(valid){
        return {values, synthetic:true, source:'fpr'};
      }
    }
    const values=[];
    if(length<=1){
      values.push(0);
    }else{
      for(let i=0;i<length;i++){
        values.push(i/(length-1));
      }
    }
    return {values, synthetic:true, source:'index'};
  };

  curveIdsToPlot.forEach((curveId)=>{
    const curve=rocCurves[curveId];
    if(!curve) return;
    if(!Array.isArray(curve.fpr) || !Array.isArray(curve.tpr)) return;
    const length=Math.min(curve.fpr.length, curve.tpr.length);
    if(!length) return;
    const thresholdSeries=buildThresholdSeries(curve,length);
    let lower=curve.tpr_lower, upper=curve.tpr_upper;
    if((!lower || !upper) && Array.isArray(curve.bands) && curve.bands.length){
      const sortedBands=[...curve.bands].sort((a,b)=>{
        const aVal=typeof a.level==='number'?a.level:parseFloat(a.level)||0;
        const bVal=typeof b.level==='number'?b.level:parseFloat(b.level)||0;
        return aVal-bVal;
      });
      const fallback=sortedBands[sortedBands.length-1];
      if(fallback){
        if(!lower) lower=fallback.lower;
        if(!upper) upper=fallback.upper;
      }
    }
    const entries=[];
    const bandEntries=[];
    const colorIndex = Math.max(0, curveIds.indexOf(curveId));
    for(let i=0;i<length;i++){
      const fpr=Number(curve.fpr[i]);
      const tpr=Number(curve.tpr[i]);
      if(!Number.isFinite(fpr) || !Number.isFinite(tpr)) continue;
      const xVal = xMode==='quantile' ? (pPos*tpr + (1-pPos)*fpr) : Number(thresholdSeries.values[i]);
      if(!Number.isFinite(xVal)) continue;
      const utility=utilityAtRates(fpr,tpr,payoffs);
      if(!Number.isFinite(utility)) continue;
      let lowerUtility=null, upperUtility=null;
      if(Array.isArray(lower) && lower.length>i && Number.isFinite(Number(lower[i]))){
        lowerUtility=utilityAtRates(fpr, Number(lower[i]), payoffs);
      }
      if(Array.isArray(upper) && upper.length>i && Number.isFinite(Number(upper[i]))){
        upperUtility=utilityAtRates(fpr, Number(upper[i]), payoffs);
      }
      entries.push({x:xVal, utility, idx:i});
      bandEntries.push({x:xVal, lower:lowerUtility, upper:upperUtility});
    }
    if(!entries.length) return;
    entries.sort((a,b)=>a.x-b.x || a.utility-b.utility);
    bandEntries.sort((a,b)=>a.x-b.x);
    entries.forEach(pt=>{
      if(pt.x<minThreshold) minThreshold=pt.x;
      if(pt.x>maxThreshold) maxThreshold=pt.x;
      if(pt.utility<minUtility) minUtility=pt.utility;
      if(pt.utility>maxUtility) maxUtility=pt.utility;
    });
    bandEntries.forEach(pt=>{
      if(Number.isFinite(pt.lower)){
        if(pt.lower<minUtility) minUtility=pt.lower;
        if(pt.lower>maxUtility) maxUtility=pt.lower;
      }
      if(Number.isFinite(pt.upper)){
        if(pt.upper<minUtility) minUtility=pt.upper;
        if(pt.upper>maxUtility) maxUtility=pt.upper;
      }
    });
    const meta=curve.metadata||{};
    const baseLabel = resolveVariantLabel(curveId, meta);
    datasets.push({
      id:curveId,
      label:baseLabel,
      entries,
      bandEntries,
      color:getCurveColor(colorIndex, curveIds.length),
      isSelected: curveId===selectedId,
      synthetic: thresholdSeries.synthetic
    });
  });

  if(!datasets.length){
    thresholdCtx.fillStyle='#333';
    thresholdCtx.font='16px sans-serif';
    thresholdCtx.textAlign='center';
    thresholdCtx.textBaseline='middle';
    thresholdCtx.fillText(strings.noThresholdData || defaultConfig.strings.noThresholdData, width/2, height/2);
    return;
  }

  if(minThreshold===Infinity || maxThreshold===-Infinity){
    minThreshold=0;
    maxThreshold=1;
  }
  if(xMode==='quantile'){
    minThreshold=Math.max(0, minThreshold);
    maxThreshold=Math.min(1, Math.max(maxThreshold, minThreshold+1e-6));
  }
  if(minThreshold===maxThreshold){
    minThreshold-=0.5;
    maxThreshold+=0.5;
  }
  if(!Number.isFinite(minUtility) || !Number.isFinite(maxUtility)){
    minUtility=0;
    maxUtility=1;
  }
  if(minUtility===maxUtility){
    const adjust=Math.max(1, Math.abs(minUtility||1));
    minUtility-=adjust/2;
    maxUtility+=adjust/2;
  }

  const marginLeft=70;
  const marginRight=30;
  const marginTop=30;

  const legendPadding=8;
  const legendItemHeight=18;
  const legendHeight=datasets.length ? legendItemHeight*datasets.length+legendPadding*2 : 0;
  const marginBottom=40+legendHeight;

  const plotW=Math.max(10,width-marginLeft-marginRight);
  const plotH=Math.max(10,height-marginTop-marginBottom);
  const xScale=(threshold)=>marginLeft+((threshold-minThreshold)/(maxThreshold-minThreshold||1))*plotW;
  const yScale=(utility)=>marginTop+(1-((utility-minUtility)/(maxUtility-minUtility||1)))*plotH;

  thresholdCtx.fillStyle='#f8f8f8';
  thresholdCtx.fillRect(marginLeft,marginTop,plotW,plotH);
  thresholdCtx.strokeStyle='#ccc';
  thresholdCtx.lineWidth=1;
  thresholdCtx.strokeRect(marginLeft,marginTop,plotW,plotH);

  thresholdCtx.strokeStyle='#444';
  thresholdCtx.lineWidth=1.2;
  thresholdCtx.beginPath();
  thresholdCtx.moveTo(marginLeft, marginTop);
  thresholdCtx.lineTo(marginLeft, marginTop+plotH);
  thresholdCtx.lineTo(marginLeft+plotW, marginTop+plotH);
  thresholdCtx.stroke();

  thresholdCtx.fillStyle='#000';
  thresholdCtx.font='13px sans-serif';
  thresholdCtx.textAlign='center';
  const xAxisLabel = xMode==='quantile' ? (strings.gainXAxisLabel || defaultConfig.strings.gainXAxisLabel || 'Fraction of the Entire Test Set') : (strings.axisThreshold || defaultConfig.strings.axisThreshold);
  thresholdCtx.fillText(xAxisLabel, marginLeft + plotW/2, marginTop+plotH+28);
  thresholdCtx.save();
  thresholdCtx.translate(18, marginTop + plotH/2);
  thresholdCtx.rotate(-Math.PI/2);
  thresholdCtx.fillText(strings.axisUtility || defaultConfig.strings.axisUtility, 0,0);
  thresholdCtx.restore();

  thresholdCtx.fillStyle='#000';
  thresholdCtx.font='12px sans-serif';
  thresholdCtx.textAlign='center';
  const xTickCount=5;
  for(let i=0;i<xTickCount;i++){
    const t=minThreshold+(i/(xTickCount-1||1))*(maxThreshold-minThreshold);
    const x=xScale(t);
    thresholdCtx.beginPath();
    thresholdCtx.moveTo(x, marginTop+plotH);
    thresholdCtx.lineTo(x, marginTop+plotH+6);
    thresholdCtx.strokeStyle='#444';
    thresholdCtx.stroke();
    thresholdCtx.fillText(Number(t).toFixed(2), x, marginTop+plotH+20);
  }

  thresholdCtx.textAlign='right';
  const yTickCount=5;
  for(let i=0;i<yTickCount;i++){
    const frac=i/(yTickCount-1||1);
    const u=minUtility+frac*(maxUtility-minUtility);
    const y=yScale(u);
    thresholdCtx.beginPath();
    thresholdCtx.moveTo(marginLeft-6,y);
    thresholdCtx.lineTo(marginLeft,y);
    thresholdCtx.strokeStyle='#444';
    thresholdCtx.stroke();
    thresholdCtx.fillText(Math.round(u).toString(), marginLeft-8, y+4);
  }

  if(minUtility<0 && maxUtility>0){
    const zeroY=yScale(0);
    thresholdCtx.strokeStyle='rgba(0,0,0,0.2)';
    thresholdCtx.setLineDash([4,4]);
    thresholdCtx.beginPath();
    thresholdCtx.moveTo(marginLeft, zeroY);
    thresholdCtx.lineTo(marginLeft+plotW, zeroY);
    thresholdCtx.stroke();
    thresholdCtx.setLineDash([]);
  }

  datasets.forEach(dataset=>{
    const lineWidth = dataset.isSelected ? 4 : 2;
    const bandPts = (dataset.bandEntries || []).filter(pt=>Number.isFinite(pt.lower) || Number.isFinite(pt.upper));
    if(bandPts.length){
      const upperPath=[];
      const lowerPath=[];
      bandPts.forEach(pt=>{
        if(Number.isFinite(pt.upper)) upperPath.push({x:xScale(pt.x), y:yScale(pt.upper)});
      });
      for(let i=bandPts.length-1;i>=0;i--){
        const pt=bandPts[i];
        if(Number.isFinite(pt.lower)) lowerPath.push({x:xScale(pt.x), y:yScale(pt.lower)});
      }
      if(upperPath.length && lowerPath.length){
        thresholdCtx.save();
        thresholdCtx.beginPath();
        thresholdCtx.moveTo(upperPath[0].x, upperPath[0].y);
        upperPath.slice(1).forEach(p=>thresholdCtx.lineTo(p.x,p.y));
        lowerPath.forEach(p=>thresholdCtx.lineTo(p.x,p.y));
        thresholdCtx.closePath();
        thresholdCtx.fillStyle=dataset.color;
        thresholdCtx.globalAlpha=0.18;
        thresholdCtx.fill();
        thresholdCtx.restore();
      }
    }

    thresholdCtx.beginPath();
    dataset.entries.forEach((pt,idx)=>{
      const x=xScale(pt.x);
      const y=yScale(pt.utility);
      if(idx===0) thresholdCtx.moveTo(x,y);
      else thresholdCtx.lineTo(x,y);
    });
    thresholdCtx.strokeStyle=dataset.color;
    thresholdCtx.lineWidth=lineWidth;
    thresholdCtx.stroke();
    thresholdCtx.lineWidth=1;
    dataset.entries.forEach(pt=>{
      const x=xScale(pt.x);
      const y=yScale(pt.utility);
      thresholdCtx.beginPath();
      thresholdCtx.arc(x,y,dataset.isSelected?4:3,0,Math.PI*2);
      thresholdCtx.fillStyle=dataset.color;
      thresholdCtx.fill();
    });

    if(dataset.isSelected && Number.isInteger(lastRocBestIdx)){
      const match=dataset.entries.find(pt=>pt.idx===lastRocBestIdx);
      if(match){
        thresholdCtx.beginPath();
        thresholdCtx.arc(xScale(match.x), yScale(match.utility), 7, 0, Math.PI*2);
        thresholdCtx.fillStyle='yellow';
        thresholdCtx.strokeStyle='red';
        thresholdCtx.lineWidth=2;
        thresholdCtx.fill();
        thresholdCtx.stroke();
        thresholdCtx.lineWidth=1;
      }
    }
  });

  if(legendHeight>0){
    const legendWidth=Math.min(260, plotW);
    const legendX=marginLeft+(plotW-legendWidth)/2;
    const legendY=marginTop+plotH+10;
    thresholdCtx.fillStyle='rgba(255,255,255,0.9)';
    thresholdCtx.strokeStyle='rgba(0,0,0,0.15)';
    thresholdCtx.lineWidth=1;
    thresholdCtx.fillRect(legendX, legendY, legendWidth, legendHeight);
    thresholdCtx.strokeRect(legendX, legendY, legendWidth, legendHeight);
    thresholdCtx.font='12px sans-serif';
    thresholdCtx.textAlign='left';
    datasets.forEach((dataset,index)=>{
      const y=legendY+legendPadding+legendItemHeight*index+legendItemHeight/2;
      thresholdCtx.fillStyle=dataset.color;
      thresholdCtx.fillRect(legendX+10, y-5, 16, 10);
      thresholdCtx.fillStyle='#000';
      const label=dataset.label || dataset.id;
      const selectedSuffix = dataset.isSelected ? (strings.legendSelectedSuffix || defaultConfig.strings.legendSelectedSuffix || '') : '';
      const syntheticSuffix = dataset.synthetic ? (strings.legendDerivedSuffix || defaultConfig.strings.legendDerivedSuffix || '') : '';
      thresholdCtx.fillText(`${label}${selectedSuffix}${syntheticSuffix}`, legendX+32, y+4);
    });
  }
}

canvas.addEventListener('mousemove',e=>{
  if(!isRocPlotVisible()){
    tooltip.style.display='none';
    return;
  }
  const rect=canvas.getBoundingClientRect();
  const offsetX=e.clientX-rect.left;
  const offsetY=e.clientY-rect.top;
  const scaleX=canvas.width/rect.width;
  const scaleY=canvas.height/rect.height;
  const x=offsetX*scaleX;
  const y=offsetY*scaleY;
  const {x0,y0,plotW,plotH}=getRocPlotGeometry(canvas.width, canvas.height);
  if(x<x0||x>x0+plotW||y<y0||y>y0+plotH){tooltip.style.display='none';return;}
  const fpr=(x-x0)/plotW,tpr=1-(y-y0)/plotH;
  const payoffs=getPayoffParams();
  const pPos=payoffs.P_POS;
  const N=getPopulationSize();
  const ap=N*pPos,an=N*(1-pPos),tp=tpr*ap,fn=(1-tpr)*ap,fp=fpr*an,tn=an-fp;
  const u=utilityAtRates(fpr,tpr,payoffs);
  const tooltipWidth=140,tooltipHeight=48;
  tooltip.style.left=(offsetX-tooltipWidth-10)+'px';
  tooltip.style.top=(offsetY-tooltipHeight-10)+'px';
  const tooltipTemplate=strings.tooltipFormat || defaultConfig.strings.tooltipFormat;
  tooltip.textContent=formatString(tooltipTemplate,{
    fpr:fpr.toFixed(2),
    tpr:tpr.toFixed(2),
    utility: Math.round(u)
  });
  tooltip.style.display='block';
});
canvas.addEventListener('mouseleave',()=>tooltip.style.display='none');

if(gainCanvas){
  gainCanvas.addEventListener('mousemove',e=>{
    if(!isGainPlotVisible()){
      tooltip.style.display='none';
      return;
    }
    const {points, utilities, thresholds, geometry, liftEnabled, liftMax}=gainPlotCache;
    if(!geometry){
      tooltip.style.display='none';
      return;
    }
    const rect=gainCanvas.getBoundingClientRect();
    const containerRect=rocPlotContainer.getBoundingClientRect();
    const offsetX=e.clientX-rect.left;
    const offsetY=e.clientY-rect.top;
    const scaleX=gainCanvas.width/rect.width;
    const scaleY=gainCanvas.height/rect.height;
    const x=offsetX*scaleX;
    const y=offsetY*scaleY;
    const {x0,y0,plotW,plotH}=geometry;
    if(x<x0||x>x0+plotW||y<y0||y>y0+plotH){tooltip.style.display='none';return;}
    const payoffs=getPayoffParams();
    const popFrac=Math.min(1,Math.max(0,(x - x0)/plotW));
    const tprVal=Math.min(1,Math.max(0,1 - (y - y0)/plotH));
    const denom=Math.max(1e-9,1 - payoffs.P_POS);
    const fprVal=Math.min(1,Math.max(0,(popFrac - payoffs.P_POS * tprVal)/denom));
    const util=utilityAtRates(fprVal,tprVal,payoffs);
    const liftVal = (liftEnabled && popFrac>0) ? tprVal/popFrac : null;

    let thresholdVal=null;
    if(points && points.length && thresholds && thresholds.length){
      let nearestIdx=-1;
      let bestDist=Infinity;
      const xScale=(xf)=>x0+xf*plotW;
      const yScale=(yt)=>y0+(1-yt)*plotH;
      points.forEach((pt,idx)=>{
        if(idx>=thresholds.length) return;
        const px=xScale(pt.x);
        const py=yScale(pt.y);
        const d=(px-x)*(px-x)+(py-y)*(py-y);
        if(d<bestDist){
          bestDist=d; nearestIdx=idx;
        }
      });
      if(nearestIdx>=0 && Number.isFinite(Number(thresholds[nearestIdx]))){
        thresholdVal=Number(thresholds[nearestIdx]);
      }
    }
    const parts=[];
    parts.push(`Pop frac: ${popFrac.toFixed(2)}`);
    parts.push(`TPR: ${tprVal.toFixed(2)}`);
    parts.push(`FPR: ${fprVal.toFixed(2)}`);
    if(thresholdVal!==null) parts.push(`Threshold: ${thresholdVal.toFixed(3)}`);
    parts.push(`Utility: ${Math.round(util)}`);
    if(liftVal!==null && liftMax>0 && uiSettings && uiSettings.showLiftCurveInGainPlot){
      parts.push(`Lift: ${liftVal.toFixed(2)}`);
    }
    tooltip.textContent=parts.join(', ');
    tooltip.style.left=(rect.left - containerRect.left + offsetX - 140)+'px';
    tooltip.style.top=(rect.top - containerRect.top + offsetY - 50)+'px';
    tooltip.style.display='block';
  });
  gainCanvas.addEventListener('mouseleave',()=>tooltip.style.display='none');
}

window.addEventListener('DOMContentLoaded',async()=>{
  await loadAppConfig();
  const loaded=await loadStaticRocFiles();
  if(!loaded){
    const fallbackSelection=Object.keys(HARDCODED_FALLBACK_CURVES)[0]||null;
    loadROCData({...HARDCODED_FALLBACK_CURVES},fallbackSelection);
  }
  if(isBestUtilityVisible() && bestUtilityDiv && !bestUtilityDiv.textContent){
    bestUtilityDiv.textContent = strings.bestUtilityUnavailable || defaultConfig.strings.bestUtilityUnavailable;
  }
});
</script>
</body>
</html>
