<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Costs and Benefits</title>
<style>
  body { font-family: sans-serif; margin: 20px; }
  .container { display: grid; grid-template-columns: 1fr 1fr; gap: 20px; }
  canvas { border: 1px solid #999; border-radius: 6px; }
  label { display: block; margin-top: 8px; }
  input[type=range] { width: 100%; }
  .tooltip { position: absolute; font-size: 12px; background: rgba(255,255,255,0.9); border: 1px solid #ccc; border-radius: 4px; padding: 3px 6px; pointer-events: none; }
  .payoff-grid { border-collapse: collapse; width: 100%; max-width: 360px; }
  .payoff-grid th, .payoff-grid td { border: 1px solid #ccc; padding: 6px; text-align: center; }
  .payoff-grid th { background: #f5f5f5; font-weight: 600; }
  .payoff-cell { display: flex; flex-direction: column; align-items: center; gap: 4px; }
  .payoff-cell-label { font-size: 12px; font-weight: 600; }
  .payoff-slider-value { font-size: 12px; font-weight: 600; }
  .payoff-input-number { width: 80px; }
</style>
</head>
<body>
<h1 id="appTitle">Costs and Benefits</h1>
<div class="container">
  <div>
    <label id="dropdownLabel"><span id="dropdownLabelText">Reference model</span>
      <select id="rocSelect"></select>
    </label>
    <div id="importControls" style="margin-top:12px; display:flex; flex-direction:column; gap:6px;">
      <label><span id="importLabelText">Import ROC Data</span>
        <input type="file" id="rocFileInput" accept=".csv,.json,application/json,text/csv">
      </label>
      <button type="button" id="downloadCurveBtn">Download Selected Curve JSON</button>
    </div>
    <div id="slidersSection">
      <div id="priorControls"></div>
      <div id="payoffGridSection" style="margin-top:12px;"></div>
    </div>
    <div id="bestUtility" style="margin-top:1em;font-weight:bold;"></div>
  </div>
  <div id="rocPlotContainer" style="position:relative;">
    <canvas id="canvas" width="600" height="600"></canvas>
    <div id="tooltip" class="tooltip" style="display:none;"></div>
  </div>
</div>
<div id="thresholdSection" style="margin-top:20px;">
  <h2 id="thresholdTitle">Payoff vs Threshold</h2>
  <canvas id="thresholdCanvas" width="800" height="320" style="border:1px solid #999; border-radius:6px;"></canvas>
</div>
<script>
const defaultConfig = {
  strings: {
    pageTitle: "ROC Utility",
    appTitle: "Costs and Benefits",
    dropdownLabel: "Reference model",
    importLabel: "Import ROC Data",
    downloadButton: "Download Selected Curve JSON",
    thresholdTitle: "Payoff vs Threshold",
    bestUtilityPrefix: "Best utility = ",
    bestUtilityUnavailable: "Best utility = â€”",
    noThresholdData: "No threshold data available for payoff plot.",
    axisThreshold: "Threshold",
    axisUtility: "Expected Utility",
    legendSelectedSuffix: " (selected)",
    legendDerivedSuffix: " (derived thresholds)",
    variantLabelFormat: "{original} ({source})",
    variantSourceFallback: "variant",
    tooltipFormat: "FPR: {fpr}, TPR: {tpr}, U: {utility}",
    payoffGrid: {
      actualPositive: "Actual Positive",
      actualNegative: "Actual Negative",
      predictedPositive: "Predicted Positive",
      predictedNegative: "Predicted Negative",
      TP: "True Positive",
      FN: "False Negative",
      FP: "False Positive",
      TN: "True Negative"
    },
    alerts: {
      noCurvesFound: "No ROC curves found in the selected file.",
      failImport: "Failed to import ROC data: {message}",
      failRead: "Unable to read the selected file.",
      noCurveSelectedDownload: "No ROC curve selected to download.",
      failStaticLoad: "Failed to load static ROC file \"{path}\": {message}",
      failConfigLoad: "Failed to load configuration: {message}"
    }
  },
  ui: {
    showRocPlot: true,
    showThresholdPlot: true,
    showSliders: true,
    showImport: true,
    showDownloadButton: true,
    showBestUtility: true,
    payoffInputMode: "slider"
  },
  sliders: {
    P_POS: {label: "Proportion positive", min: 0.01, max: 0.99, step: 0.01, value: 0.5},
  },
  payoffs: {
    TP: {label: "TP", value: 50, min: -100, max: 100, step: 1},
    FP: {label: "FP", value: -70, min: -100, max: 100, step: 1},
    TN: {label: "TN", value: 0, min: -100, max: 100, step: 1},
    FN: {label: "FN", value: 0, min: -100, max: 100, step: 1}
  },
  data: {
    staticFiles: [
      'roc_data/roadmap_logistic.csv',
      'roc_data/random_forest_baseline.csv',
      'roc_data/logistic_baseline.csv',
      'roc_data/bayesian_model_baseline.csv',
      'roc_data/roadmap_logistic.json',
      'roc_data/random_forest_baseline.json',
      'roc_data/logistic_baseline.json',
      'roc_data/bayesian_model_baseline.json'
    ]
  }
};

const STATIC_DATA_FILES = [...defaultConfig.data.staticFiles];

const HARDCODED_FALLBACK_CURVES = {
  random_forest_baseline: {
    name: 'random_forest_baseline',
    type: 'ROC',
    fpr: [0, 0.2, 0.4, 0.6, 0.8, 1],
    tpr: [0, 0.5, 0.7, 0.85, 0.9, 1],
    metadata: {source: 'embedded', note: 'Random forest demo curve'}
  },
  logistic_baseline: {
    name: 'logistic_baseline',
    type: 'ROC',
    fpr: [0, 0.2, 0.4, 0.6, 0.8, 1],
    tpr: [0, 0.4, 0.65, 0.8, 0.9, 1],
    metadata: {source: 'embedded', note: 'Logistic regression demo curve'}
  },
  bayesian_model_baseline: {
    name: 'bayesian_model_baseline',
    type: 'ROC',
    fpr: [0, 0.2, 0.4, 0.6, 0.8, 1],
    tpr: [0, 0.45, 0.7, 0.85, 0.9, 1],
    tpr_lower: [0, 0.35, 0.6, 0.75, 0.85, 0.95],
    tpr_upper: [0, 0.55, 0.8, 0.9, 0.95, 1],
    metadata: {source: 'embedded', note: 'Bayesian model demo curve'}
  }
};

let rocCurves = {};
let appConfig = cloneDeep(defaultConfig);
let strings = appConfig.strings;
let uiSettings = appConfig.ui;

const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
const thresholdCanvas = document.getElementById('thresholdCanvas');
const thresholdCtx = thresholdCanvas ? thresholdCanvas.getContext('2d') : null;
const tooltip = document.getElementById('tooltip');
const rocSelect = document.getElementById('rocSelect');
const priorControls = document.getElementById('priorControls');
const payoffGridSection = document.getElementById('payoffGridSection');
const rocFileInput = document.getElementById('rocFileInput');
const downloadCurveBtn = document.getElementById('downloadCurveBtn');
const bestUtilityDiv = document.getElementById('bestUtility');
const appTitleEl = document.getElementById('appTitle');
const dropdownLabelText = document.getElementById('dropdownLabelText');
const importControls = document.getElementById('importControls');
const importLabelText = document.getElementById('importLabelText');
const slidersSection = document.getElementById('slidersSection');
const rocPlotContainer = document.getElementById('rocPlotContainer');
const thresholdSection = document.getElementById('thresholdSection');
const thresholdTitleEl = document.getElementById('thresholdTitle');

const values = {};

const POPULATION_SIZE = 1000;

function cloneDeep(obj){
  return JSON.parse(JSON.stringify(obj));
}

function mergeDeep(target, source){
  if(!source || typeof source !== 'object') return target;
  Object.keys(source).forEach(key=>{
    const sourceValue = source[key];
    if(Array.isArray(sourceValue)){
      target[key] = sourceValue.slice();
    }else if(sourceValue && typeof sourceValue === 'object'){
      if(!target[key] || typeof target[key] !== 'object'){
        target[key] = {};
      }
      mergeDeep(target[key], sourceValue);
    }else{
      target[key] = sourceValue;
    }
  });
  return target;
}

function formatString(template, replacements = {}){
  if(!template || typeof template !== 'string') return '';
  return template.replace(/\{([^}]+)\}/g, (_, key)=>{
    const value = key in replacements ? replacements[key] : '';
    return value === undefined || value === null ? '' : String(value);
  });
}

function updateConfigReferences(){
  strings = appConfig && appConfig.strings ? appConfig.strings : defaultConfig.strings;
  uiSettings = appConfig && appConfig.ui ? appConfig.ui : defaultConfig.ui;
}

updateConfigReferences();

function getAlertTemplate(key){
  const primary = (strings && strings.alerts) ? strings.alerts : {};
  const fallback = (defaultConfig.strings && defaultConfig.strings.alerts) ? defaultConfig.strings.alerts : {};
  return primary[key] || fallback[key] || key;
}

function alertFromConfig(key, params = {}){
  const template = getAlertTemplate(key);
  alert(formatString(template, params));
}

function warnFromConfig(key, params = {}){
  const template = getAlertTemplate(key);
  console.warn(formatString(template, params));
}

function applyConfigToUI(){
  if(strings.pageTitle || strings.appTitle){
    document.title = strings.pageTitle || strings.appTitle;
  }
  if(appTitleEl) appTitleEl.textContent = strings.appTitle || defaultConfig.strings.appTitle;
  if(dropdownLabelText) dropdownLabelText.textContent = strings.dropdownLabel || defaultConfig.strings.dropdownLabel;
  if(importLabelText) importLabelText.textContent = strings.importLabel || defaultConfig.strings.importLabel;
  if(downloadCurveBtn) downloadCurveBtn.textContent = strings.downloadButton || defaultConfig.strings.downloadButton;
  if(thresholdTitleEl) thresholdTitleEl.textContent = strings.thresholdTitle || defaultConfig.strings.thresholdTitle;
  if(importControls) importControls.style.display = isImportVisible() ? 'flex' : 'none';
  if(downloadCurveBtn) downloadCurveBtn.style.display = isDownloadVisible() ? 'inline-block' : 'none';
  if(slidersSection) slidersSection.style.display = isSlidersVisible() ? 'block' : 'none';
  if(rocPlotContainer) rocPlotContainer.style.display = isRocPlotVisible() ? 'block' : 'none';
  if(thresholdSection) thresholdSection.style.display = isThresholdPlotVisible() ? 'block' : 'none';
  if(bestUtilityDiv){
    if(isBestUtilityVisible()){
      bestUtilityDiv.style.display = '';
      if(!bestUtilityDiv.textContent){
        bestUtilityDiv.textContent = strings.bestUtilityUnavailable || defaultConfig.strings.bestUtilityUnavailable;
      }
    }else{
      bestUtilityDiv.style.display = 'none';
      bestUtilityDiv.textContent = '';
    }
  }
}

async function loadAppConfig(){
  let fetchedConfig = null;
  try{
    const response = await fetch('roc_config.json');
    if(!response.ok) throw new Error(`HTTP ${response.status}`);
    fetchedConfig = await response.json();
  }catch(err){
    warnFromConfig('failConfigLoad', {message: err.message || err});
  }
  appConfig = cloneDeep(defaultConfig);
  if(fetchedConfig){
    mergeDeep(appConfig, fetchedConfig);
  }
  updateConfigReferences();
  applyConfigToUI();
  buildControlPanels();
}

function isRocPlotVisible(){ return !(uiSettings && uiSettings.showRocPlot === false); }
function isThresholdPlotVisible(){ return !(uiSettings && uiSettings.showThresholdPlot === false); }
function isSlidersVisible(){ return !(uiSettings && uiSettings.showSliders === false); }
function isImportVisible(){ return !(uiSettings && uiSettings.showImport === false); }
function isDownloadVisible(){ return !(uiSettings && uiSettings.showDownloadButton === false); }
function isBestUtilityVisible(){ return !(uiSettings && uiSettings.showBestUtility === false); }

function resolveVariantLabel(curveId, meta){
  if(!meta || !meta.original_curve_id || meta.original_curve_id === curveId) return curveId;
  const format = strings.variantLabelFormat || "{original} ({source})";
  const sourceLabel = meta.loaded_via || meta.source || strings.variantSourceFallback || defaultConfig.strings.variantSourceFallback;
  return formatString(format, {original: meta.original_curve_id, source: sourceLabel});
}

function loadROCData(data, preferredSelection) {
  const previousSelection = preferredSelection || rocSelect.value;
  rocCurves = data;
  rocSelect.innerHTML = '';
  const curveNames = Object.keys(rocCurves).sort((a,b)=>a.localeCompare(b));
  curveNames.forEach(k => {
    const opt = document.createElement('option');
    opt.value = k;
    const curve = rocCurves[k];
    const meta = curve && curve.metadata;
    opt.textContent = resolveVariantLabel(k, meta);
    rocSelect.appendChild(opt);
  });
  if (previousSelection && rocCurves[previousSelection]) {
    rocSelect.value = previousSelection;
  } else if (rocSelect.options.length) {
    rocSelect.selectedIndex = 0;
  }
  drawAll();
}

function getPayoffParams(){
  return {
    P_POS: values.P_POS,
    TP: values.TP,
    FP: values.FP,
    TN: values.TN,
    FN: values.FN
  };
}

function utilityAtRates(fpr,tpr,payoffs){
  if(!Number.isFinite(fpr) || !Number.isFinite(tpr)) return NaN;
  const {P_POS, TP, FP, TN, FN} = payoffs;
  const N = POPULATION_SIZE;
  const ap = N * P_POS;
  const an = N * (1 - P_POS);
  const tp = tpr * ap;
  const fn = (1 - tpr) * ap;
  const fp = fpr * an;
  const tn = an - fp;
  return FP * fp + TN * tn + TP * tp + FN * fn;
}

function getIsoCoefficients(payoffs){
  const {P_POS, TP, FP, TN, FN} = payoffs;
  const N = POPULATION_SIZE;
  const ap = N * P_POS;
  const an = N * (1 - P_POS);
  return {
    a: TN * an + FN * ap,
    b: FP * an - TN * an,
    c: TP * ap - FN * ap
  };
}

function getCurveColor(index,total){
  const hue = (index * 360 / Math.max(total, 1)) % 360;
  return `hsl(${hue},70%,45%)`;
}

function getPriorConfig(){
  const sliderDefs = (appConfig && appConfig.sliders) ? appConfig.sliders : defaultConfig.sliders;
  return sliderDefs && sliderDefs.P_POS ? sliderDefs.P_POS : defaultConfig.sliders.P_POS;
}

function getPayoffConfig(){
  const base = defaultConfig.payoffs || {};
  const override = (appConfig && appConfig.payoffs) ? appConfig.payoffs : {};
  const keys = ['TP','FP','TN','FN'];
  const merged = {};
  keys.forEach(key=>{
    merged[key] = Object.assign({}, base[key] || {}, override[key] || {});
  });
  return merged;
}

function getPayoffInputMode(){
  const mode = uiSettings && uiSettings.payoffInputMode;
  return mode === 'text' ? 'text' : 'slider';
}

function ensureValue(key, defaultVal){
  if(!Number.isFinite(values[key])){
    values[key] = Number.isFinite(defaultVal) ? defaultVal : 0;
  }
}

function buildControlPanels(){
  buildPriorSlider();
  buildPayoffGrid();
}

function buildPriorSlider(){
  if(!priorControls) return;
  priorControls.innerHTML = '';
  const priorCfg = getPriorConfig();
  const defaultVal = Number(priorCfg && priorCfg.value);
  ensureValue('P_POS', Number.isFinite(defaultVal) ? defaultVal : 0.5);
  if(!isSlidersVisible()) return;

  const wrapper = document.createElement('div');
  wrapper.className = 'prior-slider';
  const headerRow = document.createElement('div');
  headerRow.style.display = 'flex';
  headerRow.style.justifyContent = 'space-between';
  headerRow.style.alignItems = 'center';

  const labelSpan = document.createElement('span');
  labelSpan.textContent = (priorCfg && priorCfg.label) || (defaultConfig.sliders.P_POS && defaultConfig.sliders.P_POS.label) || 'Proportion positive';

  const valueSpan = document.createElement('span');
  valueSpan.id = 'P_POSVal';
  valueSpan.textContent = values.P_POS;

  headerRow.appendChild(labelSpan);
  headerRow.appendChild(valueSpan);

  const range = document.createElement('input');
  range.type = 'range';
  range.id = 'P_POS';
  range.min = priorCfg && priorCfg.min !== undefined ? priorCfg.min : 0;
  range.max = priorCfg && priorCfg.max !== undefined ? priorCfg.max : 1;
  range.step = priorCfg && priorCfg.step !== undefined ? priorCfg.step : 0.01;
  range.value = values.P_POS;
  range.style.width = '100%';
  range.addEventListener('input', () => {
    values.P_POS = +range.value;
    valueSpan.textContent = range.value;
    drawAll();
  });

  wrapper.appendChild(headerRow);
  wrapper.appendChild(range);
  priorControls.appendChild(wrapper);
}

function buildPayoffGrid(){
  if(!payoffGridSection) return;
  const payoffCfg = getPayoffConfig();
  const payoffKeys = ['TP','FN','FP','TN'];
  payoffKeys.forEach(key=>{
    const cfg = payoffCfg[key] || {};
    const defaultVal = Number(cfg.value);
    ensureValue(key, Number.isFinite(defaultVal) ? defaultVal : 0);
  });
  payoffGridSection.innerHTML = '';
  if(!isSlidersVisible()) return;

  const gridStrings = strings.payoffGrid || defaultConfig.strings.payoffGrid || {};
  const mode = getPayoffInputMode();

  const table = document.createElement('table');
  table.className = 'payoff-grid';

  const thead = document.createElement('thead');
  const headerRow = document.createElement('tr');
  headerRow.appendChild(document.createElement('th'));
  const colPos = document.createElement('th');
  colPos.textContent = gridStrings.predictedPositive || 'Predicted Positive';
  headerRow.appendChild(colPos);
  const colNeg = document.createElement('th');
  colNeg.textContent = gridStrings.predictedNegative || 'Predicted Negative';
  headerRow.appendChild(colNeg);
  thead.appendChild(headerRow);
  table.appendChild(thead);

  const tbody = document.createElement('tbody');

  const rowPos = document.createElement('tr');
  const rowPosHeader = document.createElement('th');
  rowPosHeader.textContent = gridStrings.actualPositive || 'Actual Positive';
  rowPos.appendChild(rowPosHeader);
  rowPos.appendChild(createPayoffCell('TP', payoffCfg, mode));
  rowPos.appendChild(createPayoffCell('FN', payoffCfg, mode));
  tbody.appendChild(rowPos);

  const rowNeg = document.createElement('tr');
  const rowNegHeader = document.createElement('th');
  rowNegHeader.textContent = gridStrings.actualNegative || 'Actual Negative';
  rowNeg.appendChild(rowNegHeader);
  rowNeg.appendChild(createPayoffCell('FP', payoffCfg, mode));
  rowNeg.appendChild(createPayoffCell('TN', payoffCfg, mode));
  tbody.appendChild(rowNeg);

  table.appendChild(tbody);
  payoffGridSection.appendChild(table);
}

function createPayoffCell(key, payoffCfg, mode){
  const cfg = payoffCfg[key] || {};
  const gridStrings = strings.payoffGrid || defaultConfig.strings.payoffGrid || {};
  const cell = document.createElement('td');
  const wrapper = document.createElement('div');
  wrapper.className = 'payoff-cell';

  const label = document.createElement('div');
  label.className = 'payoff-cell-label';
  label.textContent = cfg.label || gridStrings[key] || key;
  wrapper.appendChild(label);

  if(mode === 'text'){
    const input = document.createElement('input');
    input.type = 'number';
    input.className = 'payoff-input-number';
    if(cfg.min !== undefined) input.min = cfg.min;
    if(cfg.max !== undefined) input.max = cfg.max;
    if(cfg.step !== undefined) input.step = cfg.step;
    input.value = values[key];
    input.addEventListener('input',()=>{
      const parsed = Number(input.value);
      if(Number.isFinite(parsed)){
        values[key] = parsed;
        drawAll();
      }
    });
    input.addEventListener('blur',()=>{
      if(!Number.isFinite(Number(input.value))){
        input.value = values[key];
      }
    });
    wrapper.appendChild(input);
  }else{
    const range = document.createElement('input');
    range.type = 'range';
    range.min = cfg.min ?? -100;
    range.max = cfg.max ?? 100;
    range.step = cfg.step ?? 1;
    range.value = values[key];
    range.style.width = '100%';
    const valueSpan = document.createElement('span');
    valueSpan.className = 'payoff-slider-value';
    valueSpan.textContent = values[key];
    range.addEventListener('input',()=>{
      values[key] = +range.value;
      valueSpan.textContent = range.value;
      drawAll();
    });
    wrapper.appendChild(range);
    wrapper.appendChild(valueSpan);
  }

  cell.appendChild(wrapper);
  return cell;
}

rocSelect.onchange = () => drawAll();
rocFileInput.addEventListener('change', handleDataFileSelection);
downloadCurveBtn.addEventListener('click', downloadSelectedCurveAsJson);

function handleDataFileSelection(evt){
  const inputEl=evt.target;
  const file=inputEl.files && inputEl.files[0];
  if(!file) return;
  const reader=new FileReader();
  reader.onload=()=>{
    try{
      const text=reader.result;
      const ext=(file.name.split('.').pop()||'').toLowerCase();
      const {data:parsed, sourceType}=parseRocDataFromText(text, ext);
      if(!parsed || !Object.keys(parsed).length){
        alertFromConfig('noCurvesFound');
        return;
      }
      const mergedMetadataKey=file.name || (sourceType==='json'?'import.json':'import.csv');
      const merged={...rocCurves};
      const addedIds=addCurvesToCollection(merged, parsed, {sourceType, sourceFile: mergedMetadataKey});
      if(!addedIds.length){
        alertFromConfig('noCurvesFound');
        return;
      }
      loadROCData(merged,addedIds[0]);
    }catch(err){
      console.error(err);
      alertFromConfig('failImport', {message: err.message});
    }finally{
      inputEl.value='';
    }
  };
  reader.onerror=()=>{
    console.error(reader.error);
    alertFromConfig('failRead', {message: reader.error ? reader.error.message : ''});
    inputEl.value='';
  };
  reader.readAsText(file);
}

function downloadSelectedCurveAsJson(){
  const curveName=rocSelect.value;
  if(!curveName || !rocCurves[curveName]){
    alertFromConfig('noCurveSelectedDownload');
    return;
  }
  const curve=rocCurves[curveName];
  const serialized=JSON.stringify(curve,null,2);
  const blob=new Blob([serialized],{type:'application/json'});
  const url=URL.createObjectURL(blob);
  const link=document.createElement('a');
  link.href=url;
  link.download=`${curveName}.json`;
  document.body.appendChild(link);
  link.click();
  setTimeout(()=>{document.body.removeChild(link);URL.revokeObjectURL(url);},0);
}

function drawAll(){
  if(isRocPlotVisible()){
    drawRocPlot();
  }else{
    ctx.clearRect(0,0,canvas.width,canvas.height);
  }
  if(isThresholdPlotVisible()){
    drawThresholdPlot();
  }else if(thresholdCtx){
    thresholdCtx.clearRect(0,0,thresholdCanvas.width,thresholdCanvas.height);
  }
}

function parseRocDataFromText(text, extHint){
  const normalizedExt = (extHint || '').toLowerCase();
  const parserOrder = normalizedExt==='json'
    ? ['json','csv']
    : normalizedExt==='csv'
      ? ['csv','json']
      : ['json','csv'];
  let lastError=null;
  for(const parser of parserOrder){
    try{
      if(parser==='json'){
        const raw=JSON.parse(text);
        const parsed=normalizeRocJson(raw);
        if(parsed && Object.keys(parsed).length){
          return {data:parsed, sourceType:'json'};
        }
      }else if(parser==='csv'){
        const parsed=parseRocCsv(text);
        if(parsed && Object.keys(parsed).length){
          return {data:parsed, sourceType:'csv'};
        }
      }
    }catch(err){
      lastError=err;
    }
  }
  if(lastError) throw lastError;
  throw new Error(getAlertTemplate('noCurvesFound'));
}

function slugifyLabel(value){
  return String(value||'curve').toLowerCase().replace(/[^a-z0-9]+/g,'-').replace(/^-+|-+$/g,'')||'curve';
}

function addCurvesToCollection(target, parsed, {sourceType, sourceFile} = {}){
  const addedIds=[];
  if(!parsed || typeof parsed!=='object') return addedIds;
  const suffixRoot=slugifyLabel(sourceFile ? sourceFile.split('/').pop().replace(/\.[^.]+$/,'') : '');
  Object.keys(parsed).forEach(originalId=>{
    const baseCurve=parsed[originalId];
    if(!baseCurve) return;
    const curve={...baseCurve};
    const metadata={...(curve.metadata||{})};
    if(sourceType){
      metadata.loaded_via=sourceType;
      if(!metadata.source) metadata.source=sourceType;
    }
    if(sourceFile){
      metadata.source_file=sourceFile;
      metadata.loaded_file=sourceFile;
    }
    if(originalId && metadata.original_curve_id===undefined) metadata.original_curve_id=originalId;
    let baseId=curve.name || originalId || (suffixRoot || 'curve');
    baseId=String(baseId);
    let finalId=baseId;
    if(target[finalId]){
      const baseSlug=slugifyLabel(baseId);
      const suffixBaseRaw = (suffixRoot && suffixRoot !== baseSlug) ? suffixRoot : (sourceType ? slugifyLabel(sourceType) : 'alt');
      const suffixBase = suffixBaseRaw || 'alt';
      let candidate=`${baseId}__${suffixBase}`;
      let counter=2;
      while(target[candidate]){
        candidate=`${baseId}__${suffixBase}_${counter}`;
        counter++;
      }
      finalId=candidate;
    }
    curve.name=finalId;
    curve.metadata=metadata;
    target[finalId]=curve;
    addedIds.push(finalId);
  });
  return addedIds;
}

async function loadStaticRocFiles(){
  let preferredSelection=null;
  let loadedAny=false;
  const merged={...rocCurves};
  const fileList = (appConfig && appConfig.data && Array.isArray(appConfig.data.staticFiles) && appConfig.data.staticFiles.length)
    ? appConfig.data.staticFiles
    : STATIC_DATA_FILES;
  for(const filePath of fileList){
    if(typeof filePath!=='string' || !filePath.trim()) continue;
    const trimmedPath=filePath.trim();
    try{
      const response=await fetch(trimmedPath);
      if(!response.ok) throw new Error(`HTTP ${response.status}`);
      const text=await response.text();
      const {data:parsed, sourceType}=parseRocDataFromText(text, trimmedPath.split('.').pop());
      const addedIds=addCurvesToCollection(merged, parsed, {sourceType, sourceFile: trimmedPath});
      if(addedIds.length){
        loadedAny=true;
        if(!preferredSelection) preferredSelection=addedIds[0];
      }
    }catch(err){
      console.error(err);
      warnFromConfig('failStaticLoad', {path: trimmedPath, message: err.message || err});
    }
  }
  if(loadedAny){
    loadROCData(merged,preferredSelection);
  }
  return loadedAny;
}

function parseRocCsv(text){
  if(!text || !text.trim()) throw new Error('CSV file is empty.');
  const rawLines=text.split(/\r?\n/);
  const lines=[];
  for(const line of rawLines){
    if(!line) continue;
    const trimmed=line.trim();
    if(!trimmed || trimmed.startsWith('#')) continue;
    lines.push(line);
  }
  if(lines.length<2) throw new Error('CSV must include a header row and at least one data row.');

  const headers=splitCsvLine(lines[0]).map(h=>h.trim());
  if(!headers.length) throw new Error('CSV header row is empty.');
  const indexMap={};
  headers.forEach((header,idx)=>{ if(header) indexMap[header]=idx; });

  const required=['curve_id','fpr','tpr'];
  const missing=required.filter(name=>!(name in indexMap));
  if(missing.length) throw new Error(`Missing required column(s): ${missing.join(', ')}`);

  const curveIdx=indexMap.curve_id;
  const fprIdx=indexMap.fpr;
  const tprIdx=indexMap.tpr;
  const thresholdIdx=Object.prototype.hasOwnProperty.call(indexMap,'threshold')?indexMap.threshold:-1;
  const simpleLowerIdx=Object.prototype.hasOwnProperty.call(indexMap,'tpr_lower')?indexMap.tpr_lower:-1;
  const simpleUpperIdx=Object.prototype.hasOwnProperty.call(indexMap,'tpr_upper')?indexMap.tpr_upper:-1;

  const bandIndexMap={};
  headers.forEach((header,idx)=>{
    const match=header.match(/^tpr_(lower|upper)_(\d+(?:\.\d+)*)$/);
    if(match){
      const type=match[1];
      const levelKey=match[2];
      if(!bandIndexMap[levelKey]) bandIndexMap[levelKey]={};
      bandIndexMap[levelKey][type]=idx;
    }
  });

  const usedIndexes=new Set([curveIdx,fprIdx,tprIdx]);
  if(thresholdIdx!==-1) usedIndexes.add(thresholdIdx);
  if(simpleLowerIdx!==-1) usedIndexes.add(simpleLowerIdx);
  if(simpleUpperIdx!==-1) usedIndexes.add(simpleUpperIdx);
  Object.values(bandIndexMap).forEach(cols=>{
    if(typeof cols.lower==='number') usedIndexes.add(cols.lower);
    if(typeof cols.upper==='number') usedIndexes.add(cols.upper);
  });

  const extraColumns=headers
    .map((header,idx)=>({header,idx}))
    .filter(item=>!usedIndexes.has(item.idx));

  const groups={};
  for(let i=1;i<lines.length;i++){
    const row=splitCsvLine(lines[i]);
    if(!row.length || row.every(cell=>cell.trim()==='')) continue;
    const curveIdRaw=row[curveIdx]!==undefined?row[curveIdx].trim():'';
    if(!curveIdRaw) continue;
    const fpr=toNumber(row[fprIdx]);
    const tpr=toNumber(row[tprIdx]);
    if(!Number.isFinite(fpr)||!Number.isFinite(tpr)) continue;

    let group=groups[curveIdRaw];
    if(!group){
      group={
        fpr:[],
        tpr:[],
        threshold:thresholdIdx!==-1?[]:null,
        simpleLower:simpleLowerIdx!==-1?[]:null,
        simpleUpper:simpleUpperIdx!==-1?[]:null,
        bands:{},
        metadataValues:{}
      };
      Object.keys(bandIndexMap).forEach(levelKey=>{
        group.bands[levelKey]={lower:[],upper:[]};
      });
      groups[curveIdRaw]=group;
    }

    group.fpr.push(fpr);
    group.tpr.push(tpr);

    if(group.threshold){
      const value=toNumber(row[thresholdIdx]);
      group.threshold.push(Number.isFinite(value)?value:null);
    }
    if(group.simpleLower){
      const value=toNumber(row[simpleLowerIdx]);
      group.simpleLower.push(Number.isFinite(value)?value:null);
    }
    if(group.simpleUpper){
      const value=toNumber(row[simpleUpperIdx]);
      group.simpleUpper.push(Number.isFinite(value)?value:null);
    }

    Object.keys(bandIndexMap).forEach(levelKey=>{
      const band=group.bands[levelKey];
      const lowerIdx=bandIndexMap[levelKey].lower;
      const upperIdx=bandIndexMap[levelKey].upper;
      if(typeof lowerIdx==='number'){
        const value=toNumber(row[lowerIdx]);
        band.lower.push(Number.isFinite(value)?value:null);
      }else{
        band.lower.push(null);
      }
      if(typeof upperIdx==='number'){
        const value=toNumber(row[upperIdx]);
        band.upper.push(Number.isFinite(value)?value:null);
      }else{
        band.upper.push(null);
      }
    });

    extraColumns.forEach(({header,idx})=>{
      const value=row[idx];
      if(value===undefined) return;
      const trimmed=value.trim();
      if(!trimmed) return;
      if(!group.metadataValues[header]) group.metadataValues[header]=new Set();
      group.metadataValues[header].add(trimmed);
    });
  }

  const result={};
  Object.keys(groups).forEach(curveId=>{
    const group=groups[curveId];
    if(!group.fpr.length || !group.tpr.length) return;
    const curve={name:curveId,type:'ROC',fpr:group.fpr,tpr:group.tpr};

    if(group.threshold && group.threshold.some(Number.isFinite)){
      curve.threshold=group.threshold;
    }
    if(group.simpleLower && group.simpleUpper && group.simpleLower.some(Number.isFinite) && group.simpleUpper.some(Number.isFinite)){
      curve.tpr_lower=group.simpleLower;
      curve.tpr_upper=group.simpleUpper;
    }

    const bandEntries=Object.keys(group.bands).map(levelKey=>{
      const level=parseFloat(levelKey);
      const lowerArr=group.bands[levelKey].lower;
      const upperArr=group.bands[levelKey].upper;
      const hasLower=lowerArr.some(Number.isFinite);
      const hasUpper=upperArr.some(Number.isFinite);
      return {
        level:Number.isFinite(level)?level:levelKey,
        lower:hasLower?lowerArr:[],
        upper:hasUpper?upperArr:[]
      };
    }).filter(b=>b.lower.length||b.upper.length);

    if(bandEntries.length){
      bandEntries.sort((a,b)=>{
        const aVal=typeof a.level==='number'?a.level:parseFloat(a.level)||0;
        const bVal=typeof b.level==='number'?b.level:parseFloat(b.level)||0;
        return aVal-bVal;
      });
      curve.bands=bandEntries;
      if(!curve.tpr_lower && !curve.tpr_upper){
        const fallback=bandEntries[bandEntries.length-1];
        if(fallback){
          if(fallback.lower.length) curve.tpr_lower=fallback.lower;
          if(fallback.upper.length) curve.tpr_upper=fallback.upper;
        }
      }
    }

    const metadata={source:'csv'};
    Object.keys(group.metadataValues).forEach(key=>{
      const values=Array.from(group.metadataValues[key]);
      if(values.length===1){
        metadata[key]=values[0];
      }
    });
    curve.metadata=metadata;

    result[curveId]=curve;
  });

  return result;
}

function normalizeRocJson(raw){
  if(raw===null || raw===undefined) throw new Error('JSON content is empty.');
  const result={};

  const coerceNumericArray=(arr,{allowNull=false,label})=>{
    if(!Array.isArray(arr)) throw new Error(`${label} must be an array.`);
    return arr.map((value,idx)=>{
      if(value===null || value===undefined || value===''){
        if(allowNull) return null;
        throw new Error(`${label} has missing value at index ${idx}.`);
      }
      if(typeof value==='number' && Number.isFinite(value)) return value;
      const num=toNumber(value);
      if(Number.isFinite(num)) return num;
      if(allowNull) return null;
      throw new Error(`${label} has non-numeric value at index ${idx}.`);
    });
  };

  const addCurve=(curveObj,keyHint)=>{
    if(!curveObj || typeof curveObj!=='object' || Array.isArray(curveObj)){
      throw new Error(`Curve entry "${keyHint}" must be an object.`);
    }
    const curveId=curveObj.name || curveObj.curve_id || keyHint;
    if(!curveId) throw new Error('Curve entry is missing a name or curve_id.');
    if(!Array.isArray(curveObj.fpr)) throw new Error(`${curveId}.fpr must be an array.`);
    if(!Array.isArray(curveObj.tpr)) throw new Error(`${curveId}.tpr must be an array.`);
    const fpr=coerceNumericArray(curveObj.fpr,{allowNull:false,label:`${curveId}.fpr`});
    const tpr=coerceNumericArray(curveObj.tpr,{allowNull:false,label:`${curveId}.tpr`});
    if(fpr.length!==tpr.length) throw new Error(`${curveId} has mismatched fpr/tpr lengths.`);

    const normalized={
      name: curveId,
      type: curveObj.type || 'ROC',
      fpr,
      tpr
    };

    if(curveObj.threshold!==undefined){
      if(!Array.isArray(curveObj.threshold)) throw new Error(`${curveId}.threshold must be an array.`);
      const threshold=coerceNumericArray(curveObj.threshold,{allowNull:true,label:`${curveId}.threshold`});
      if(threshold.length!==fpr.length) throw new Error(`${curveId}.threshold length must match fpr/tpr.`);
      normalized.threshold=threshold;
    }
    if(curveObj.tpr_lower!==undefined){
      if(!Array.isArray(curveObj.tpr_lower)) throw new Error(`${curveId}.tpr_lower must be an array.`);
      const lower=coerceNumericArray(curveObj.tpr_lower,{allowNull:true,label:`${curveId}.tpr_lower`});
      if(lower.length!==fpr.length) throw new Error(`${curveId}.tpr_lower length must match fpr/tpr.`);
      normalized.tpr_lower=lower;
    }
    if(curveObj.tpr_upper!==undefined){
      if(!Array.isArray(curveObj.tpr_upper)) throw new Error(`${curveId}.tpr_upper must be an array.`);
      const upper=coerceNumericArray(curveObj.tpr_upper,{allowNull:true,label:`${curveId}.tpr_upper`});
      if(upper.length!==fpr.length) throw new Error(`${curveId}.tpr_upper length must match fpr/tpr.`);
      normalized.tpr_upper=upper;
    }
    if(Array.isArray(curveObj.bands)){
      const bands=curveObj.bands.map((band,index)=>{
        if(!band || typeof band!=='object' || Array.isArray(band)){
          throw new Error(`${curveId}.bands[${index}] must be an object.`);
        }
        const level=band.level!==undefined?band.level:(band.credible_level!==undefined?band.credible_level:band.confidence_level!==undefined?band.confidence_level:(index+1));
        const lower=band.lower!==undefined?coerceNumericArray(band.lower,{allowNull:true,label:`${curveId}.bands[${index}].lower`}):[];
        const upper=band.upper!==undefined?coerceNumericArray(band.upper,{allowNull:true,label:`${curveId}.bands[${index}].upper`}):[];
        if(lower.length && lower.length!==fpr.length) throw new Error(`${curveId}.bands[${index}].lower length must match fpr/tpr.`);
        if(upper.length && upper.length!==fpr.length) throw new Error(`${curveId}.bands[${index}].upper length must match fpr/tpr.`);
        return {
          level,
          lower,
          upper
        };
      }).filter(band=>band.lower.length || band.upper.length);
      if(bands.length) normalized.bands=bands;
    }
    if(curveObj.metadata && typeof curveObj.metadata==='object' && !Array.isArray(curveObj.metadata)){
      normalized.metadata={...curveObj.metadata};
    }
    result[curveId]=normalized;
  };

  if(Array.isArray(raw)){
    raw.forEach((curve,idx)=>{
      if(curve && typeof curve==='object' && Array.isArray(curve.fpr) && Array.isArray(curve.tpr)){
        addCurve(curve, curve.name || curve.curve_id || `curve_${idx}`);
      }
    });
  }else if(typeof raw==='object'){
    if(Array.isArray(raw.curves)){
      raw.curves.forEach((curve,idx)=>{
        if(curve && typeof curve==='object' && Array.isArray(curve.fpr) && Array.isArray(curve.tpr)){
          addCurve(curve, curve.name || curve.curve_id || `curve_${idx}`);
        }
      });
    }
    Object.keys(raw).forEach(key=>{
      if(key==='curves' && Array.isArray(raw[key])) return;
      const candidate=raw[key];
      if(candidate && typeof candidate==='object' && Array.isArray(candidate.fpr) && Array.isArray(candidate.tpr)){
        addCurve(candidate, key);
      }
    });
  }else{
    throw new Error('JSON root must be an array or object.');
  }

  return result;
}

function splitCsvLine(line){
  const result=[];
  let current='';
  let inQuotes=false;
  for(let i=0;i<line.length;i++){
    const char=line[i];
    if(char==='\"'){
      if(inQuotes && line[i+1]==='\"'){
        current+='\"';
        i++;
      }else{
        inQuotes=!inQuotes;
      }
    }else if(char===',' && !inQuotes){
      result.push(current);
      current='';
    }else{
      current+=char;
    }
  }
  result.push(current);
  return result;
}

function toNumber(value){
  if(value===undefined || value===null) return NaN;
  const trimmed=typeof value==='string'?value.trim():value;
  if(trimmed==='') return NaN;
  const num=Number(trimmed);
  return Number.isFinite(num)?num:NaN;
}

function hslToRgb(h,s,l){const a=s*Math.min(l,1-l);const f=n=>{const k=(n+h*12)%12;const color=l-a*Math.max(Math.min(k-3,9-k,1),-1);return Math.round(255*color);};return [f(0),f(8),f(4)];}
function heatColor(s){const h=240-240*s;const [r,g,b]=hslToRgb(h/360,0.6,0.85);return [r,g,b];}

function drawRocPlot(){
  const rocName=rocSelect.value;
  if(!rocName || !rocCurves[rocName]){
    ctx.clearRect(0,0,canvas.width,canvas.height);
    if(bestUtilityDiv && isBestUtilityVisible()){
      bestUtilityDiv.textContent = strings.bestUtilityUnavailable || defaultConfig.strings.bestUtilityUnavailable;
    }
    return;
  }
  const roc=rocCurves[rocName];
  const fpr=roc.fpr, tpr=roc.tpr;
  let lower=roc.tpr_lower, upper=roc.tpr_upper;
  if((!lower || !upper) && Array.isArray(roc.bands) && roc.bands.length){
    const sortedBands=[...roc.bands].sort((a,b)=>{
      const aVal=typeof a.level==='number'?a.level:parseFloat(a.level)||0;
      const bVal=typeof b.level==='number'?b.level:parseFloat(b.level)||0;
      return aVal-bVal;
    });
    const fallback=sortedBands[sortedBands.length-1];
    if(fallback){
      if(!lower) lower=fallback.lower;
      if(!upper) upper=fallback.upper;
    }
  }
  const payoffs=getPayoffParams();
  const {P_POS: pPos, TP, FP, TN, FN} = payoffs;
  const width=canvas.width, height=canvas.height;

  const margin=0.05; const labelOffsetFactor = 0.6; const labelOffset = labelOffsetFactor * margin;
  const x0=margin*width; const y0=margin*height; const plotW=width*(1-2*margin); const plotH=height*(1-2*margin);
  const xScale=(xf)=>x0+xf*plotW; const yScale=(yt)=>y0+(1-yt)*plotH;
  const clamp01=(v)=>Math.max(0,Math.min(1,v));

  const {a,b,c}=getIsoCoefficients(payoffs);
  const isoEnabled=Number.isFinite(c) && Math.abs(c)>1e-9;

  ctx.clearRect(0,0,width,height);

  const iw=Math.max(2,Math.floor(plotW)); const ih=Math.max(2,Math.floor(plotH));
  const img=ctx.createImageData(iw,ih); const data=img.data; let minU=Infinity,maxU=-Infinity; const utilities=[];
  for(let j=0;j<ih;j++){
    const tprVal=1-j/(ih-1);
    for(let i=0;i<iw;i++){
      const fprVal=i/(iw-1);
      const u=utilityAtRates(fprVal,tprVal,payoffs);
      utilities.push(u);
      if(u<minU)minU=u;
      if(u>maxU)maxU=u;
    }
  }
  const scale=v=>(v-minU)/(maxU-minU||1);
  let k=0;for(let j=0;j<ih;j++){for(let i=0;i<iw;i++){const s=scale(utilities[j*iw+i]);const [r,g,b2]=heatColor(s);data[k++]=r;data[k++]=g;data[k++]=b2;data[k++]=255;}}
  ctx.putImageData(img,Math.round(x0),Math.round(y0));

  ctx.save();
  ctx.beginPath(); ctx.rect(x0,y0,plotW,plotH); ctx.clip();

  if(isoEnabled){
    const nLines=10;
    const step=(maxU-minU)/(nLines+1||1);
    ctx.strokeStyle='rgba(0,0,0,0.4)'; ctx.lineWidth=1; ctx.setLineDash([4,4]);
    ctx.font='12px sans-serif'; ctx.fillStyle='black'; ctx.textBaseline='middle';
    for(let i=1;i<=nLines;i++){
      const level=minU+i*step;
      const tpr0=(level-a-b*0)/c; const tpr1=(level-a-b*1)/c;
      if(!Number.isFinite(tpr0) || !Number.isFinite(tpr1)) continue;
      const yA=yScale(tpr0), yB=yScale(tpr1);
      ctx.beginPath(); ctx.moveTo(xScale(0),yA); ctx.lineTo(xScale(1),yB); ctx.stroke();

      const tprLeft=(level-a)/c;
      const fprBottom=(level-a)/b;
      const offsetX = labelOffset * plotW; const offsetY = labelOffset * plotH;
      if(Number.isFinite(tprLeft) && tprLeft>=0 && tprLeft<=1){
        const xL=xScale(0)+offsetX; const yL=yScale(tprLeft);
        ctx.fillText(Math.round(level),xL,yL);
      } else if(Number.isFinite(fprBottom) && fprBottom>=0 && fprBottom<=1){
        const xB=xScale(clamp01(fprBottom)); const yBtm=yScale(0)-offsetY;
        ctx.textAlign='center'; ctx.fillText(Math.round(level),xB,yBtm); ctx.textAlign='left';
      }
    }
    ctx.setLineDash([]);
  }
  else{
    ctx.setLineDash([]);
  }

  const denominator = (pPos*(TP-FN));
  if(denominator){
    const s=((1-pPos)*(TN-FP))/denominator;
    ctx.strokeStyle='limegreen'; ctx.lineWidth=3; ctx.setLineDash([10,10]);
    const drawOne=(intercept)=>{ctx.beginPath();ctx.moveTo(xScale(0),yScale(intercept));ctx.lineTo(xScale(1),yScale(s+intercept));ctx.stroke();};
    drawOne(0); drawOne(1-s); ctx.setLineDash([]);
  }

  ctx.restore();

  if(Array.isArray(lower) && Array.isArray(upper) && lower.length===fpr.length && upper.length===fpr.length){
    ctx.beginPath(); ctx.moveTo(xScale(fpr[0]),yScale(upper[0])); for(let i=1;i<fpr.length;i++)ctx.lineTo(xScale(fpr[i]),yScale(upper[i])); for(let i=fpr.length-1;i>=0;i--)ctx.lineTo(xScale(fpr[i]),yScale(lower[i])); ctx.closePath(); ctx.fillStyle='rgba(0,0,255,0.2)'; ctx.fill();
    ctx.beginPath(); ctx.strokeStyle='rgba(0,0,180,0.6)'; ctx.lineWidth=1;
    for(let i=0;i<fpr.length;i++){if(i===0)ctx.moveTo(xScale(fpr[i]),yScale(upper[i]));else ctx.lineTo(xScale(fpr[i]),yScale(upper[i]));} ctx.stroke();
    ctx.beginPath(); for(let i=0;i<fpr.length;i++){if(i===0)ctx.moveTo(xScale(fpr[i]),yScale(lower[i]));else ctx.lineTo(xScale(fpr[i]),yScale(lower[i]));} ctx.stroke();
  }

  let bestU=-Infinity,bestPt=null;
  ctx.beginPath(); ctx.strokeStyle='blue'; ctx.lineWidth=2;
  let firstPoint=true;
  for(let i=0;i<fpr.length;i++){
    const fVal=Number(fpr[i]);
    const tVal=Number(tpr[i]);
    if(!Number.isFinite(fVal) || !Number.isFinite(tVal)) continue;
    const x=xScale(fVal),y=yScale(tVal);
    if(firstPoint){ctx.moveTo(x,y); firstPoint=false;} else ctx.lineTo(x,y);
    const u=utilityAtRates(fVal,tVal,payoffs);
    if(Number.isFinite(u) && u>bestU){bestU=u;bestPt={x,y};}
  }
  if(!firstPoint) ctx.stroke();
  if(bestPt){
    ctx.beginPath();ctx.arc(bestPt.x,bestPt.y,6,0,2*Math.PI);
    ctx.fillStyle='yellow';ctx.strokeStyle='red';ctx.fill();ctx.stroke();
    if(bestUtilityDiv && isBestUtilityVisible()){
      const prefix = strings.bestUtilityPrefix || defaultConfig.strings.bestUtilityPrefix;
      bestUtilityDiv.textContent = `${prefix}${Math.round(bestU)}`;
    }
  } else if(bestUtilityDiv && isBestUtilityVisible()){
    bestUtilityDiv.textContent = strings.bestUtilityUnavailable || defaultConfig.strings.bestUtilityUnavailable;
  }

  ctx.strokeStyle='#666'; ctx.lineWidth=1; ctx.strokeRect(x0,y0,plotW,plotH);
}

function drawThresholdPlot(){
  if(!thresholdCanvas || !thresholdCtx){
    return;
  }
  const width=thresholdCanvas.width;
  const height=thresholdCanvas.height;
  thresholdCtx.clearRect(0,0,width,height);
  if(!isThresholdPlotVisible()){
    return;
  }

  const payoffs=getPayoffParams();
  const curveIds=Object.keys(rocCurves).sort((a,b)=>a.localeCompare(b));
  const selectedId=rocSelect.value;

  const datasets=[];
  let minThreshold=Infinity,maxThreshold=-Infinity,minUtility=Infinity,maxUtility=-Infinity;

  const buildThresholdSeries=(curve,length)=>{
    if(Array.isArray(curve.threshold) && curve.threshold.length>=length){
      const values=[];
      let valid=true;
      for(let i=0;i<length;i++){
        const value=Number(curve.threshold[i]);
        if(Number.isFinite(value)){
          values.push(value);
        }else{
          valid=false;
          break;
        }
      }
      if(valid){
        return {values, synthetic:false, source:'threshold'};
      }
    }
    if(Array.isArray(curve.fpr) && curve.fpr.length>=length){
      const values=[];
      let valid=true;
      for(let i=0;i<length;i++){
        const value=Number(curve.fpr[i]);
        if(Number.isFinite(value)){
          values.push(value);
        }else{
          valid=false;
          break;
        }
      }
      if(valid){
        return {values, synthetic:true, source:'fpr'};
      }
    }
    const values=[];
    if(length<=1){
      values.push(0);
    }else{
      for(let i=0;i<length;i++){
        values.push(i/(length-1));
      }
    }
    return {values, synthetic:true, source:'index'};
  };

  curveIds.forEach((curveId,curveIndex)=>{
    const curve=rocCurves[curveId];
    if(!curve) return;
    if(!Array.isArray(curve.fpr) || !Array.isArray(curve.tpr)) return;
    const length=Math.min(curve.fpr.length, curve.tpr.length);
    if(!length) return;
    const thresholdSeries=buildThresholdSeries(curve,length);
    const entries=[];
    for(let i=0;i<length;i++){
      const thresholdValue=Number(thresholdSeries.values[i]);
      const fpr=Number(curve.fpr[i]);
      const tpr=Number(curve.tpr[i]);
      if(!Number.isFinite(thresholdValue) || !Number.isFinite(fpr) || !Number.isFinite(tpr)) continue;
      const utility=utilityAtRates(fpr,tpr,payoffs);
      if(!Number.isFinite(utility)) continue;
      entries.push({threshold:thresholdValue, utility});
    }
    if(!entries.length) return;
    entries.sort((a,b)=>a.threshold-b.threshold || a.utility-b.utility);
    entries.forEach(pt=>{
      if(pt.threshold<minThreshold) minThreshold=pt.threshold;
      if(pt.threshold>maxThreshold) maxThreshold=pt.threshold;
      if(pt.utility<minUtility) minUtility=pt.utility;
      if(pt.utility>maxUtility) maxUtility=pt.utility;
    });
    const meta=curve.metadata||{};
    const baseLabel = resolveVariantLabel(curveId, meta);
    datasets.push({
      id:curveId,
      label:baseLabel,
      entries,
      color:getCurveColor(curveIndex, curveIds.length),
      isSelected: curveId===selectedId,
      synthetic: thresholdSeries.synthetic
    });
  });

  if(!datasets.length){
    thresholdCtx.fillStyle='#333';
    thresholdCtx.font='16px sans-serif';
    thresholdCtx.textAlign='center';
    thresholdCtx.textBaseline='middle';
    thresholdCtx.fillText(strings.noThresholdData || defaultConfig.strings.noThresholdData, width/2, height/2);
    return;
  }

  if(minThreshold===Infinity || maxThreshold===-Infinity){
    minThreshold=0;
    maxThreshold=1;
  }
  if(minThreshold===maxThreshold){
    minThreshold-=0.5;
    maxThreshold+=0.5;
  }
  if(!Number.isFinite(minUtility) || !Number.isFinite(maxUtility)){
    minUtility=0;
    maxUtility=1;
  }
  if(minUtility===maxUtility){
    const adjust=Math.max(1, Math.abs(minUtility||1));
    minUtility-=adjust/2;
    maxUtility+=adjust/2;
  }

  const marginLeft=70;
  const marginRight=30;
  const marginTop=30;

  const legendPadding=8;
  const legendItemHeight=18;
  const legendHeight=datasets.length ? legendItemHeight*datasets.length+legendPadding*2 : 0;
  const marginBottom=40+legendHeight;

  const plotW=Math.max(10,width-marginLeft-marginRight);
  const plotH=Math.max(10,height-marginTop-marginBottom);
  const xScale=(threshold)=>marginLeft+((threshold-minThreshold)/(maxThreshold-minThreshold||1))*plotW;
  const yScale=(utility)=>marginTop+(1-((utility-minUtility)/(maxUtility-minUtility||1)))*plotH;

  thresholdCtx.fillStyle='#f8f8f8';
  thresholdCtx.fillRect(marginLeft,marginTop,plotW,plotH);
  thresholdCtx.strokeStyle='#ccc';
  thresholdCtx.lineWidth=1;
  thresholdCtx.strokeRect(marginLeft,marginTop,plotW,plotH);

  thresholdCtx.strokeStyle='#444';
  thresholdCtx.lineWidth=1.2;
  thresholdCtx.beginPath();
  thresholdCtx.moveTo(marginLeft, marginTop);
  thresholdCtx.lineTo(marginLeft, marginTop+plotH);
  thresholdCtx.lineTo(marginLeft+plotW, marginTop+plotH);
  thresholdCtx.stroke();

  thresholdCtx.fillStyle='#000';
  thresholdCtx.font='13px sans-serif';
  thresholdCtx.textAlign='center';
  thresholdCtx.fillText(strings.axisThreshold || defaultConfig.strings.axisThreshold, marginLeft + plotW/2, marginTop+plotH+28);
  thresholdCtx.save();
  thresholdCtx.translate(18, marginTop + plotH/2);
  thresholdCtx.rotate(-Math.PI/2);
  thresholdCtx.fillText(strings.axisUtility || defaultConfig.strings.axisUtility, 0,0);
  thresholdCtx.restore();

  thresholdCtx.fillStyle='#000';
  thresholdCtx.font='12px sans-serif';
  thresholdCtx.textAlign='center';
  const xTickCount=5;
  for(let i=0;i<xTickCount;i++){
    const t=minThreshold+(i/(xTickCount-1||1))*(maxThreshold-minThreshold);
    const x=xScale(t);
    thresholdCtx.beginPath();
    thresholdCtx.moveTo(x, marginTop+plotH);
    thresholdCtx.lineTo(x, marginTop+plotH+6);
    thresholdCtx.strokeStyle='#444';
    thresholdCtx.stroke();
    thresholdCtx.fillText(Number(t).toFixed(2), x, marginTop+plotH+20);
  }

  thresholdCtx.textAlign='right';
  const yTickCount=5;
  for(let i=0;i<yTickCount;i++){
    const frac=i/(yTickCount-1||1);
    const u=minUtility+frac*(maxUtility-minUtility);
    const y=yScale(u);
    thresholdCtx.beginPath();
    thresholdCtx.moveTo(marginLeft-6,y);
    thresholdCtx.lineTo(marginLeft,y);
    thresholdCtx.strokeStyle='#444';
    thresholdCtx.stroke();
    thresholdCtx.fillText(Math.round(u).toString(), marginLeft-8, y+4);
  }

  if(minUtility<0 && maxUtility>0){
    const zeroY=yScale(0);
    thresholdCtx.strokeStyle='rgba(0,0,0,0.2)';
    thresholdCtx.setLineDash([4,4]);
    thresholdCtx.beginPath();
    thresholdCtx.moveTo(marginLeft, zeroY);
    thresholdCtx.lineTo(marginLeft+plotW, zeroY);
    thresholdCtx.stroke();
    thresholdCtx.setLineDash([]);
  }

  datasets.forEach(dataset=>{
    thresholdCtx.beginPath();
    dataset.entries.forEach((pt,idx)=>{
      const x=xScale(pt.threshold);
      const y=yScale(pt.utility);
      if(idx===0) thresholdCtx.moveTo(x,y);
      else thresholdCtx.lineTo(x,y);
    });
    thresholdCtx.strokeStyle=dataset.color;
    thresholdCtx.lineWidth=dataset.isSelected?3:2;
    thresholdCtx.stroke();
    thresholdCtx.lineWidth=1;
    dataset.entries.forEach(pt=>{
      const x=xScale(pt.threshold);
      const y=yScale(pt.utility);
      thresholdCtx.beginPath();
      thresholdCtx.arc(x,y,dataset.isSelected?4:3,0,Math.PI*2);
      thresholdCtx.fillStyle=dataset.color;
      thresholdCtx.fill();
    });
  });

  if(legendHeight>0){
    const legendWidth=Math.min(260, plotW);
    const legendX=marginLeft+(plotW-legendWidth)/2;
    const legendY=marginTop+plotH+10;
    thresholdCtx.fillStyle='rgba(255,255,255,0.9)';
    thresholdCtx.strokeStyle='rgba(0,0,0,0.15)';
    thresholdCtx.lineWidth=1;
    thresholdCtx.fillRect(legendX, legendY, legendWidth, legendHeight);
    thresholdCtx.strokeRect(legendX, legendY, legendWidth, legendHeight);
    thresholdCtx.font='12px sans-serif';
    thresholdCtx.textAlign='left';
    datasets.forEach((dataset,index)=>{
      const y=legendY+legendPadding+legendItemHeight*index+legendItemHeight/2;
      thresholdCtx.fillStyle=dataset.color;
      thresholdCtx.fillRect(legendX+10, y-5, 16, 10);
      thresholdCtx.fillStyle='#000';
      const label=dataset.label || dataset.id;
      const selectedSuffix = dataset.isSelected ? (strings.legendSelectedSuffix || defaultConfig.strings.legendSelectedSuffix || '') : '';
      const syntheticSuffix = dataset.synthetic ? (strings.legendDerivedSuffix || defaultConfig.strings.legendDerivedSuffix || '') : '';
      thresholdCtx.fillText(`${label}${selectedSuffix}${syntheticSuffix}`, legendX+32, y+4);
    });
  }
}

canvas.addEventListener('mousemove',e=>{
  if(!isRocPlotVisible()){
    tooltip.style.display='none';
    return;
  }
  const rect=canvas.getBoundingClientRect(); const x=e.clientX-rect.left,y=e.clientY-rect.top;
  const width=canvas.width,height=canvas.height,margin=0.05,x0=margin*width,y0=margin*height,plotW=width*(1-2*margin),plotH=height*(1-2*margin);
  if(x<x0||x>x0+plotW||y<y0||y>y0+plotH){tooltip.style.display='none';return;}
  const fpr=(x-x0)/plotW,tpr=1-(y-y0)/plotH;
  const payoffs=getPayoffParams();
  const pPos=payoffs.P_POS;
  const N=POPULATION_SIZE;
  const ap=N*pPos,an=N*(1-pPos),tp=tpr*ap,fn=(1-tpr)*ap,fp=fpr*an,tn=an-fp;
  const u=utilityAtRates(fpr,tpr,payoffs);
  const tooltipWidth=140,tooltipHeight=48;
  tooltip.style.left=(x-tooltipWidth-10)+'px';
  tooltip.style.top=(y-tooltipHeight-10)+'px';
  const tooltipTemplate=strings.tooltipFormat || defaultConfig.strings.tooltipFormat;
  tooltip.textContent=formatString(tooltipTemplate,{
    fpr:fpr.toFixed(2),
    tpr:tpr.toFixed(2),
    utility: Math.round(u)
  });
  tooltip.style.display='block';
});
canvas.addEventListener('mouseleave',()=>tooltip.style.display='none');

window.addEventListener('DOMContentLoaded',async()=>{
  await loadAppConfig();
  const loaded=await loadStaticRocFiles();
  if(!loaded){
    const fallbackSelection=Object.keys(HARDCODED_FALLBACK_CURVES)[0]||null;
    loadROCData({...HARDCODED_FALLBACK_CURVES},fallbackSelection);
  }
  if(isBestUtilityVisible() && bestUtilityDiv && !bestUtilityDiv.textContent){
    bestUtilityDiv.textContent = strings.bestUtilityUnavailable || defaultConfig.strings.bestUtilityUnavailable;
  }
});
</script>
</body>
</html>
