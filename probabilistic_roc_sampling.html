<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Probabilistic View of AUC – Interactive ROC App</title>
<style>
  /* Base layout and typography */
  body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial; margin: 18px; background: #f9fafb; color: #111827; user-select: none; }
  h2 { text-align: center; margin: 0 0 8px; }
  #datasetSelector, #arrangeBar, #controls, #legend-container { text-align: center; }
  #stage { margin: auto; position: relative; }
  /* Ensure overlay is actually on top and visible during drags */
  #dragOverlay { position: absolute; left: 0; top: 0; z-index: 10; pointer-events: none; }
  button, select { padding: 6px 12px; border-radius: 6px; border: 1px solid #9ca3af; cursor: pointer; background: #e5e7eb; margin: 5px; }
  #legend-container svg { display: inline-block; margin-top: 10px; }
  text { user-select: none; pointer-events: none; font-size: 12px; fill: #111827; }
  #scatter-container, #matrix-container { border: 1px solid #d1d5db; border-radius: 8px; background: #fff; margin: 10px auto; }
</style>
</head>
<body>
<h2 id="appTitle"></h2>
<div id="datasetSelector">
  <label for="datasetSelect">Select dataset:</label>
  <select id="datasetSelect"></select>
</div>
<div id="stage">
  <div id="scatter-container"><svg id="scatterSVG"></svg></div>
  <div id="matrix-container"><svg id="matrixSVG"></svg></div>
  <svg id="dragOverlay"></svg>
</div>
<div id="arrangeBar"><button id="autoArrange"></button></div>
<div id="controls" style="display:none">
  <button id="randomSample"></button>
  <label for="sampleCount" id="pointsPerClick"></label>
  <select id="sampleCount"><option value="1">1</option><option value="10">10</option><option value="100">100</option></select>
  <div id="aucDisplay"></div>
</div>
<div id="legend-container"><svg id="legendSVG" width="560" height="160"></svg></div>

<script>
// ==================== Localized Strings ====================
const STRINGS = {
  title: "Probabilistic View of AUC",
  autoArrange: "Auto-Arrange Cases",
  randomSample: "Random Sample",
  pointsPerClick: "Points per click:",
  aucEstimate: "AUC estimate: — (0 pts)",
  scatterTitle: "Scatterplot of Scores",
  matrixTitle: "Matrix of Case Comparisons",
  scatterXAxis: "Score",
  labelPos: "Positive Cases",
  labelNeg: "Negative Cases",
  legend: [
    { color: '#ffff66', text: 'Positive > Negative (yellow)' },
    { color: '#ff3333', text: 'Positive < Negative (red)' },
    { color: '#ff9900', text: 'Tie (orange)' },
    { color: '#0077ff', text: 'ROC curve (blue)' }
  ]
};

// ==================== Static Text Injection ====================
(function setStaticText(){
  document.getElementById('appTitle').textContent = STRINGS.title;
  document.getElementById('autoArrange').textContent = STRINGS.autoArrange;
  document.getElementById('randomSample').textContent = STRINGS.randomSample;
  document.getElementById('pointsPerClick').textContent = STRINGS.pointsPerClick;
  document.getElementById('aucDisplay').textContent = STRINGS.aucEstimate;
})();

// ==================== Datasets ====================
const datasets = {
  "Test Set A": { scores: [20,19,18,17,16,15,14,13,11.5,11.5,10,9,8,7,6,5,4,3,2,1], labels: [1,1,1,1,0,1,1,0,1,0,1,0,1,0,0,1,0,0,0,0] },
  "Test Set B": { scores: [20,19,18,17,16,15,14,13,11.5,11.5,9.5,9.5,8,7,6,5,4,3,2,1], labels: [1,1,1,1,1,1,1,0,1,0,1,0,1,0,0,1,0,0,0,0] },
  "Test Set C": { 
    scores: [50,49,48,47,46,45,44,43,42,41,35,35,35,35,35,35,35,35,35,35,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,10,9,8,7,6,5,4,3,2,1], 
    labels: [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0] 
  },
  "Test Set D": { scores: Array.from({length:100},(_,i)=>100-i), labels: Array.from({length:100},(_,i)=> i<40?1:0 ) } // 40 positives, 60 negatives
};

// Populate selector
const datasetSelect = document.getElementById('datasetSelect');
for(const name in datasets){ const opt=document.createElement('option'); opt.value=name; opt.textContent=name; datasetSelect.appendChild(opt); }

// ==================== DOM Handles ====================
const scatter = document.getElementById('scatterSVG');
const matrix  = document.getElementById('matrixSVG');
const overlay = document.getElementById('dragOverlay');
const autoBtn = document.getElementById('autoArrange');
const randBtn = document.getElementById('randomSample');
const sampleSel = document.getElementById('sampleCount');
const aucDisplay = document.getElementById('aucDisplay');
const legend = document.getElementById('legendSVG');
const controls = document.getElementById('controls');

// ==================== Utility Makers ====================
function mk(tag, attrs={}){ const e=document.createElementNS('http://www.w3.org/2000/svg', tag); for(const k in attrs) e.setAttribute(k, attrs[k]); return e; }
function diamondPoints(x,y,r){ return `${x},${y-r} ${x+r},${y} ${x},${y+r} ${x-r},${y}`; }

// ==================== Resizing for Large Datasets ====================
function resizeForDataset(nNeg, nPos){
  const baseW = 900, baseMatrixH = 540, scatterH = 180;
  const diamondW = 24, circleH = 24;
  const extraW = Math.max(0, nNeg - 20);
  const extraH = Math.max(0, nPos - 30);
  const newW = baseW + extraW * diamondW;
  const newMatrixH = baseMatrixH + extraH * circleH;

  // ViewBoxes for proper coordinate transforms
  scatter.setAttribute('viewBox', `0 0 ${newW} ${scatterH}`);
  matrix.setAttribute('viewBox', `0 0 ${newW} ${newMatrixH}`);
  overlay.setAttribute('viewBox', `0 0 ${newW} ${newMatrixH + 300}`);

  // Explicit CSS sizes so SVGs are actually visible and overlay is tall enough for dragging
  scatter.style.width = newW + 'px';
  scatter.style.height = scatterH + 'px';
  matrix.style.width = newW + 'px';
  matrix.style.height = newMatrixH + 'px';
  overlay.style.width = newW + 'px';
  overlay.style.height = (newMatrixH + 300) + 'px';

  // Match container widths to avoid layout overflow hiding controls/buttons
  document.getElementById('stage').style.width = newW + 'px';
  document.getElementById('arrangeBar').style.width = newW + 'px';
  document.getElementById('controls').style.width = newW + 'px';
  document.getElementById('scatter-container').style.width = newW + 'px';
  document.getElementById('matrix-container').style.width = newW + 'px';
}

// ==================== Globals (reset each build) ====================
let nodes = [], posAnch = [], negAnch = [];
let cellLayer, rocPath, rocPoints, samplesOld, samplesNew;
let margin = 80, innerW = 0, W = 0, matrixH = 0, scatterHConst = 180;

// Helper to place a node's SVG
function setC(n,x,y){
  if(n.isPos){ n.shape.setAttribute('cx',x); n.shape.setAttribute('cy',y); }
  else { n.shape.setAttribute('points', diamondPoints(x,y,12)); }
  n.label.setAttribute('x',x); n.label.setAttribute('y',y);
}

// ==================== Builder ====================

function buildVisualization(scores, labels){
  const n = scores.length;
  const nPos = labels.filter(x=>x===1).length;
  const nNeg = labels.filter(x=>x===0).length;

  resizeForDataset(nNeg, nPos);

  // Clear SVGs
  scatter.innerHTML = '';
  matrix.innerHTML = '';
  overlay.innerHTML = '';
  legend.innerHTML = '';

  // Derived sizes
  W = parseFloat(scatter.getAttribute('viewBox').split(' ')[2]);
  matrixH = parseFloat(matrix.getAttribute('viewBox').split(' ')[3]);
  scatterHConst = parseFloat(scatter.getAttribute('viewBox').split(' ')[3]);
  margin = 80; // keep room for y-axis label
  innerW = W - 2*margin;

  // Colors
  const posColor='#2ca02c', negColor='#d62728';
  const palePos='#c7f0c7', paleNeg='#f7b3b3';
  const SHAPE_R=10, DIAMOND_R=12;

  // Scales
  const scoreMin=Math.min(...scores), scoreMax=Math.max(...scores);
  const scaleX=s=>margin+(s-scoreMin)/(scoreMax-scoreMin)*(innerW-40);

  // ---------- Scatter ----------
  const scatterTop=60, scatterBot=120;
  scatter.appendChild(mk('text',{x:W/2,y:20,'text-anchor':'middle','font-weight':'600'})).textContent=STRINGS.scatterTitle;
  scatter.appendChild(mk('text',{x:W/2,y:scatterHConst-5,'text-anchor':'middle','font-weight':'500'})).textContent=STRINGS.scatterXAxis;

  const numTicks=5;
  for(let i=0;i<=numTicks;i++){
    const val=scoreMin+(scoreMax-scoreMin)*i/numTicks;
    const x=scaleX(val);
    scatter.appendChild(mk('line',{x1:x,y1:scatterHConst-20,x2:x,y2:scatterHConst-10,stroke:'#555'}));
    scatter.appendChild(mk('text',{x:x,y:scatterHConst-25,'text-anchor':'middle'})).textContent=val.toFixed(1);
  }

  scatter.appendChild(mk('text',{x:margin,y:scatterTop-20,'text-anchor':'start','font-weight':'500'})).textContent=STRINGS.labelPos;
  scatter.appendChild(mk('text',{x:margin,y:scatterBot+25,'text-anchor':'start','font-weight':'500'})).textContent=STRINGS.labelNeg;

  // Detect duplicate scores
  const posGroups={}, negGroups={};
  scores.forEach((s,i)=>{
    if(labels[i]){ if(!posGroups[s])posGroups[s]=[]; posGroups[s].push(i); }
    else{ if(!negGroups[s])negGroups[s]=[]; negGroups[s].push(i); }
  });

  nodes=[]; posAnch=[]; negAnch=[];
  for(let i=0;i<n;i++){
    const score=scores[i];
    const isPos=!!labels[i];
    const x=scaleX(score);
    const baseY=isPos?scatterTop:scatterBot;
    const group=isPos?posGroups[score]:negGroups[score];
    let offset=0;
    if(group && group.length>1){
      const idx=group.indexOf(i);
      const spacing=4, center=(group.length-1)/2;
      offset=(idx-center)*spacing;
    }
    const y=baseY+offset;

    // Create dashed anchor
    const anchor=isPos
      ? mk('circle',{cx:x,cy:y,r:SHAPE_R,fill:'none',stroke:palePos,'stroke-width':'4','stroke-dasharray':'2 2'})
      : mk('polygon',{points:diamondPoints(x,y,DIAMOND_R),fill:'none',stroke:paleNeg,'stroke-width':'4','stroke-dasharray':'2 2'});
    scatter.appendChild(anchor);

    // Create draggable shape
    const shape=isPos
      ? mk('circle',{cx:x,cy:y,r:SHAPE_R,fill:posColor,stroke:'#222'})
      : mk('polygon',{points:diamondPoints(x,y,DIAMOND_R),fill:negColor,stroke:'#222'});
    const lbl=mk('text',{x,y,'text-anchor':'middle','dominant-baseline':'central','font-size':'11',fill:'#fff'});
    lbl.textContent=score;
    scatter.append(shape,lbl);

    nodes.push({isPos,score,shape,label:lbl,anchor,home:{x,y,svg:scatter},currentSVG:scatter});
  }
  // ---------- Matrix ----------
  const gridW=innerW-32, gridH=matrixH-120;
  const cellW=gridW/nNeg, cellH=gridH/nPos;

  // Add title for matrix area
  const matrixTitle = mk('text', {
    x: W / 2,
    y: 30,  // adjust as needed
    'text-anchor': 'middle',
    'font-weight': '600',
    'font-size': '16'
  });
  matrixTitle.textContent = STRINGS.matrixTitle;  // <-- customize title text
  matrix.appendChild(matrixTitle);

  // Matrix anchors (right for positives, top for negatives)
  for(let r=0;r<nPos;r++){
    const y=margin+(nPos-r-0.5)*cellH; const x=margin+gridW+28;
    matrix.appendChild(mk('circle',{cx:x,cy:y,r:SHAPE_R,fill:'none',stroke:palePos,'stroke-width':'4','stroke-dasharray':'2 2'}));
    posAnch.push({x,y,svg:matrix,occupied:null,isPos:true});
  }
  for(let c=0;c<nNeg;c++){
    const x=margin+(c+0.5)*cellW; const y=margin-30;
    matrix.appendChild(mk('polygon',{points:diamondPoints(x,y,DIAMOND_R),fill:'none',stroke:paleNeg,'stroke-width':'4','stroke-dasharray':'2 2'}));
    negAnch.push({x,y,svg:matrix,occupied:null,isPos:false});
  }

  // Grid cells
  for(let r=0;r<nPos;r++){
    for(let c=0;c<nNeg;c++){
      matrix.appendChild(mk('rect',{x:margin+c*cellW,y:margin+(nPos-r-1)*cellH,width:cellW,height:cellH,fill:'#fff',stroke:'#e5e7eb'}));
    }
  }

  // Numeric ticks
  for(let c=0;c<nNeg;c++){
    const x=margin+(c+0.5)*cellW; matrix.appendChild(mk('text',{x:x,y:matrixH-20,'text-anchor':'middle'})).textContent=c+1;
  }
  for(let r=0;r<nPos;r++){
    const y=margin+(nPos-r-0.5)*cellH; matrix.appendChild(mk('text',{x:margin-20,y:y,'text-anchor':'end'})).textContent=r+1;
  }

  // Axis labels (y = positives, x = negatives)
  matrix.appendChild(mk('text',{x:margin-40,y:matrixH/2,'text-anchor':'middle','dominant-baseline':'middle','transform':`rotate(-90, ${margin-40}, ${matrixH/2})`,'font-weight':'600','font-size':'14'})).textContent=STRINGS.labelPos;
  matrix.appendChild(mk('text',{x:margin+gridW/2,y:matrixH-5,'text-anchor':'middle','font-weight':'500'})).textContent=STRINGS.labelNeg;

  // ---------- Legend ----------
  STRINGS.legend.forEach((e,i)=>{
    const y=20+i*26; legend.appendChild(mk('rect',{x:20,y,width:14,height:14,fill:e.color,stroke:'#111'})); legend.appendChild(mk('text',{x:40,y:y+11})).textContent=e.text; });

  // Layers for colors, ROC, and sampling
  cellLayer = mk('g',{}); matrix.appendChild(cellLayer);
  rocPath = mk('path',{stroke:'#0077ff','stroke-width':'5',fill:'none',visibility:'hidden'});
  rocPoints = mk('g',{visibility:'hidden'});
  matrix.append(rocPath, rocPoints);
  samplesOld = mk('g',{}); samplesNew = mk('g',{}); matrix.append(samplesOld, samplesNew);

  // ---------- AUC + Helpers ----------
  let cumY=0,cumR=0,cumO=0;
  function resetSamples(){ cumY=cumR=cumO=0; samplesOld.innerHTML=''; samplesNew.innerHTML=''; }
  function calcMatrixAUC(){
    const rects=cellLayer.querySelectorAll('rect');
    let y=0,o=0,r=0; rects.forEach(c=>{const f=c.getAttribute('fill'); if(f==='#ffff66')y++; else if(f==='#ff3333')r++; else if(f==='#ff9900')o++;});
    const tot=y+o+r; return tot>0?(y+0.5*o)/tot:null;
  }
  function updateAUCDisplay(){
    const tot=cumY+cumO+cumR; if(tot>0){ const auc=(cumY+0.5*cumO)/tot; const calc=calcMatrixAUC(); aucDisplay.textContent=`AUC (calc): ${calc?.toFixed(3)||'—'} | AUC (sample): ${auc.toFixed(3)} (${tot} pts)`; }
  }
  function inProperOrder(){
    const ps=posAnch.map(a=>a.occupied?a.occupied.score:null); const ns=negAnch.map(a=>a.occupied?a.occupied.score:null);
    if(ps.some(v=>v===null)||ns.some(v=>v===null)) return false;
    for(let i=1;i<ps.length;i++){ if(ps[i]>ps[i-1]) return false; }
    for(let i=1;i<ns.length;i++){ if(ns[i]>ns[i-1]) return false; }
    return true;
  }
  function drawROC(){
      /*
      drawROC()

      This function constructs and renders a Receiver Operating Characteristic (ROC) curve
      based on the cases currently arranged in the matrix. It follows standard ROC
      computation practice:

      1. All cases (positives and negatives) are grouped by their score values.
        For each unique score threshold (sorted from highest to lowest),
        we compute how many positives (TP) and negatives (FP) would be "activated"
        as the decision threshold moves downward through that score.

      2. The ROC curve is then traced by incrementally accumulating:
          - True Positive Rate (TPR) = cumulative positives / total positives
          - False Positive Rate (FPR) = cumulative negatives / total negatives
        These are the usual normalized ROC axes (ranging 0–1). However, in this
        visualization, the curve is *scaled* to match the matrix grid dimensions:
          - The x-axis extends from 0 to the number of negative cases (Nₙ)
          - The y-axis extends from 0 to the number of positive cases (Nₚ)
        so that one grid cell corresponds to one pairwise comparison between
        a positive and a negative case.

      3. When both positives and negatives share the same score (a tie), both
        TPR and FPR increase together. This produces a single *diagonal* segment
        spanning the full tied block (the orange rectangle in the matrix).

      4. When only negatives occur at a given score, the ROC curve moves
        *horizontally* (increasing FPR only, crossing red cells).
        When only positives occur, it moves *vertically* (increasing TPR only,
        crossing yellow cells).

      The result is a stepwise ROC curve that follows the red–yellow boundary,
      with diagonal transitions precisely where tied scores occur across classes.
    */
    // Only show ROC when all anchors are filled and in proper sorted order
    if (!inProperOrder()){
      rocPath.setAttribute('visibility','hidden');
      rocPoints.setAttribute('visibility','hidden');
      return;
    }

    // Collect scores from anchors
    const posScores = posAnch.map(a => a.occupied.score);
    const negScores = negAnch.map(a => a.occupied.score);
    const Np = posScores.length, Nn = negScores.length;

    // Group counts by score across BOTH classes
    const byScore = new Map();  // score -> {pos:count, neg:count}
    for (const s of posScores){
      const o = byScore.get(s) || {pos:0,neg:0}; o.pos++; byScore.set(s,o);
    }
    for (const s of negScores){
      const o = byScore.get(s) || {pos:0,neg:0}; o.neg++; byScore.set(s,o);
    }

    // Sort scores descending (threshold moves from +inf down to -inf)
    const groups = [...byScore.entries()]
      .sort((a,b) => Number(b[0]) - Number(a[0]))
      .map(([score, cnt]) => ({ score: Number(score), pos: cnt.pos|0, neg: cnt.neg|0 }));

    // Build ROC in rate space, then scale to matrix counts (x in [0..nNeg], y in [0..nPos])
    let tpr = 0, fpr = 0;
    const roc = [[0,0]]; // start at (0,0)
    for (const g of groups){
      // Moving the threshold past this score turns ON all cases at this score
      // If only negatives: horizontal step; only positives: vertical step
      // If both: diagonal step of the correct size
      fpr += g.neg / Nn;
      tpr += g.pos / Np;
      roc.push([fpr * Nn, tpr * Np]);  // scale to grid counts
    }
    // Ensure we end exactly at (Nn, Np)
    if (roc[roc.length-1][0] !== Nn || roc[roc.length-1][1] !== Np){
      roc.push([Nn, Np]);
    }

    // Project to SVG coordinates
    const toXY = ([gx, gy]) => [ margin + gx * cellW, margin + (nPos - gy) * cellH ];
    const svgPts = roc.map(toXY);

    // Render path
    rocPath.setAttribute('d', svgPts.map((p,i) => i ? `L${p[0]},${p[1]}` : `M${p[0]},${p[1]}`).join(' '));
    rocPath.setAttribute('visibility','visible');

    // Render markers
    rocPoints.innerHTML = '';
    svgPts.forEach(p => {
      rocPoints.appendChild(mk('circle', { cx:p[0], cy:p[1], r:6, fill:'#0077ff', stroke:'#000', 'stroke-width':1 }));
    });
    rocPoints.setAttribute('visibility','visible');

    // Keep layers on top
    matrix.append(rocPath, rocPoints);
  }

  function updateColors(){
    cellLayer.innerHTML=''; rocPath.setAttribute('visibility','hidden'); rocPoints.setAttribute('visibility','hidden');
    let filled=0;
    for(let r=0;r<nPos;r++){
      const p=posAnch[r].occupied; if(!p) continue;
      for(let c=0;c<nNeg;c++){
        const ng=negAnch[c].occupied; if(!ng) continue;
        filled++;
        let fill='#ff9900'; if(p.score>ng.score) fill='#ffff66'; else if(p.score<ng.score) fill='#ff3333';
        cellLayer.appendChild(mk('rect',{x:margin+c*cellW,y:margin+(nPos-r-1)*cellH,width:cellW,height:cellH,fill,stroke:'#ccc'}));
      }
    }
    if(filled===nPos*nNeg){
      controls.style.display='block'; const auc=calcMatrixAUC();
      aucDisplay.textContent=`AUC (calc): ${auc.toFixed(3)} | AUC (sample): — (0 pts)`; drawROC();
    } else {
      controls.style.display='none'; aucDisplay.textContent=STRINGS.aucEstimate; resetSamples();
    }
  }

  // ---------- Drag & Drop ----------
  let drag=null, dragOffset={x:0,y:0};
  document.addEventListener('mousedown', (e)=>{
    const n=nodes.find(n=>n.shape===e.target); if(!n) return;
    drag=n;
    const shapeBox=n.shape.getBoundingClientRect();
    dragOffset.x = shapeBox.left + shapeBox.width/2 - e.clientX;
    dragOffset.y = shapeBox.top + shapeBox.height/2 - e.clientY;
    const screenX = shapeBox.left + shapeBox.width/2;
    const screenY = shapeBox.top + shapeBox.height/2;
    overlay.append(n.shape, n.label); n.currentSVG=overlay;
    const pt=overlay.createSVGPoint(); pt.x=screenX; pt.y=screenY;
    const local=pt.matrixTransform(overlay.getScreenCTM().inverse());
    setC(n, local.x, local.y);
    e.preventDefault();
  });

  document.addEventListener('mousemove', (e)=>{
    if(!drag) return;
    const pt=overlay.createSVGPoint(); pt.x=e.clientX+dragOffset.x; pt.y=e.clientY+dragOffset.y;
    const p=pt.matrixTransform(overlay.getScreenCTM().inverse());
    setC(drag, p.x, p.y);
  });

  document.addEventListener('mouseup', (e)=>{
    if(!drag) return;
    const cx=e.clientX, cy=e.clientY;
    posAnch.forEach(a=>a.occupied===drag&&(a.occupied=null));
    negAnch.forEach(a=>a.occupied===drag&&(a.occupied=null));
    const rectS=scatter.getBoundingClientRect();
    const inScatter = cx>=rectS.left && cx<=rectS.right && cy>=rectS.top && cy<=rectS.bottom;

    const anchors=[...posAnch,...negAnch];
    let best={d:1e9,a:null};
    anchors.forEach(a=>{
      const p=a.svg.createSVGPoint(); p.x=a.x; p.y=a.y;
      const sc=p.matrixTransform(a.svg.getScreenCTM());
      const d=Math.hypot(sc.x-cx, sc.y-cy);
      if(d<best.d) best={d,a};
    });

    const t=best.a, near=best.d<40;
    if(inScatter){
      animateTo(drag, drag.home.svg, drag.home.x, drag.home.y, 800);
    } else if(near && t && ((drag.isPos && t.isPos) || (!drag.isPos && !t.isPos))){
      t.occupied=drag; animateTo(drag, t.svg, t.x, t.y, 800);
    } else {
      animateTo(drag, drag.home.svg, drag.home.x, drag.home.y, 800);
    }
    drag=null;
  });

  function animateTo(n, destSVG, x2, y2, dur=800){
    const startBox=n.shape.getBoundingClientRect();
    const start={x:startBox.left+startBox.width/2, y:startBox.top+startBox.height/2};
    const pt=destSVG.createSVGPoint(); pt.x=x2; pt.y=y2; const dest=pt.matrixTransform(destSVG.getScreenCTM());
    overlay.append(n.shape, n.label);
    const t0=performance.now();
    function step(t){
      const f=Math.min((t-t0)/dur,1);
      const sx=start.x+(dest.x-start.x)*f; const sy=start.y+(dest.y-start.y)*f;
      const p=overlay.createSVGPoint(); p.x=sx; p.y=sy;
      const local=p.matrixTransform(overlay.getScreenCTM().inverse());
      setC(n, local.x, local.y);
      if(f<1) requestAnimationFrame(step);
      else { destSVG.append(n.shape, n.label); setC(n, x2, y2); updateColors(); }
    }
    requestAnimationFrame(step);
  }

  // ---------- Auto-arrange ----------
  autoBtn.onclick = ()=>{
    posAnch.forEach(a=>a.occupied=null); negAnch.forEach(a=>a.occupied=null);
    const posNodes = nodes.filter(n=>n.isPos).sort((a,b)=>b.score-a.score);
    const negNodes = nodes.filter(n=>!n.isPos).sort((a,b)=>b.score-a.score);
    posNodes.forEach((nd,i)=>{ const t=posAnch[i]; t.occupied=nd; animateTo(nd, matrix, t.x, t.y, 800); nd.currentSVG=matrix; });
    negNodes.forEach((nd,i)=>{ const t=negAnch[i]; t.occupied=nd; animateTo(nd, matrix, t.x, t.y, 800); nd.currentSVG=matrix; });
  };

  // ---------- Random Sampling ----------
  randBtn.onclick = ()=>{
    // Grey out any new samples to old
    [...samplesNew?.childNodes||[]].forEach(node=>{ if(node.setAttribute){ node.setAttribute('fill','#777'); node.setAttribute('opacity','0.5'); samplesOld.appendChild(node); } });
    const N=parseInt(sampleSel.value,10);
    for(let i=0;i<N;i++){
      const rx=margin+Math.random()*(cellW*nNeg);
      const ry=margin+Math.random()*(cellH*nPos);
      const col=Math.floor((rx-margin)/cellW);
      const row=nPos-1-Math.floor((ry-margin)/cellH);
      if(col>=0&&col<nNeg&&row>=0&&row<nPos){
        const p=posAnch[row].occupied, ng=negAnch[col].occupied;
        if(p&&ng){ if(p.score>ng.score) cumY++; else if(p.score<ng.score) cumR++; else cumO++; samplesNew.appendChild(mk('circle',{cx:rx,cy:ry,r:2,fill:'#000',opacity:'0.9'})); }
      }
    }
    updateAUCDisplay();
  };

  // Initial
  updateColors();
}

// Dataset switching + initial build
datasetSelect.onchange = (e)=>{ const d=datasets[e.target.value]; buildVisualization(d.scores, d.labels); };
const first = Object.values(datasets)[0];
buildVisualization(first.scores, first.labels);
</script>
</body>
</html>
