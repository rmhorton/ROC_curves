<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Probabilistic View of AUC â€“ Interactive ROC App</title>
<style>
  /* Base layout and typography */
  body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial; margin: 18px; background: #f9fafb; color: #111827; user-select: none; }
  h2 { text-align: center; margin: 0 0 8px; }
  #datasetSelector { text-align: center; }
  #actionsRow { display: grid; grid-template-columns: auto 1fr auto; align-items: flex-start; column-gap: 24px; margin: 16px auto 0; }
  #controlColumn { display: flex; flex-direction: column; align-items: flex-start; gap: 12px; }
  #arrangeBar { display: flex; align-items: center; }
  #arrangeBar button { margin: 0; }
  #sampleControls { display: flex; flex-direction: column; align-items: flex-start; gap: 6px; visibility: hidden; opacity: 0; pointer-events: none; min-width: 0; }
  #sampleControls button { margin: 0; }
  #sampleControls .sample-row { display: flex; align-items: center; gap: 8px; }
  #sampleControls label { white-space: nowrap; }
  #legend-container { display: flex; justify-content: flex-end; align-items: flex-start; justify-self: end; }
  #aucColumn { display: flex; flex-direction: column; justify-content: flex-start; align-items: center; min-width: 0; }
  #aucDisplay { text-align: center; min-height: 36px; width: 100%; white-space: nowrap; }
  #stage { margin: auto; position: relative; }
  /* Ensure overlay is actually on top and visible during drags */
  #dragOverlay { position: absolute; left: 0; top: 0; z-index: 10; pointer-events: none; }
  button, select { padding: 6px 12px; border-radius: 6px; border: 1px solid #9ca3af; cursor: pointer; background: #e5e7eb; margin: 5px; }
  #legend-container svg { display: inline-block; margin-top: 0; }
  text { user-select: none; pointer-events: none; font-size: 12px; fill: #111827; }
  #scatter-container, #matrix-container { border: 1px solid #d1d5db; border-radius: 8px; background: #fff; margin: 10px auto; }
</style>
</head>
<body>
<h2 id="appTitle"></h2>
<div id="datasetSelector">
  <label for="datasetSelect">Select dataset:</label>
  <select id="datasetSelect"></select>
</div>
<div id="stage">
  <div id="scatter-container"><svg id="scatterSVG"></svg></div>
  <div id="matrix-container"><svg id="matrixSVG"></svg></div>
  <svg id="dragOverlay"></svg>
</div>
<div id="actionsRow">
  <div id="controlColumn">
    <div id="arrangeBar"><button id="autoArrange"></button></div>
    <div id="sampleControls">
      <button id="randomSample"></button>
      <div class="sample-row">
        <label for="sampleCount" id="pointsPerClick"></label>
        <select id="sampleCount"><option value="1">1</option><option value="10">10</option><option value="100">100</option></select>
      </div>
    </div>
  </div>
  <div id="aucColumn">
    <div id="aucDisplay"></div>
  </div>
  <div id="legend-container"><svg id="legendSVG" width="560" height="160"></svg></div>
</div>

<script>
// ==================== Localized Strings ====================
const STRINGS = {
  title: "Probabilistic View of AUC",
  autoArrange: "Auto-Arrange Cases",
  randomSample: "Random Sample",
  pointsPerClick: "Points per click:",
  aucCalcLabel: "AUC (calculated)",
  aucSampleLabel: "AUC (sampled)",
  scatterTitle: "Scatterplot of Scores",
  matrixTitle: "Matrix of Case Comparisons",
  scatterXAxis: "Score",
  labelPos: "Positive Cases",
  labelNeg: "Negative Cases",
  legend: [
    { color: '#ffff66', text: 'Positive > Negative (yellow)' },
    { color: '#ff3333', text: 'Positive < Negative (red)' },
    { color: '#ff9900', text: 'Tie (orange)' },
    { color: '#0077ff', text: 'ROC curve (blue)' }
  ],
  legendTitle: "Legend"
};

// ==================== Static Text Injection ====================
(function setStaticText(){
  document.getElementById('appTitle').textContent = STRINGS.title;
  document.getElementById('autoArrange').textContent = STRINGS.autoArrange;
  document.getElementById('randomSample').textContent = STRINGS.randomSample;
  document.getElementById('pointsPerClick').textContent = STRINGS.pointsPerClick;
})();

// ==================== Datasets ====================
const datasets = {
  "Test Set A": { scores: [20,19,18,17,16,15,14,13,11.5,11.5,10,9,8,7,6,5,4,3,2,1], labels: [1,1,1,1,0,1,1,0,1,0,1,0,1,0,0,1,0,0,0,0] },
  "Test Set B": { scores: [20,19,18,17,16,15,14,13,11.5,11.5,9.5,9.5,8,7,6,5,4,3,2,1], labels: [1,1,1,1,1,1,1,0,1,0,1,0,1,0,0,1,0,0,0,0] },
  "Test Set C": { 
    scores: [50,49,48,47,46,45,44,43,42,41,35,35,35,35,35,35,35,35,35,35,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,10,9,8,7,6,5,4,3,2,1], 
    labels: [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0] 
  },
  "Test Set D": { scores: Array.from({length:100},(_,i)=>100-i), labels: Array.from({length:100},(_,i)=> i<40?1:0 ) } // 40 positives, 60 negatives
};

// Populate selector
const datasetSelect = document.getElementById('datasetSelect');
for(const name in datasets){ const opt=document.createElement('option'); opt.value=name; opt.textContent=name; datasetSelect.appendChild(opt); }

// ==================== DOM Handles ====================
const scatter = document.getElementById('scatterSVG');
const matrix  = document.getElementById('matrixSVG');
const overlay = document.getElementById('dragOverlay');
const autoBtn = document.getElementById('autoArrange');
const randBtn = document.getElementById('randomSample');
const sampleSel = document.getElementById('sampleCount');
const aucDisplay = document.getElementById('aucDisplay');
const legend = document.getElementById('legendSVG');
const sampleControls = document.getElementById('sampleControls');

// ==================== Utility Makers ====================
function mk(tag, attrs={}){ const e=document.createElementNS('http://www.w3.org/2000/svg', tag); for(const k in attrs) e.setAttribute(k, attrs[k]); return e; }
function diamondPoints(x,y,r){ return `${x},${y-r} ${x+r},${y} ${x},${y+r} ${x-r},${y}`; }

// ==================== Resizing for Large Datasets ====================
function resizeForDataset(nNeg, nPos){
  const baseW = 900, baseMatrixH = 540, scatterH = 180;
  const diamondW = 24, circleH = 24;
  const extraW = Math.max(0, nNeg - 20);
  const extraH = Math.max(0, nPos - 30);
  const newW = baseW + extraW * diamondW;
  const newMatrixH = baseMatrixH + extraH * circleH;

  // ViewBoxes for proper coordinate transforms
  scatter.setAttribute('viewBox', `0 0 ${newW} ${scatterH}`);
  matrix.setAttribute('viewBox', `0 0 ${newW} ${newMatrixH}`);
  overlay.setAttribute('viewBox', `0 0 ${newW} ${newMatrixH + 300}`);

  // Explicit CSS sizes so SVGs are actually visible and overlay is tall enough for dragging
  scatter.style.width = newW + 'px';
  scatter.style.height = scatterH + 'px';
  matrix.style.width = newW + 'px';
  matrix.style.height = newMatrixH + 'px';
  overlay.style.width = newW + 'px';
  overlay.style.height = (newMatrixH + 300) + 'px';

  // Match container widths so stage, controls, and legend stay aligned
  document.getElementById('stage').style.width = newW + 'px';
  document.getElementById('scatter-container').style.width = newW + 'px';
  document.getElementById('matrix-container').style.width = newW + 'px';
  document.getElementById('actionsRow').style.width = newW + 'px';
}

// ==================== Globals (reset each build) ====================
let nodes = [], posAnch = [], negAnch = [];
let cellLayer, rocPath, rocPoints, samplesOld, samplesNew;
let margin = 80, innerW = 0, W = 0, matrixH = 0, scatterHConst = 180;

const vizState = {
  scores: [],
  labels: [],
  nPos: 0,
  nNeg: 0,
  scoreMin: 0,
  scoreMax: 0,
  scaleX: null,
  cellW: 0,
  cellH: 0,
  gridW: 0,
  gridH: 0
};

const COLORS = {
  pos: '#2ca02c',
  neg: '#d62728',
  palePos: '#c7f0c7',
  paleNeg: '#f7b3b3'
};

const SHAPE_R = 10;
const DIAMOND_R = 12;
const SCATTER_TOP = 60;
const SCATTER_BOT = 120;

let cumY = 0, cumR = 0, cumO = 0;
let eventsBound = false;
let drag = null;
let dragOffset = { x: 0, y: 0 };

// Helper to place a node's SVG
function setC(n,x,y){
  if(n.isPos){ n.shape.setAttribute('cx',x); n.shape.setAttribute('cy',y); }
  else { n.shape.setAttribute('points', diamondPoints(x,y,12)); }
  n.label.setAttribute('x',x); n.label.setAttribute('y',y);
}

// ==================== Builder ====================

function buildVisualization(scores, labels){
  vizState.scores = scores;
  vizState.labels = labels;
  vizState.nPos = labels.filter(x => x === 1).length;
  vizState.nNeg = labels.filter(x => x === 0).length;

  resizeForDataset(vizState.nNeg, vizState.nPos);

  scatter.innerHTML = '';
  matrix.innerHTML = '';
  overlay.innerHTML = '';
  legend.innerHTML = '';

  W = parseFloat(scatter.getAttribute('viewBox').split(' ')[2]);
  matrixH = parseFloat(matrix.getAttribute('viewBox').split(' ')[3]);
  scatterHConst = parseFloat(scatter.getAttribute('viewBox').split(' ')[3]);
  margin = 80;
  innerW = W - 2 * margin;

  vizState.scoreMin = Math.min(...scores);
  vizState.scoreMax = Math.max(...scores);
  const domain = (vizState.scoreMax - vizState.scoreMin) || 1;
  vizState.scaleX = (s) => margin + ((s - vizState.scoreMin) / domain) * (innerW - 40);

  nodes = [];
  posAnch = [];
  negAnch = [];
  drag = null;

  drawScatter();
  drawMatrix();
  drawLegend();
  resetSamples();
  bindEvents();
  updateColors();
}

// Render the scatter plot anchors and draggable nodes; populates global `nodes` using scores/labels from `vizState`.
function drawScatter(){
  const { scores, labels, scaleX, scoreMin, scoreMax } = vizState;
  const scatterTop = SCATTER_TOP;
  const scatterBot = SCATTER_BOT;

  scatter.appendChild(mk('text', { x: W / 2, y: 20, 'text-anchor': 'middle', 'font-weight': '600' })).textContent = STRINGS.scatterTitle;
  scatter.appendChild(mk('text', { x: W / 2, y: scatterHConst - 5, 'text-anchor': 'middle', 'font-weight': '500' })).textContent = STRINGS.scatterXAxis;

  const numTicks = 5;
  const range = scoreMax - scoreMin;
  for (let i = 0; i <= numTicks; i++){
    const val = scoreMin + range * (i / numTicks);
    const x = scaleX(val);
    scatter.appendChild(mk('line', { x1: x, y1: scatterHConst - 20, x2: x, y2: scatterHConst - 10, stroke: '#555' }));
    scatter.appendChild(mk('text', { x, y: scatterHConst - 25, 'text-anchor': 'middle' })).textContent = val.toFixed(1);
  }

  scatter.appendChild(mk('text', { x: margin, y: scatterTop - 20, 'text-anchor': 'start', 'font-weight': '500' })).textContent = STRINGS.labelPos;
  scatter.appendChild(mk('text', { x: margin, y: scatterBot + 25, 'text-anchor': 'start', 'font-weight': '500' })).textContent = STRINGS.labelNeg;

  const posGroups = {}, negGroups = {};
  scores.forEach((s, i) => {
    if (labels[i]){
      if (!posGroups[s]) posGroups[s] = [];
      posGroups[s].push(i);
    } else {
      if (!negGroups[s]) negGroups[s] = [];
      negGroups[s].push(i);
    }
  });

  for (let i = 0; i < scores.length; i++){
    const score = scores[i];
    const isPos = !!labels[i];
    const x = scaleX(score);
    const baseY = isPos ? scatterTop : scatterBot;
    const group = isPos ? posGroups[score] : negGroups[score];
    let offset = 0;
    if (group && group.length > 1){
      const idx = group.indexOf(i);
      const spacing = 4;
      const center = (group.length - 1) / 2;
      offset = (idx - center) * spacing;
    }
    const y = baseY + offset;

    const anchor = isPos
      ? mk('circle', { cx: x, cy: y, r: SHAPE_R, fill: 'none', stroke: COLORS.palePos, 'stroke-width': '4', 'stroke-dasharray': '2 2' })
      : mk('polygon', { points: diamondPoints(x, y, DIAMOND_R), fill: 'none', stroke: COLORS.paleNeg, 'stroke-width': '4', 'stroke-dasharray': '2 2' });
    scatter.appendChild(anchor);

    const shape = isPos
      ? mk('circle', { cx: x, cy: y, r: SHAPE_R, fill: COLORS.pos, stroke: '#222' })
      : mk('polygon', { points: diamondPoints(x, y, DIAMOND_R), fill: COLORS.neg, stroke: '#222' });
    const lbl = mk('text', { x, y, 'text-anchor': 'middle', 'dominant-baseline': 'central', 'font-size': '11', fill: '#fff' });
    lbl.textContent = score;
    scatter.append(shape, lbl);

    nodes.push({ isPos, score, shape, label: lbl, anchor, home: { x, y, svg: scatter }, currentSVG: scatter });
  }
}

// Lay out the comparison matrix, initialize anchor arrays, and allocate shared layers recorded in globals.
function drawMatrix(){
  const { nPos, nNeg } = vizState;
  const gridW = innerW - 32;
  const gridH = matrixH - 120;

  vizState.gridW = gridW;
  vizState.gridH = gridH;
  vizState.cellW = nNeg ? gridW / nNeg : 0;
  vizState.cellH = nPos ? gridH / nPos : 0;

  const cellW = vizState.cellW;
  const cellH = vizState.cellH;

  const matrixTitle = mk('text', {
    x: W / 2,
    y: 30,
    'text-anchor': 'middle',
    'font-weight': '600',
    'font-size': '16'
  });
  matrixTitle.textContent = STRINGS.matrixTitle;
  matrix.appendChild(matrixTitle);

  for (let r = 0; r < nPos; r++){
    const y = margin + (nPos - r - 0.5) * cellH;
    const x = margin + gridW + 28;
    matrix.appendChild(mk('circle', { cx: x, cy: y, r: SHAPE_R, fill: 'none', stroke: COLORS.palePos, 'stroke-width': '4', 'stroke-dasharray': '2 2' }));
    posAnch.push({ x, y, svg: matrix, occupied: null, isPos: true });
  }
  for (let c = 0; c < nNeg; c++){
    const x = margin + (c + 0.5) * cellW;
    const y = margin - 30;
    matrix.appendChild(mk('polygon', { points: diamondPoints(x, y, DIAMOND_R), fill: 'none', stroke: COLORS.paleNeg, 'stroke-width': '4', 'stroke-dasharray': '2 2' }));
    negAnch.push({ x, y, svg: matrix, occupied: null, isPos: false });
  }

  for (let r = 0; r < nPos; r++){
    for (let c = 0; c < nNeg; c++){
      matrix.appendChild(mk('rect', { x: margin + c * cellW, y: margin + (nPos - r - 1) * cellH, width: cellW, height: cellH, fill: '#fff', stroke: '#e5e7eb' }));
    }
  }

  for (let c = 0; c < nNeg; c++){
    const x = margin + (c + 0.5) * cellW;
    matrix.appendChild(mk('text', { x, y: matrixH - 20, 'text-anchor': 'middle' })).textContent = c + 1;
  }
  for (let r = 0; r < nPos; r++){
    const y = margin + (nPos - r - 0.5) * cellH;
    matrix.appendChild(mk('text', { x: margin - 20, y, 'text-anchor': 'end' })).textContent = r + 1;
  }

  matrix.appendChild(mk('text', { x: margin - 40, y: matrixH / 2, 'text-anchor': 'middle', 'dominant-baseline': 'middle', transform: `rotate(-90, ${margin - 40}, ${matrixH / 2})`, 'font-weight': '600', 'font-size': '14' })).textContent = STRINGS.labelPos;
  matrix.appendChild(mk('text', { x: margin + gridW / 2, y: matrixH - 5, 'text-anchor': 'middle', 'font-weight': '500' })).textContent = STRINGS.labelNeg;

  cellLayer = mk('g', {});
  matrix.appendChild(cellLayer);
  rocPath = mk('path', { stroke: '#0077ff', 'stroke-width': '5', fill: 'none', visibility: 'hidden' });
  rocPoints = mk('g', { visibility: 'hidden' });
  matrix.append(rocPath, rocPoints);
  samplesOld = mk('g', {});
  samplesNew = mk('g', {});
  matrix.append(samplesOld, samplesNew);
}

// Populate the static legend using `STRINGS.legend`; only touches the legend SVG.
function drawLegend(){
  const content = mk('g', {});
  legend.appendChild(content);

  const title = mk('text', { x: 20, y: 18, 'font-weight': '600' });
  title.textContent = STRINGS.legendTitle;
  content.appendChild(title);

  STRINGS.legend.forEach((entry, i) => {
    const y = 36 + i * 26;
    content.appendChild(mk('rect', { x: 20, y, width: 14, height: 14, fill: entry.color, stroke: '#111' }));
    content.appendChild(mk('text', { x: 40, y: y + 11 })).textContent = entry.text;
  });

  const bbox = content.getBBox();
  const pad = 12;
  const newWidth = Math.ceil(bbox.x + bbox.width + pad);
  const newHeight = Math.ceil(bbox.y + bbox.height + pad);
  if (newWidth > 0){
    legend.setAttribute('width', newWidth);
  }
  if (newHeight > 0){
    legend.setAttribute('height', newHeight);
  }
  legend.setAttribute('viewBox', `0 0 ${Math.max(newWidth, 1)} ${Math.max(newHeight, 1)}`);
}

// Attach UI handlers once (guarded by `eventsBound`), wiring buttons, sampling, and drag/drop behaviors across globals.
function bindEvents(){
  autoBtn.onclick = () => {
    posAnch.forEach(a => a.occupied = null);
    negAnch.forEach(a => a.occupied = null);
    const posNodes = nodes.filter(n => n.isPos).sort((a, b) => b.score - a.score);
    const negNodes = nodes.filter(n => !n.isPos).sort((a, b) => b.score - a.score);
    posNodes.forEach((nd, i) => {
      const target = posAnch[i];
      if (!target) return;
      target.occupied = nd;
      animateTo(nd, matrix, target.x, target.y, 800);
      nd.currentSVG = matrix;
    });
    negNodes.forEach((nd, i) => {
      const target = negAnch[i];
      if (!target) return;
      target.occupied = nd;
      animateTo(nd, matrix, target.x, target.y, 800);
      nd.currentSVG = matrix;
    });
  };

  randBtn.onclick = () => {
    const { cellW, cellH, nNeg, nPos } = vizState;
    if (!cellW || !cellH) return;

    [...(samplesNew?.childNodes || [])].forEach(node => {
      if (node.setAttribute){
        node.setAttribute('fill', '#777');
        node.setAttribute('opacity', '0.5');
        samplesOld.appendChild(node);
      }
    });

    const N = parseInt(sampleSel.value, 10);
    for (let i = 0; i < N; i++){
      const rx = margin + Math.random() * (cellW * nNeg);
      const ry = margin + Math.random() * (cellH * nPos);
      const col = Math.floor((rx - margin) / cellW);
      const row = nPos - 1 - Math.floor((ry - margin) / cellH);
      if (col >= 0 && col < nNeg && row >= 0 && row < nPos){
        const p = posAnch[row].occupied;
        const ng = negAnch[col].occupied;
        if (p && ng){
          if (p.score > ng.score) cumY++;
          else if (p.score < ng.score) cumR++;
          else cumO++;
          samplesNew.appendChild(mk('circle', { cx: rx, cy: ry, r: 2, fill: '#000', opacity: '0.9' }));
        }
      }
    }
    updateAUCDisplay();
  };

  if (eventsBound) return;
  eventsBound = true;

  document.addEventListener('mousedown', (e) => {
    const node = nodes.find(n => n.shape === e.target);
    if (!node) return;
    drag = node;
    const shapeBox = node.shape.getBoundingClientRect();
    dragOffset.x = shapeBox.left + shapeBox.width / 2 - e.clientX;
    dragOffset.y = shapeBox.top + shapeBox.height / 2 - e.clientY;
    const screenX = shapeBox.left + shapeBox.width / 2;
    const screenY = shapeBox.top + shapeBox.height / 2;
    overlay.append(node.shape, node.label);
    node.currentSVG = overlay;
    const pt = overlay.createSVGPoint();
    pt.x = screenX;
    pt.y = screenY;
    const local = pt.matrixTransform(overlay.getScreenCTM().inverse());
    setC(node, local.x, local.y);
    e.preventDefault();
  });

  document.addEventListener('mousemove', (e) => {
    if (!drag) return;
    const pt = overlay.createSVGPoint();
    pt.x = e.clientX + dragOffset.x;
    pt.y = e.clientY + dragOffset.y;
    const local = pt.matrixTransform(overlay.getScreenCTM().inverse());
    setC(drag, local.x, local.y);
  });

  document.addEventListener('mouseup', (e) => {
    if (!drag) return;
    const cx = e.clientX;
    const cy = e.clientY;
    posAnch.forEach(a => { if (a.occupied === drag) a.occupied = null; });
    negAnch.forEach(a => { if (a.occupied === drag) a.occupied = null; });

    const rectS = scatter.getBoundingClientRect();
    const inScatter = cx >= rectS.left && cx <= rectS.right && cy >= rectS.top && cy <= rectS.bottom;

    const anchors = [...posAnch, ...negAnch];
    let best = { d: 1e9, a: null };
    anchors.forEach(a => {
      const p = a.svg.createSVGPoint();
      p.x = a.x;
      p.y = a.y;
      const sc = p.matrixTransform(a.svg.getScreenCTM());
      const d = Math.hypot(sc.x - cx, sc.y - cy);
      if (d < best.d) best = { d, a };
    });

    const target = best.a;
    const near = best.d < 40;
    if (inScatter){
      animateTo(drag, drag.home.svg, drag.home.x, drag.home.y, 800);
    } else if (near && target && ((drag.isPos && target.isPos) || (!drag.isPos && !target.isPos))){
      target.occupied = drag;
      animateTo(drag, target.svg, target.x, target.y, 800);
    } else {
      animateTo(drag, drag.home.svg, drag.home.x, drag.home.y, 800);
    }
    drag = null;
  });
}

// Clear sampling state counters and associated SVG groups; resets globals `cumY`, `cumR`, `cumO`, `samplesOld`, `samplesNew`.
function resetSamples(){
  cumY = 0;
  cumR = 0;
  cumO = 0;
  if (samplesOld) samplesOld.innerHTML = '';
  if (samplesNew) samplesNew.innerHTML = '';
}

// Derive the deterministic matrix AUC from the colored cell layer; reads `cellLayer`.
function calcMatrixAUC(){
  if (!cellLayer) return null;
  const rects = cellLayer.querySelectorAll('rect');
  let y = 0, o = 0, r = 0;
  rects.forEach(c => {
    const fill = c.getAttribute('fill');
    if (fill === '#ffff66') y++;
    else if (fill === '#ff3333') r++;
    else if (fill === '#ff9900') o++;
  });
  const tot = y + o + r;
  return tot > 0 ? (y + 0.5 * o) / tot : null;
}

// Refresh the on-screen AUC summary using sampling tallies and matrix calculation helpers.
function updateAUCDisplay(){
  const total = cumY + cumO + cumR;
  if (total > 0){
    const aucSample = (cumY + 0.5 * cumO) / total;
    const calc = calcMatrixAUC();
    const calcLabel = STRINGS.aucCalcLabel;
    const sampleLabel = STRINGS.aucSampleLabel;
    aucDisplay.innerHTML = `${calcLabel}: ${calc?.toFixed(3) || 'â€”'}<br>${sampleLabel}: ${aucSample.toFixed(3)} (${total} pts)`;
  }
}

// Verify that all anchors are filled and ordered monotonically by score; inspects `posAnch` and `negAnch`.
function inProperOrder(){
  const ps = posAnch.map(a => a.occupied ? a.occupied.score : null);
  const ns = negAnch.map(a => a.occupied ? a.occupied.score : null);
  if (ps.some(v => v === null) || ns.some(v => v === null)) return false;
  for (let i = 1; i < ps.length; i++) if (ps[i] > ps[i - 1]) return false;
  for (let i = 1; i < ns.length; i++) if (ns[i] > ns[i - 1]) return false;
  return true;
}

// Compute ROC metrics grouped by score thresholds for reuse across visualizations.
function computeROC(scores, labels){
  if (!Array.isArray(scores) || !Array.isArray(labels) || scores.length !== labels.length) return [];

  const byScore = new Map();
  let totalPos = 0;
  let totalNeg = 0;

  for (let i = 0; i < scores.length; i++){
    const threshold = Number(scores[i]);
    const label = labels[i] === 1 ? 1 : 0;
    const entry = byScore.get(threshold) || { threshold, pos: 0, neg: 0 };
    if (label === 1){
      entry.pos++;
      totalPos++;
    } else {
      entry.neg++;
      totalNeg++;
    }
    byScore.set(threshold, entry);
  }

  const sorted = [...byScore.values()].sort((a, b) => b.threshold - a.threshold);
  let cumPos = 0;
  let cumNeg = 0;

  return sorted.map(group => {
    cumPos += group.pos;
    cumNeg += group.neg;
    const fpr = totalNeg ? cumNeg / totalNeg : 0;
    const tpr = totalPos ? cumPos / totalPos : 0;
    return {
      threshold: group.threshold,
      fpr,
      tpr,
      fpCount: cumNeg,
      tpCount: cumPos
    };
  });
}

/*
  drawROC()

  Constructs and renders the ROC curve based on the current matrix arrangement.
  The positives and negatives seated in the anchors are grouped by score so that
  ties produce diagonal segments. The curve is scaled to the matrix grid (in
  counts, not rates) to match the pairwise comparison grid the user sees.
*/
function drawROC(){
  const { nPos, nNeg, cellW, cellH } = vizState;
  if (!cellW || !cellH){
    rocPath.setAttribute('visibility', 'hidden');
    rocPoints.setAttribute('visibility', 'hidden');
    return;
  }

  if (!inProperOrder()){
    rocPath.setAttribute('visibility', 'hidden');
    rocPoints.setAttribute('visibility', 'hidden');
    return;
  }

  const scores = [];
  const labels = [];
  posAnch.forEach(a => { if (a.occupied){ scores.push(a.occupied.score); labels.push(1); } });
  negAnch.forEach(a => { if (a.occupied){ scores.push(a.occupied.score); labels.push(0); } });

  const rocData = computeROC(scores, labels);
  if (!rocData.length){
    rocPath.setAttribute('visibility', 'hidden');
    rocPoints.setAttribute('visibility', 'hidden');
    return;
  }

  const roc = [[0, 0], ...rocData.map(d => [d.fpCount, d.tpCount])];
  const last = roc[roc.length - 1];
  if (last && (last[0] !== nNeg || last[1] !== nPos)){
    roc.push([nNeg, nPos]);
  }

  const toXY = ([gx, gy]) => [margin + gx * cellW, margin + (nPos - gy) * cellH];
  const svgPts = roc.map(toXY);

  rocPath.setAttribute('d', svgPts.map((p, i) => (i ? `L${p[0]},${p[1]}` : `M${p[0]},${p[1]}`)).join(' '));
  rocPath.setAttribute('visibility', 'visible');

  rocPoints.innerHTML = '';
  svgPts.forEach(p => {
    rocPoints.appendChild(mk('circle', { cx: p[0], cy: p[1], r: 6, fill: '#0077ff', stroke: '#000', 'stroke-width': 1 }));
  });
  rocPoints.setAttribute('visibility', 'visible');
  matrix.append(rocPath, rocPoints);
}

// Recompute matrix cell colors, toggle control visibility, and optionally draw the ROC curve; leverages multiple globals.
function updateColors(){
  const { nPos, nNeg, cellW, cellH } = vizState;
  if (!cellW || !cellH){
    if (cellLayer) cellLayer.innerHTML = '';
    sampleControls.style.visibility = 'hidden';
    sampleControls.style.opacity = '0';
    sampleControls.style.pointerEvents = 'none';
    aucDisplay.innerHTML = '';
    resetSamples();
    return;
  }

  cellLayer.innerHTML = '';
  rocPath.setAttribute('visibility', 'hidden');
  rocPoints.setAttribute('visibility', 'hidden');
  let filled = 0;
  for (let r = 0; r < nPos; r++){
    const p = posAnch[r].occupied;
    if (!p) continue;
    for (let c = 0; c < nNeg; c++){
      const ng = negAnch[c].occupied;
      if (!ng) continue;
      filled++;
      let fill = '#ff9900';
      if (p.score > ng.score) fill = '#ffff66';
      else if (p.score < ng.score) fill = '#ff3333';
      cellLayer.appendChild(mk('rect', { x: margin + c * cellW, y: margin + (nPos - r - 1) * cellH, width: cellW, height: cellH, fill, stroke: '#ccc' }));
    }
  }

  if (filled === nPos * nNeg && nPos && nNeg){
    sampleControls.style.visibility = 'visible';
    sampleControls.style.opacity = '1';
    sampleControls.style.pointerEvents = 'auto';
    const auc = calcMatrixAUC();
    const calcLabel = STRINGS.aucCalcLabel;
    const sampleLabel = STRINGS.aucSampleLabel;
    aucDisplay.innerHTML = `${calcLabel}: ${auc?.toFixed(3) || 'â€”'}<br>${sampleLabel}: â€” (0 pts)`;
    drawROC();
  } else {
    sampleControls.style.visibility = 'hidden';
    sampleControls.style.opacity = '0';
    sampleControls.style.pointerEvents = 'none';
    aucDisplay.innerHTML = '';
    resetSamples();
  }
}

// Smoothly move a node between SVGs; drives `updateColors` after positioning to keep visuals in sync.
function animateTo(node, destSVG, x2, y2, dur = 800){
  const startBox = node.shape.getBoundingClientRect();
  const start = { x: startBox.left + startBox.width / 2, y: startBox.top + startBox.height / 2 };
  const pt = destSVG.createSVGPoint();
  pt.x = x2;
  pt.y = y2;
  const dest = pt.matrixTransform(destSVG.getScreenCTM());
  overlay.append(node.shape, node.label);
  const t0 = performance.now();
  function step(t){
    const f = Math.min((t - t0) / dur, 1);
    const sx = start.x + (dest.x - start.x) * f;
    const sy = start.y + (dest.y - start.y) * f;
    const p = overlay.createSVGPoint();
    p.x = sx;
    p.y = sy;
    const local = p.matrixTransform(overlay.getScreenCTM().inverse());
    setC(node, local.x, local.y);
    if (f < 1){
      requestAnimationFrame(step);
    } else {
      destSVG.append(node.shape, node.label);
      setC(node, x2, y2);
      updateColors();
    }
  }
  requestAnimationFrame(step);
}

// Dataset switching + initial build
datasetSelect.onchange = (e)=>{ const d=datasets[e.target.value]; buildVisualization(d.scores, d.labels); };
const first = Object.values(datasets)[0];
buildVisualization(first.scores, first.labels);
</script>
</body>
</html>
