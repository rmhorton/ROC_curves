<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Probabilistic ROC Sampling — Final Single-File Live App</title>
<style>
  :root { --w: 720px; --h: 480px; }
  body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial; margin: 18px; }
  h2 { margin: 0 0 8px; }
  #stage { position: relative; width: var(--w); height: var(--h); border: 1px solid #ddd; background: #fff; }
  #legend { margin-top: 10px; font-size: 13px; }
  .legend-row { display: flex; align-items: center; gap: 8px; margin: 2px 0; }
  .swatch-square { width: 16px; height: 16px; border: 1px solid #333; }
  .swatch-circle { width: 16px; height: 16px; border-radius: 50%; border: 1px solid #333; }
  button { margin-top: 8px; font-size: 13px; cursor: pointer; color: #0366d6; }
  svg { display: block; }
  #randomBtn { display: none; }
  #aucSample { display: none; }
  #rocReady { display: none; color: green; font-weight: bold; margin-top: 6px; }
</style>
</head>
<body>
<h2>Probabilistic ROC Sampling — Live Update</h2>
<div id="stage"><svg id="svg" width="100%" height="100%" viewBox="0 0 720 480"></svg></div>

<div id="legend">
  <h3>Legend</h3>
  <div class="legend-row"><div class="swatch-square" style="background:lightyellow"></div>positive score &gt; negative score</div>
  <div class="legend-row"><div class="swatch-square" style="background:orange"></div>tie (scores equal)</div>
  <div class="legend-row"><div class="swatch-square" style="background:red"></div>negative score &gt; positive score</div>
  <div class="legend-row"><div class="swatch-circle" style="background:#2ca02c"></div>Positive case (circle)</div>
  <div class="legend-row"><div class="swatch-circle" style="background:#d62728; clip-path: polygon(50% 0,100% 50%,50% 100%,0 50%)"></div>Negative case (diamond)</div>
  <div id="aucDisplay" style="margin-top:8px;font-weight:bold;">AUC calculation: 0 / 0 = 0</div>
  <div id="aucSample" style="margin-top:4px;font-weight:bold;">AUC from sampling: 0 / 0 = 0</div>
  <div id="rocReady">✅ ROC Ready</div>
  <button id="randomBtn">Random Sample</button>
</div>

<script>
(function(){
  const svg=document.getElementById('svg');
  const W=svg.viewBox.baseVal.width,H=svg.viewBox.baseVal.height;
  const margin=60,strokeW=2;const innerW=W-2*margin,innerH=H-2*margin;
  const circleR=16,diamondSize=44,posColor='#2ca02c',negColor='#d62728';
  const labelsRaw=[1,1,1,1,0,1,1,0,1,0,1,0,1,0,0,1,0,0,0,0];
  const scoresRaw=[20,19,18,17,16,15,14,13,11.5,11.5,10,9,8,7,6,5,4,3,2,1];
  const order=scoresRaw.map((s,i)=>[s,i]).sort((a,b)=>b[0]-a[0]).map(x=>x[1]);
  const labels=order.map(i=>!!labelsRaw[i]);const scores=order.map(i=>scoresRaw[i]);
  const posIdx=[],negIdx=[];for(let i=0;i<labels.length;i++)(labels[i]?posIdx:negIdx).push(i);
  const n_pos=posIdx.length,n_neg=negIdx.length;
  const cellW=innerW/n_neg,cellH=innerH/n_pos;

  const gGrid=mk('g'),gCells=mk('g'),gAnchors=mk('g'),gPts=mk('g'),gROC=mk('g'),gSamples=mk('g');
  svg.append(gGrid,gCells,gAnchors,gPts,gROC,gSamples);

  const aucDisplay=document.getElementById('aucDisplay');
  const aucSample=document.getElementById('aucSample');
  const randomBtn=document.getElementById('randomBtn');
  const rocReady=document.getElementById('rocReady');

  function mk(t,a={}){const e=document.createElementNS('http://www.w3.org/2000/svg',t);for(const k in a)e.setAttribute(k,a[k]);return e;}
  function diamondPoints(cx,cy,s){return `${cx},${cy-s} ${cx+s},${cy} ${cx},${cy+s} ${cx-s},${cy}`;}
  function getCircleCenter(e){return[+e.getAttribute('cx'),+e.getAttribute('cy')];}
  function getDiamondCenter(e){const pts=e.getAttribute('points').split(' ')[0].split(',');const cx=+pts[0],yTop=+pts[1];return[cx,yTop+diamondSize/2];}
  function setCenter(n,x,y){if(n.isPos){n.shape.setAttribute('cx',x);n.shape.setAttribute('cy',y);}else{n.shape.setAttribute('points',diamondPoints(x,y,diamondSize/2));}n.label.setAttribute('x',x);n.label.setAttribute('y',y);}

  gGrid.appendChild(mk('rect',{x:margin,y:margin,width:innerW,height:innerH,fill:'none',stroke:'#888','stroke-width':1}));
  for(let c=0;c<=n_neg;c++)gGrid.appendChild(mk('line',{x1:margin+c*cellW,y1:margin,x2:margin+c*cellW,y2:margin+innerH,stroke:'#eee'}));
  for(let r=0;r<=n_pos;r++)gGrid.appendChild(mk('line',{x1:margin,y1:margin+r*cellH,x2:margin+innerW,y2:margin+r*cellH,stroke:'#eee'}));

  const posAnchors=Array.from({length:n_pos},(_,r)=>[margin-30,margin+innerH-cellH*(r+0.5)]);
  const negAnchors=Array.from({length:n_neg},(_,c)=>[margin+cellW*(c+0.5),margin+innerH+30]);
  const posTaken=Array(n_pos).fill(null);const negTaken=Array(n_neg).fill(null);

  posAnchors.forEach(([x,y])=>gAnchors.appendChild(mk('circle',{cx:x,cy:y,r:12,fill:'none',stroke:'#ccc','stroke-dasharray':'2 2'})));
  negAnchors.forEach(([x,y])=>gAnchors.appendChild(mk('polygon',{points:diamondPoints(x,y,12),fill:'none',stroke:'#ccc','stroke-dasharray':'2 2'})));

  const nodes=[];const cx0=W/2,cy0=H/2,jitter=60;
  for(let i=0;i<labels.length;i++){
    const isPos=labels[i];const x=cx0+(Math.random()*2-1)*jitter;const y=cy0+(Math.random()*2-1)*jitter;const g=mk('g');
    if(isPos){const shape=mk('circle',{cx:x,cy:y,r:16,fill:posColor,stroke:'#222'});const label=mk('text',{x,y,'text-anchor':'middle','dominant-baseline':'central','font-size':'13',fill:'white'});label.textContent=scores[i];g.append(shape,label);gPts.append(g);nodes.push({id:i,isPos:true,shape,label,score:scores[i],anchorIndex:null});}
    else{const shape=mk('polygon',{points:diamondPoints(x,y,diamondSize/2),fill:negColor,stroke:'#222'});const label=mk('text',{x,y,'text-anchor':'middle','dominant-baseline':'central','font-size':'13',fill:'white'});label.textContent=scores[i];g.append(shape,label);gPts.append(g);nodes.push({id:i,isPos:false,shape,label,score:scores[i],anchorIndex:null});}
  }

  nodes.forEach(n=>{let dragging=false,sx=0,sy=0;n.shape.addEventListener('pointerdown',e=>{dragging=true;n.shape.setPointerCapture(e.pointerId);sx=e.clientX;sy=e.clientY;});n.shape.addEventListener('pointermove',e=>{if(!dragging)return;const dx=e.clientX-sx,dy=e.clientY-sy;sx=e.clientX;sy=e.clientY;const c=n.isPos?getCircleCenter(n.shape):getDiamondCenter(n.shape);setCenter(n,c[0]+dx,c[1]+dy);});n.shape.addEventListener('pointerup',e=>{if(!dragging)return;dragging=false;n.shape.releasePointerCapture(e.pointerId);snapOrSwap(n);});});

  function nearestAnchor(n){const anchors=n.isPos?posAnchors:negAnchors;const[x,y]=n.isPos?getCircleCenter(n.shape):getDiamondCenter(n.shape);let best=-1,bestD=Infinity;for(let i=0;i<anchors.length;i++){const[ax,ay]=anchors[i];const d=(x-ax)**2+(y-ay)**2;if(d<bestD){bestD=d;best=i;}}return{index:best,dist2:bestD};}
  function snapOrSwap(n){const anchors=n.isPos?posAnchors:negAnchors;const taken=n.isPos?posTaken:negTaken;const{index:i,dist2}=nearestAnchor(n);if(i<0||dist2>1600)return;const[ax,ay]=anchors[i];const old=n.anchorIndex;const occ=taken[i];if(occ!=null&&occ!==n.id){const other=nodes[occ];const otherOld=old;if(old!=null){const[ox,oy]=anchors[old];setCenter(other,ox,oy);other.anchorIndex=old;taken[old]=occ;}else{other.anchorIndex=null;}setCenter(n,ax,ay);n.anchorIndex=i;taken[i]=n.id;}else{if(old!=null)taken[old]=null;setCenter(n,ax,ay);n.anchorIndex=i;taken[i]=n.id;}updateAfterChange();}

  function redrawMatrix(){gCells.innerHTML='';let num=0,den=n_pos*n_neg;for(let r=0;r<n_pos;r++){for(let c=0;c<n_neg;c++){const posId=posTaken[r],negId=negTaken[c];if(posId==null||negId==null)continue;const v=(1+Math.sign(nodes[posId].score-nodes[negId].score))/2;const fill=v===1?'lightyellow':v===0.5?'orange':'red';if(v===1)num++;else if(v===0.5)num+=0.5;const rect=mk('rect',{x:margin+c*cellW,y:margin+(n_pos-1-r)*cellH,width:cellW,height:cellH,fill,stroke:'black','stroke-width':1});gCells.appendChild(rect);}}aucDisplay.textContent=`AUC calculation: ${num.toFixed(1)} / ${den} = ${(num/den).toFixed(4)}`;}

  let rocValid=false;
  function allAnchorsFilled(){return posTaken.every(v=>v!=null)&&negTaken.every(v=>v!=null);}
  function rowsSortedDescending(){for(let r=1;r<n_pos;r++){const lower=posTaken[r-1];const upper=posTaken[r];if(lower==null||upper==null)return false;const a=nodes[lower].score;const b=nodes[upper].score;if(a<b)return false;}return true;}
  function colsSortedDescending(){for(let c=1;c<n_neg;c++){if(negTaken[c-1]==null||negTaken[c]==null)return false;const a=nodes[negTaken[c-1]].score,b=nodes[negTaken[c]].score;if(a<b)return false;}return true;}

  function computeROCPoints(){const grouped={};for(let i=0;i<labels.length;i++){const sc=scores[i];(grouped[sc]||(grouped[sc]={pos:0,neg:0}));if(labels[i])grouped[sc].pos++;else grouped[sc].neg++;}const uniq=Object.keys(grouped).map(parseFloat).sort((a,b)=>b-a);const pts=[[0,0]];let fp=0,tp=0;for(const sc of uniq){fp+=grouped[sc].neg;tp+=grouped[sc].pos;pts.push([fp,tp]);}return pts;}

  function drawOrClearROC(){
    gROC.innerHTML='';
    const filled=allAnchorsFilled();
    const rowOK=rowsSortedDescending();
    const colOK=colsSortedDescending();
    const isValid=filled&&rowOK&&colOK;
    console.log('ROC check:',{filled,rowOK,colOK,isValid});
    if(!isValid){rocValid=false;randomBtn.style.display='none';aucSample.style.display='none';rocReady.style.display='none';return;}

    const pts=computeROCPoints();
    const off=strokeW/2;
    const toXY=([fp,tp])=>[margin+(fp/n_neg)*innerW+off,margin+innerH-(tp/n_pos)*innerH+off];
    const points=pts.map(p=>toXY(p).join(',')).join(' ');
    gROC.appendChild(mk('polyline',{points,fill:'none',stroke:'blue','stroke-width':strokeW}));
    pts.forEach(p=>{const[x,y]=toXY(p);gROC.appendChild(mk('circle',{cx:x,cy:y,r:3.5,fill:'blue'}));});

    if(!rocValid){
      // only reset once when ROC first becomes valid
      sampleDots.forEach(d=>d.setAttribute('fill','#ccc'));
      sampleDots=[];
      sampleNum=0;
      sampleDen=0;
      aucSample.textContent=`AUC from sampling: 0 / 0 = 0`;
    }

    rocValid=true;
    randomBtn.style.display='inline-block';
    aucSample.style.display='block';
    rocReady.style.display='block';
  }

  function updateAfterChange(){redrawMatrix();drawOrClearROC();}

  let sampleDots=[],sampleNum=0,sampleDen=0;
  randomBtn.addEventListener('click',()=>{
    if(!rocValid)return;
    sampleDots.forEach(d=>d.setAttribute('fill','#ccc'));
    const r=Math.floor(Math.random()*n_pos),c=Math.floor(Math.random()*n_neg);
    const cx=margin+c*cellW+Math.random()*cellW,cy=margin+(n_pos-1-r)*cellH+Math.random()*cellH;
    const dot=mk('circle',{cx,cy,r:4,fill:'black'});
    gSamples.appendChild(dot);sampleDots=[dot];sampleDen++;
    const posId=posTaken[r],negId=negTaken[c];if(posId==null||negId==null){aucSample.textContent=`AUC from sampling: ${sampleNum.toFixed(1)} / ${sampleDen} = ${(sampleNum/sampleDen).toFixed(4)}`;return;}
    const v=(1+Math.sign(nodes[posId].score-nodes[negId].score))/2;if(v===1)sampleNum++;else if(v===0.5)sampleNum+=0.5;
    aucSample.textContent=`AUC from sampling: ${sampleNum.toFixed(1)} / ${sampleDen} = ${(sampleNum/sampleDen).toFixed(4)}`;
  });

  setInterval(()=>{drawOrClearROC();},1000);
  redrawMatrix();
})();
</script>
</body>
</html>
