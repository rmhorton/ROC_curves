<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Continuous ROC Explorer</title>
  <script src="https://cdn.jsdelivr.net/npm/jstat@latest/dist/jstat.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/d3@7"></script>
  <script src="jstat_extra.js"></script>
  <script src="continuous_ROC_config.js"></script>
  <script src="ROC_lib.js"></script>
  <style>
    body{font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif;margin:0;background:#fcfcff;color:#21213a}
    body.busy{cursor:progress!important}
    body.busy *{cursor:progress!important}
    .app-root{width:100%;padding:16px 24px;box-sizing:border-box}
    h2{margin:0 0 6px 0;font-size:24px;font-weight:650;color:#1e1e31}
    p.description{margin:0 0 18px 0;font-size:14px;color:#515172}
    .controls{display:grid;grid-template-columns:repeat(auto-fit,minmax(320px,1fr));gap:18px;margin-bottom:22px}
    .ctrl{background:#f5f5fd;border:1px solid #e2e2f2;border-radius:14px;padding:14px;box-shadow:0 1px 3px rgba(15,15,35,0.08)}
    .ctrl h3{margin:0 0 10px 0;font-size:16px;font-weight:600;color:#2d2d48}
    .component-list{display:flex;flex-direction:column;gap:12px}
    .component-card{background:#fff;border:1px solid #d9d9ea;border-radius:10px;padding:10px}
    .component-header{display:flex;justify-content:space-between;align-items:center;font-size:13px;font-weight:600;color:#2f2f50;margin-bottom:8px}
    .component-remove-row{display:flex;justify-content:flex-end;margin-bottom:6px}
    .component-controls{display:flex;align-items:center;gap:6px;margin-left:8px}
    .component-controls button,.add-component-btn{background:#ececf9;border:1px solid #cfcfe4;border-radius:6px;padding:4px 8px;font-size:12px;cursor:pointer;color:#383856}
    .component-controls button:hover,.add-component-btn:hover{background:#dedef4}
    .component-remove-btn{min-width:28px;padding:4px 8px;text-align:center;background:#f2f2f6;border-color:#ccccd8;color:#6a6a7a;font-weight:700;border-radius:6px}
    .component-remove-btn:hover{background:#e6e6ee}
    .param-row{display:flex;align-items:center;gap:8px;margin:6px 0;font-size:13px;color:#30304a}
    .component-row{display:flex;align-items:center;gap:8px;margin:6px 0;font-size:13px;color:#30304a}
    .component-row label{min-width:110px}
    .component-row input:not([type=range]),.component-row select{flex:1;padding:5px 6px;border-radius:6px;border:1px solid #c6c6db;font-size:13px}
    .component-row input[type=range]{flex:1}
    .parameter-controls{flex:1;display:flex;align-items:center;gap:8px}
    .parameter-number{width:80px;flex:0 0 auto;padding:5px 6px;border-radius:6px;border:1px solid #c6c6db;font-size:13px}
    .parameter-slider{flex:1}
    .component-info{font-size:12px;color:#4e4e70;margin:4px 0 0 110px}
    .empirical-group rect{stroke:none}
    .hist-pos-bar{}
    .hist-neg-bar{}
    #empiricalPanel{display:flex;flex-direction:column;gap:10px;font-size:13px;color:#30304a}
    #dataImportDropZone{border:1px dashed #8a8ac5;border-radius:10px;padding:10px;text-align:center;background:#f5f5fd;cursor:pointer;transition:background 0.2s,border-color 0.2s}
    #dataImportDropZone.dragover{background:#e7e7fb;border-color:#5c5cb8}
    #dataImportStatus{font-size:12px;color:#4e4e70}
    .data-import-options{display:flex;flex-direction:column;gap:6px}
    .data-import-options label{display:flex;align-items:center;gap:6px;font-size:12px;color:#3a3a5a}
    .plot-with-legend{position:relative}
    .rug-pos line{stroke-width:1.2;opacity:0.75}
    .rug-neg line{stroke-width:1.2;opacity:0.75}
    .roc-empirical{stroke-width:2;fill:none;stroke-dasharray:5 4}
    .roc-bands path{vector-effect:non-scaling-stroke}
    .legend-bar{display:flex;flex-wrap:wrap;gap:10px;margin-top:10px;font-size:12px;color:#30304a}
    #rocLegend{display:flex;flex-wrap:wrap;gap:6px 12px;align-items:flex-start}
    #rocLegend .legend-item{flex:0 0 auto;white-space:nowrap;display:flex;align-items:center;min-width:120px}
    .legend-item{display:flex;align-items:center;gap:6px;padding:6px 10px;border:1px solid #dcdcee;border-radius:8px;cursor:pointer;user-select:none;background:#f9f9ff;transition:background 0.15s,border-color 0.15s,opacity 0.15s}
    .legend-item:hover{background:#f0f0ff}
    .legend-item.inactive{opacity:0.45;background:#f4f4f7}
    .legend-swatch{width:14px;height:14px;border-radius:3px;flex:0 0 auto;border:1px solid #d1d1e0}
    .sim-options{display:flex;flex-direction:column;gap:6px;margin-top:10px;font-size:12px;color:#3a3a5a}
    .sim-options label{display:flex;align-items:center;gap:6px}
    .add-component-btn{margin-top:0;padding:6px 10px}
    .panel-header{display:flex;align-items:center;justify-content:space-between;margin-bottom:8px}
    .panel-title{font-size:15px;font-weight:600;color:#2d2d48}
    .info-icon{font-size:13px;color:#4a4a66;cursor:help;user-select:none;padding:2px 6px;border-radius:6px;border:1px solid #dcdcee;background:#f9f9ff}
    .subsection{border:1px solid #e1e1f0;border-radius:8px;padding:10px 12px;margin-top:10px;background:#fdfdff}
    .subsection h4{margin:0 0 8px 0;font-size:14px;font-weight:600;color:#30304a}
    #busyOverlay{position:fixed;inset:0;background:rgba(255,255,255,0.65);display:none;align-items:center;justify-content:center;z-index:9999}
    #busySpinner{width:48px;height:48px;border:5px solid rgba(0,0,0,0.1);border-top-color:#4a4a90;border-radius:50%;animation:spin 1s linear infinite}
    @keyframes spin{to{transform:rotate(360deg)}}
    /*
    .plots{display:flex;flex-wrap:wrap;gap:20px;margin-bottom:50px}
    .plot-block{flex:1;min-width:360px}
    #distPlot,#rocPlot{width:100%;height:420px}
    #rocPlot svg{width:100%;height:auto}
    .roc-samples path{vector-effect:non-scaling-stroke}
    #rocLegend{flex-wrap:wrap}
    */ 
    .top-controls{display:grid;grid-template-columns:repeat(auto-fit,minmax(360px,1fr));gap:20px;margin-bottom:24px;width:100%}
    .top-column{box-sizing:border-box}
    .plots-row{display:grid;grid-template-columns:repeat(2,minmax(0,1fr));gap:24px;margin-bottom:16px;align-items:flex-start;width:100%}
    @media (max-width:900px){
      .top-controls{grid-template-columns:1fr;}
      .plots-row{grid-template-columns:1fr;}
    }
    .plot-cell{box-sizing:border-box}
    .plot-cell svg,.plot-cell .plot-wrapper{width:100%;height:auto}
    .plot-score,.plot-roc{display:flex;flex-direction:column;align-items:center}
    .bottom-panels{display:grid;grid-template-columns:repeat(auto-fit,minmax(280px,1fr));gap:24px;margin-top:24px;margin-bottom:16px;width:100%}
    .bottom-panel{width:100%;box-sizing:border-box}
    #prevalenceControl, #prevalenceControl *{width:100%;max-width:100%;box-sizing:border-box;}
    .metrics-table{width:100%;border-collapse:collapse;margin-top:10px;font-size:13px}
    .metrics-table th,.metrics-table td{border:1px solid #d7d7e8;padding:4px 10px;text-align:center}

    .threshold-input{display:flex;flex-direction:column;gap:6px;margin-top:8px;font-size:13px;color:#32324e}
.threshold-input input{width:100%;max-width:100%;padding:5px 6px;border-radius:6px;border:1px solid #c8c8dc;box-sizing:border-box}
    #prevalenceControl{display:flex;flex-direction:column;align-items:flex-start;gap:12px;font-size:13px;color:#30304a}
    #prevalenceControl input[type=range]{width:100%}
    .component-actions{display:flex;gap:8px;flex-wrap:wrap;margin-top:10px}
    table{border-collapse:collapse;margin-top:12px;font-size:13px}
    th,td{border:1px solid #d7d7e8;padding:4px 10px;text-align:center}
    .chart-title{font-size:16px;font-weight:600;fill:#202038}
    .axis-label{font-size:13px;fill:#4a4a66}
    .pdf-line-positive{stroke-width:2.4;}
    .pdf-line-negative{stroke-width:2.4;}
    .area-tp{fill:rgba(54,184,84,0.28);stroke:none}
    .area-fn{fill:rgba(220,67,67,0.30);stroke:none}
    .area-tn{fill:rgba(54,184,84,0.28);stroke:none;opacity:0.75}
    .area-fp{fill:rgba(220,67,67,0.30);stroke:none;opacity:0.75}
    .roc-point, .threshold-handle{fill:#1a73ff;stroke:#fff;stroke-width:2;cursor:grab}
    .threshold-line{stroke:#1b1b32;stroke-width:2;stroke-dasharray:6 4;cursor:ew-resize}
    .roc-point:active, .threshold-handle:active{cursor:grabbing}
    .roc-line{stroke:#30307c;stroke-width:2.5;fill:none}
    .roc-random{stroke:#a0a0ba;stroke-width:1.4;stroke-dasharray:4 4;fill:none}
  </style>
  <!--  
   .roc-point{fill:#d62728;stroke:#fff;stroke-width:1.6;cursor:pointer}-->
</head>
<body>
<div id="app" class="app-root">
  <h2 id="pageTitle">Continuous ROC Explorer</h2>
  <p class="description" id="pageIntro"></p>

  <div id="distParamContainer" class="top-controls dist-param-container">
    <div class="top-column top-negatives">
      <div class="ctrl" id="negControl">
        <h3 id="negTitle">Negatives</h3>
        <div id="negParams"></div>
      </div>
    </div>
    <div class="top-column top-positives">
      <div class="ctrl" id="posControl">
        <h3 id="posTitle">Positives</h3>
        <div id="posParams"></div>
      </div>
    </div>
  </div>

  <div class="plots-row">
    <div class="plot-cell plot-score">
      <div class="plot-with-legend plot-wrapper">
        <div id="distPlot"></div>
      </div>
      <div id="scoreLegend" class="legend-bar"></div>
    </div>
    <div class="plot-cell plot-roc">
      <div class="plot-with-legend plot-wrapper">
        <div id="rocPlot"></div>
      </div>
      <div id="rocLegend" class="legend-bar"></div>
    </div>
  </div>

    <div class="bottom-panels">
      <div id="thresholdControl" class="bottom-panel">
        <div class="panel-header">
          <span class="panel-title" id="thresholdPanelTitle"></span>
          <span class="info-icon" id="thresholdPanelInfo" title="ⓘ">ⓘ</span>
        </div>
        <div class="threshold-input">
          <label for="thresholdInput" id="thresholdInputLabel">Set exact threshold:</label>
          <input type="number" id="thresholdInput" step="0.001" value="0.5">
        </div>
        <div class="hint" id="thresholdHint"></div>
        <table id="threshold-metrics-table" class="metrics-table"></table>
      </div>
    <div id="prevalenceControl" class="bottom-panel">
        <div class="panel-header">
          <span class="panel-title" id="prevalencePanelTitle"></span>
          <span class="info-icon" id="prevalencePanelInfo" title="ⓘ">ⓘ</span>
        </div>
        <label for="prevalenceSlider" id="prevalenceLabel">Prevalence:</label>
        <input type="range" id="prevalenceSlider" min="0" max="1" step="0.01" value="0.5">
        <span id="prevalenceVal">0.50</span>
        <div id="metricsPrev">
          <table id="prevalence-metrics-table" class="metrics-table"></table>
        </div>
      </div>
    <div id="empiricalPanel" class="ctrl bottom-panel">
      <div class="panel-header">
        <span class="panel-title" id="empiricalPanelTitle"></span>
        <span class="info-icon" id="empiricalPanelInfo" title="ⓘ">ⓘ</span>
      </div>
      <div id="sampling-controls-section" class="subsection">
        <h4 id="samplingSectionTitle"></h4>
        <div class="component-row">
          <label for="sampleSizeInput">Sample size:</label>
          <input type="number" id="sampleSizeInput" value="200" min="10" step="10">
        </div>
        <div class="component-row">
          <label for="numSamplesInput"># samples (ROC reps):</label>
          <input type="number" id="numSamplesInput" value="20" min="1" step="1">
        </div>
        <button id="resampleButton" style="margin-top:10px;">New sample</button>
        <div class="sim-options">
          <label><input type="checkbox" id="autoResampleToggle">Auto-resample on parameter change</label>
        </div>
      </div>
      <div id="dataset-io-section" class="subsection">
        <h4 id="datasetSectionTitle"></h4>
        <div class="component-row">
          <label for="datasetNameInput">Dataset name:</label>
          <input type="text" id="datasetNameInput" value="simulated_dataset">
        </div>
        <div id="dataImportDropZone" style="margin-top:8px;">
          <label for="dataImportInput">Load empirical data (scores + labels):</label>
          <input type="file" id="dataImportInput" accept=".csv" style="margin-top:6px;">
          <div style="font-size:11px;color:#666;margin-top:6px;">Drop a CSV here or use the file picker. Required columns: <code>score</code>, <code>label</code>.</div>
        </div>
        <div id="dataImportStatus">No empirical data loaded.</div>
        <button id="dataExportButton" style="margin-top:10px;">Export Dataset CSV</button>
        <div id="exportStatus" style="font-size:12px;color:#666;margin-top:6px;"></div>
      </div>
    </div>
    <div id="rocPanel" class="ctrl bottom-panel">
      <div class="panel-header">
        <span class="panel-title" id="rocPanelTitle"></span>
        <span class="info-icon" id="rocPanelInfo" title="ⓘ">ⓘ</span>
      </div>
      <div class="component-row">
        <label for="rocExportName">Curve name:</label>
        <input type="text" id="rocExportName" value="exported_curve">
      </div>
        <div class="component-row">
          <label for="rocBandMode">Confidence band:</label>
          <select id="rocBandMode">
            <option value="none">None</option>
            <option value="bootstrap">Bootstrap</option>
            <option value="delong">DeLong</option>
          </select>
        </div>
        <button id="rocExportJsonButton" style="margin-top:10px;">Export ROC (JSON)</button>
        <button id="rocExportCsvButton" style="margin-top:10px;">Export ROC (CSV – human readable)</button>
        <button id="rocImportJsonButton" style="margin-top:10px;">Import ROC JSON…</button>
        <input type="file" id="rocImportFile" accept=".json,application/json" style="display:none">
      </div>
  </div>
  <div id="busyOverlay"><div id="busySpinner"></div></div>

</div>
  <script>
    window.addEventListener('DOMContentLoaded',()=>{
      const CONFIG=window.MULTIDISTRIBUTION_CONFIG||{};
      const {STRINGS,FEATURES,DISTRIBUTIONS,DISTRIBUTION_ORDER,DEFAULT_OPTIONS}=CONFIG;
      const ROC_CONFIG=window.ROC_EXPLORER_CONFIG||{};
      let isRestoringImportedState=false;
      const visibilityState={
        score:{
          posPDF:true,
          negPDF:true,
          posHist:DEFAULT_OPTIONS.showEmpiricalHistogram??true,
          negHist:DEFAULT_OPTIONS.showEmpiricalHistogram??true,
          empiricalPoints:DEFAULT_OPTIONS.showEmpiricalPoints??false
        },
        roc:{
          theoretical:true,
          empirical:DEFAULT_OPTIONS.showEmpiricalRoc??false,
          confidenceBand:true,
          estimated:true,
          sample:{}
        }
      };
      let currentEmpiricalDataset={name:'simulated_dataset', source:'simulated'};
      window.currentEmpiricalDataset=currentEmpiricalDataset;
      if(!STRINGS||!FEATURES||!DISTRIBUTIONS||!DISTRIBUTION_ORDER||!DEFAULT_OPTIONS){
        document.body.innerHTML='<p style="color:#a20000">Configuration not found. Ensure multidistribution_config.js is loaded.</p>';
        return;
      }
      const METRIC_TOOLTIPS={
        threshold:{
          tpr:'True Positive Rate (Sensitivity): TP / (TP + FN)',
          tnr:'True Negative Rate (Specificity): TN / (TN + FP)',
          fpr:'False Positive Rate: FP / (FP + TN)',
          fnr:'False Negative Rate: FN / (FN + TP)',
          youden:'Youden’s J statistic: TPR + TNR - 1',
          bacc:'Balanced Accuracy: (TPR + TNR) / 2'
        },
        prevalence:{
          ppv:'Positive Predictive Value: TP / (TP + FP)',
          npv:'Negative Predictive Value: TN / (TN + FN)',
          acc:'Overall accuracy: (TP + TN) / (TP + FP + TN + FN)',
          mrate:'Error rate: 1 - Accuracy',
          mcc:'Matthews Correlation Coefficient: correlation between observed and predicted classes',
          dor:'Diagnostic Odds Ratio: (TP * TN) / (FP * FN)'
        }
      };
      ['threshold','prevalence'].forEach(section=>{
        const target=STRINGS.metrics?.[section];
        if(!target){return;}
        Object.entries(METRIC_TOOLTIPS[section]).forEach(([key,tip])=>{
          if(target[key] && target[key].tooltip===undefined){
            target[key].tooltip=tip;
          }
        });
      });
      const DISTRIBUTIONS_INTERNAL=Object.fromEntries(
        Object.entries(DISTRIBUTIONS||{}).map(([key,def])=>{
          const trimmed=String(key||'').trim();
          return trimmed?[trimmed,def]:null;
        }).filter(Boolean)
      );
      const DISTRIBUTION_KEYS=Array.isArray(DISTRIBUTION_ORDER)
        ? DISTRIBUTION_ORDER.map(key=>String(key||'').trim()).filter(key=>DISTRIBUTIONS_INTERNAL[key])
        : Object.keys(DISTRIBUTIONS_INTERNAL);
      if(!DISTRIBUTION_KEYS.length){
        document.body.innerHTML='<p style="color:#a20000">No distributions configured. Check multidistribution_config.js.</p>';
        return;
      }

      const DEFAULT_COLOR_CONFIG={
        positive:{hue:'#1f77b4',histogramOpacity:0.4,rugOpacity:0.75,pdfOpacity:1,rocOpacity:1},
        negative:{hue:'#d62728',histogramOpacity:0.4,rugOpacity:0.75,pdfOpacity:1,rocOpacity:1},
        sample:{hue:'#7d3cff',opacity:0.7},
        empirical:{hue:'#7d3cff',opacity:1},
        randomRoc:{hue:'#30307c',opacity:1},
        confidenceBand:{hue:'#7d3cff',opacity:0.18,strokeOpacity:1},
        positiveCurveFill:{hue:'#1f77b4',opacity:0.08},
        negativeCurveFill:{hue:'#d62728',opacity:0.08},
        estimatedCurve:{hue:'#17becf',opacity:1}
      };

      function resolveColorConfig(source){
        const result={
          positive:{...DEFAULT_COLOR_CONFIG.positive},
          negative:{...DEFAULT_COLOR_CONFIG.negative},
          sample:{...DEFAULT_COLOR_CONFIG.sample},
          empirical:{...DEFAULT_COLOR_CONFIG.empirical},
          randomRoc:{...DEFAULT_COLOR_CONFIG.randomRoc},
          confidenceBand:{...DEFAULT_COLOR_CONFIG.confidenceBand},
          positiveCurveFill:{...DEFAULT_COLOR_CONFIG.positiveCurveFill},
          negativeCurveFill:{...DEFAULT_COLOR_CONFIG.negativeCurveFill},
          estimatedCurve:{...DEFAULT_COLOR_CONFIG.estimatedCurve}
        };
        ['positive','negative'].forEach(key=>{
          const entry=source?.[key];
          if(!entry){return;}
          if(typeof entry.hue==='string' && entry.hue.trim()){result[key].hue=entry.hue;}
          ['histogramOpacity','rugOpacity','pdfOpacity','rocOpacity'].forEach(field=>{
            const val=Number(entry[field]);
            if(Number.isFinite(val)){result[key][field]=val;}
          });
        });
        ['sample','empirical','randomRoc','confidenceBand','positiveCurveFill','negativeCurveFill'].forEach(key=>{
          const entry=source?.[key];
          if(!entry){return;}
          if(typeof entry.hue==='string' && entry.hue.trim()){result[key].hue=entry.hue;}
          if(entry.opacity!==undefined){
            const val=Number(entry.opacity);
            if(Number.isFinite(val)){result[key].opacity=val;}
          }
          if(entry.strokeOpacity!==undefined){
            const val=Number(entry.strokeOpacity);
            if(Number.isFinite(val)){result[key].strokeOpacity=val;}
          }
        });
        return result;
      }

      function getColor(key, fallback='#000'){
        const entry=COLOR_CONFIG?.[key];
        if(!entry){return fallback;}
        if(entry.hue){
          const opacity=entry.opacity!==undefined?entry.opacity:1;
          return ROCUtils.hexOpacityToRgba(entry.hue,opacity);
        }
        return fallback;
      }

      function applyColorStyles(colors){
        const toRgba=ROCUtils.hexOpacityToRgba;
        document.querySelectorAll('style[data-role="color-theme"]').forEach(node=>node.remove());
        const css=`
.hist-pos-bar{fill:${getColor('positive', '#1f77b4')};opacity:${colors?.positive?.histogramOpacity??0.4};}
.hist-neg-bar{fill:${getColor('negative', '#d62728')};opacity:${colors?.negative?.histogramOpacity??0.4};}
.rug-pos line{stroke:${getColor('positive', '#1f77b4')};opacity:${colors?.positive?.rugOpacity??0.75};}
.rug-neg line{stroke:${getColor('negative', '#d62728')};opacity:${colors?.negative?.rugOpacity??0.75};}
.legend-pos{background:${getColor('positive', '#1f77b4')};opacity:${colors?.positive?.histogramOpacity??0.4};}
.legend-neg{background:${getColor('negative', '#d62728')};opacity:${colors?.negative?.histogramOpacity??0.4};}
.pdf-line-positive{stroke:${getColor('positive', '#1f77b4')};fill:${getColor('positiveCurveFill','#1f77b4')};opacity:${colors?.positive?.pdfOpacity??1};}
.pdf-line-negative{stroke:${getColor('negative', '#d62728')};fill:${getColor('negativeCurveFill','#d62728')};opacity:${colors?.negative?.pdfOpacity??1};}
`;
        const styleEl=document.createElement('style');
        styleEl.setAttribute('data-role','color-theme');
        styleEl.textContent=css;
        document.head.appendChild(styleEl);
      }

      const COLOR_CONFIG=resolveColorConfig(CONFIG.COLORS);
      applyColorStyles(COLOR_CONFIG);
const COLOR_HELPERS={
        posPdf:getColor('positive', '#1f77b4'),
        negPdf:getColor('negative', '#d62728'),
        posPdfFill:getColor('positiveCurveFill', '#1f77b4'),
        negPdfFill:getColor('negativeCurveFill', '#d62728'),
        posHist:getColor('positive', '#1f77b4'),
        negHist:getColor('negative', '#d62728'),
        posRug:getColor('positive', '#1f77b4'),
        negRug:getColor('negative', '#d62728'),
        empirical:getColor('empirical', '#7d3cff'),
        roc:getColor('randomRoc', '#30307c'),
        sample:getColor('sample', '#7d3cff'),
        estimated:getColor('estimatedCurve', '#17becf'),
        confBandFill:()=>ROCUtils.hexOpacityToRgba(COLOR_CONFIG.confidenceBand?.hue||'#7d3cff',COLOR_CONFIG.confidenceBand?.opacity??0.18),
        confBandStroke:getColor('confidenceBand', '#7d3cff')
      };

      const scoreLegendContainer=document.getElementById('scoreLegend');
      const rocLegendContainer=document.getElementById('rocLegend');
      const getScoreLegendItems=()=>{
        const items=[
          {key:'posPDF',label:'Positive PDF',color:COLOR_HELPERS.posPdfFill},
          {key:'negPDF',label:'Negative PDF',color:COLOR_HELPERS.negPdfFill},
          {key:'posHist',label:'Positive histogram',color:COLOR_HELPERS.posHist},
          {key:'negHist',label:'Negative histogram',color:COLOR_HELPERS.negHist}
        ];
        if(hasEmpiricalData()){
          items.push({key:'empiricalPoints',label:'Empirical points',color:COLOR_HELPERS.empirical});
        }
        return items;
      };

      function buildLegend(container, items, sectionKey){
        if(!container){return;}
        container.innerHTML='';
        items.forEach(item=>{
          const el=document.createElement('div');
          el.className='legend-item';
          el.dataset.section=sectionKey;
          el.dataset.key=item.key;
          const swatch=document.createElement('span');
          swatch.className='legend-swatch';
          swatch.style.background=item.color;
          const label=document.createElement('span');
          label.textContent=item.label;
          el.appendChild(swatch);
          el.appendChild(label);
          el.addEventListener('click',()=>{
            const section=visibilityState[sectionKey]||{};
            if(sectionKey==='roc'){
              if(item.key==='sampleCurves'){
                const current=state.plots.showSampleRocCurves!==false;
                state.plots.showSampleRocCurves=!current;
                section.sample=section.sample||{};
                section.sample.sampleCurves=state.plots.showSampleRocCurves;
              } else if(item.key==='empirical'){
                const current=state.plots.showEmpiricalRocCurve!==false;
                state.plots.showEmpiricalRocCurve=!current;
                section.empirical=state.plots.showEmpiricalRocCurve;
              } else if(item.key==='estimated'){
                const current=state.plots.showEstimatedCurve!==false;
                state.plots.showEstimatedCurve=!current;
                section.estimated=state.plots.showEstimatedCurve;
              } else if(item.key==='confidenceBand'){
                const current=state.plots.showConfidenceBands!==false;
                state.plots.showConfidenceBands=!current;
                section.confidenceBand=state.plots.showConfidenceBands;
              } else {
                section[item.key]=!section[item.key];
              }
            } else {
              section[item.key]=!section[item.key];
            }
            visibilityState[sectionKey]=section;
            renderLegendSelection();
            update();
          });
          container.appendChild(el);
        });
      }

      function renderLegendSelection(){
        document.querySelectorAll('.legend-item').forEach(el=>{
          const section=el.dataset.section;
          const key=el.dataset.key;
          let active=visibilityState?.[section]?.[key];
          if(section==='roc' && key){
            if(key==='sampleCurves'){
              active=state.plots.showSampleRocCurves!==false;
              visibilityState.roc.sample=visibilityState.roc.sample||{};
              visibilityState.roc.sample.sampleCurves=active;
            } else if(key==='empirical'){
              active=state.plots.showEmpiricalRocCurve!==false;
              visibilityState.roc.empirical=active;
            } else if(key==='estimated'){
              active=state.plots.showEstimatedCurve!==false;
              visibilityState.roc.estimated=active;
            } else if(key==='confidenceBand'){
              active=state.plots.showConfidenceBands!==false;
              visibilityState.roc.confidenceBand=active;
            }
          }
          el.classList.toggle('inactive',!active);
        });
      }

      function resetVisibilityState(){
        visibilityState.score=visibilityState.score||{};
        visibilityState.roc=visibilityState.roc||{};
        visibilityState.roc.sample=visibilityState.roc.sample||{};
        visibilityState.score.posPDF=true;
        visibilityState.score.negPDF=true;
        visibilityState.score.posHist=true;
        visibilityState.score.negHist=true;
        visibilityState.score.empiricalPoints=true;
        visibilityState.roc.theoretical=true;
        visibilityState.roc.empirical=state.plots.showEmpiricalRocCurve!==false;
        visibilityState.roc.estimated=state.plots.showEstimatedCurve!==false;
        visibilityState.roc.confidenceBand=state.plots.showConfidenceBands!==false;
        visibilityState.roc.sample.sampleCurves=state.plots.showSampleRocCurves!==false;
        renderLegendSelection();
      }

      const prevalenceSlider=document.getElementById('prevalenceSlider');
      const thresholdInput=document.getElementById('thresholdInput');
      const prevalenceValEl=document.getElementById('prevalenceVal');

      document.title=STRINGS.pageTitle;
      document.getElementById('pageTitle').textContent=STRINGS.pageTitle;
      document.getElementById('pageIntro').textContent=STRINGS.introText;
      document.getElementById('negTitle').textContent=STRINGS.controls.negativesTitle;
      document.getElementById('posTitle').textContent=STRINGS.controls.positivesTitle;
      document.getElementById('thresholdInputLabel').textContent=STRINGS.controls.thresholdInputLabel;
      const thresholdHintEl=document.getElementById('thresholdHint');
      if(thresholdHintEl){thresholdHintEl.textContent='';}
      document.getElementById('prevalenceLabel').textContent=STRINGS.controls.prevalenceLabel;
      const panelStrings=STRINGS.panels||{};
      const setPanelCopy=(titleId,infoId,key)=>{
        const cfg=panelStrings[key]||{};
        const titleEl=document.getElementById(titleId);
        const infoEl=document.getElementById(infoId);
        if(titleEl){titleEl.textContent=cfg.title||'';}
        if(infoEl){infoEl.setAttribute('title',cfg.info||'');}
      };
      setPanelCopy('thresholdPanelTitle','thresholdPanelInfo','threshold');
      setPanelCopy('prevalencePanelTitle','prevalencePanelInfo','prevalence');
      setPanelCopy('empiricalPanelTitle','empiricalPanelInfo','empiricalSamples');
      const samplingTitle=document.getElementById('samplingSectionTitle');
      const datasetTitle=document.getElementById('datasetSectionTitle');
      if(samplingTitle){samplingTitle.textContent=panelStrings.empiricalSamples?.samplingSectionTitle||'Sampling';}
      if(datasetTitle){datasetTitle.textContent=panelStrings.empiricalSamples?.datasetSectionTitle||'Dataset';}
      setPanelCopy('rocPanelTitle','rocPanelInfo','rocCurves');

      function computeThresholdMetrics(confusion){
        const TP=Math.max(0,Number(confusion?.TP)||0);
        const FP=Math.max(0,Number(confusion?.FP)||0);
        const TN=Math.max(0,Number(confusion?.TN)||0);
        const FN=Math.max(0,Number(confusion?.FN)||0);
        const safeDiv=(num,den)=>den>0?num/den:0;
        const tpr=safeDiv(TP,TP+FN);
        const tnr=safeDiv(TN,TN+FP);
        const fpr=safeDiv(FP,FP+TN);
        const fnr=safeDiv(FN,FN+TP);
        const youden=tpr+tnr-1;
        const bacc=(tpr+tnr)/2;
        return {tpr,tnr,fpr,fnr,youden,bacc};
      }

      function computeConfusionAtThreshold(thrPoint){
        if(!thrPoint){return null;}
        const prevalence=clamp(Number(state.prevalence)||0,0,1);
        const tprVal=clamp(thrPoint.tpr,0,1);
        const fprVal=clamp(thrPoint.fpr,0,1);
        const TP=tprVal*prevalence;
        const FN=Math.max(prevalence-TP,0);
        const FP=fprVal*(1-prevalence);
        const TN=Math.max((1-prevalence)-FP,0);
        return {TP,FP,TN,FN,prevalence};
      }

      function renderThresholdMetrics(thrPoint){
        const table=document.getElementById('threshold-metrics-table');
        if(!table){return;}
        if(!thrPoint || !Number.isFinite(thrPoint.tpr) || !Number.isFinite(thrPoint.fpr)){
          table.innerHTML='';
          return;
        }
        const confusion=computeConfusionAtThreshold(thrPoint);
        const metrics=computeThresholdMetrics(confusion);
        const labels=STRINGS.metrics?.threshold||{};
        const rows=[
          {key:'tpr',value:metrics.tpr},
          {key:'tnr',value:metrics.tnr},
          {key:'fpr',value:metrics.fpr},
          {key:'fnr',value:metrics.fnr},
          {key:'youden',value:metrics.youden},
          {key:'bacc',value:metrics.bacc}
        ];
        table.innerHTML=rows.map(row=>{
          const labelCfg=labels[row.key]||{};
          const label=labelCfg.label||row.key.toUpperCase();
          const tooltip=labelCfg.tooltip||'';
          const val=Number.isFinite(row.value)?row.value:0;
          return `<tr><th title="${tooltip}">${label}</th><td>${val.toFixed(3)}</td></tr>`;
        }).join('');
      }

      function computePrevalenceMetrics(confusion){
        if(!confusion){return {};}
        const TP=Number(confusion.TP)||0;
        const FP=Number(confusion.FP)||0;
        const TN=Number(confusion.TN)||0;
        const FN=Number(confusion.FN)||0;
        const safeDiv=(num,den)=>den>0?num/den:NaN;
        const ppv=safeDiv(TP,TP+FP);
        const npv=safeDiv(TN,TN+FN);
        const acc=safeDiv(TP+TN,TP+FP+TN+FN);
        const mrate=Number.isFinite(acc)?1-acc:NaN;
        const mccDen=(TP+FP)*(TP+FN)*(TN+FP)*(TN+FN);
        const mcc=mccDen>0?((TP*TN)-(FP*FN))/Math.sqrt(mccDen):NaN;
        const dorDen=FP*FN;
        const dor=TP>0 && TN>0 && dorDen>0 ? (TP*TN)/dorDen : NaN;
        return {ppv,npv,acc,mrate,mcc,dor};
      }

      function renderPrevalenceMetrics(thrPoint){
        const table=document.getElementById('prevalence-metrics-table');
        if(!table){return;}
        const confusion=computeConfusionAtThreshold(thrPoint);
        if(!confusion){table.innerHTML='';return;}
        const metrics=computePrevalenceMetrics(confusion);
        const labels=STRINGS.metrics?.prevalence||{};
        const rows=[
          {key:'ppv',value:metrics.ppv},
          {key:'npv',value:metrics.npv},
          {key:'acc',value:metrics.acc},
          {key:'mrate',value:metrics.mrate},
          {key:'mcc',value:metrics.mcc},
          {key:'dor',value:metrics.dor}
        ];
        table.innerHTML=rows.map(row=>{
          const labelCfg=labels[row.key]||{};
          const label=labelCfg.label||row.key.toUpperCase();
          const tooltip=labelCfg.tooltip||'';
          const val=row.value;
          const display=Number.isFinite(val)?val.toFixed(3):'—';
          return `<tr><th title="${tooltip}">${label}</th><td>${display}</td></tr>`;
        }).join('');
      }

      function cloneComponent(src={}){
        const fallback=DISTRIBUTION_KEYS.find(key=>DISTRIBUTIONS_INTERNAL[key])||Object.keys(DISTRIBUTIONS_INTERNAL)[0];
        const key=(src.distribution&&DISTRIBUTIONS_INTERNAL[src.distribution])?src.distribution:fallback;
        const def=DISTRIBUTIONS_INTERNAL[key];
        const params={};
        const source=src.parameters||{};
        def.parameters.forEach(meta=>{
          let value;
          if(Object.prototype.hasOwnProperty.call(source,meta.id)){
            value=source[meta.id];
          } else if(meta.alias){
            const aliases=Array.isArray(meta.alias)?meta.alias:[meta.alias];
            const match=aliases.find(alias=>Object.prototype.hasOwnProperty.call(source,alias));
            if(match!==undefined){value=source[match];}
          }
          if(value===undefined){value=meta.value;}
          params[meta.id]=value;
        });
        return {distribution:key,weight:src.weight??1,parameters:params};
      }

      function cloneSet(opts){
        if(FEATURES.allowMultiComponents){
          if(opts?.components?.length){
            return opts.components.map(cloneComponent);
          }
          const count=Math.max(1,Math.min(FEATURES.defaultComponents||1,FEATURES.maxComponents||Infinity));
          return Array.from({length:count},()=>cloneComponent({distribution:opts?.distribution||DISTRIBUTION_ORDER[0],parameters:opts?.parameters||{},weight:1/count}));
        }
        return [cloneComponent(opts||{distribution:DISTRIBUTION_ORDER[0]})];
      }

      // NOTE: v1.16 state refactor:
      // `state` will gradually replace scattered globals for theoretical, samples,
      // imported data, and plot visibility. For now this object mirrors existing fields.
      const state={
        theoretical:{
          threshold:DEFAULT_OPTIONS.threshold??0.5,
          prevalence:DEFAULT_OPTIONS.prevalence??0.5,
          thresholdInitialized:false,
          posComponents:cloneSet(DEFAULT_OPTIONS.positives),
          negComponents:cloneSet(DEFAULT_OPTIONS.negatives)
        },
        domain:[0,1],
        rocPairs:[],
        rocPairsSorted:[],
        dataPoints:[],
        dataImported:DEFAULT_OPTIONS.dataImported||false, // mapped to imported
        autoResample:DEFAULT_OPTIONS.autoResample??false,
        simulatedDataActive:false,
        rocBandMode:'none',
        busy:false,
        samples:{
          curves:[],
          histograms:null,
          confBand:null,
          delongBand:null,
          estimatedCurve:null,
          numSamples:20
        },
        imported:{
          datasetName:'',
          filename:null,
          sampleCount:0,
          positives:[],
          negatives:[],
          rows:[],
          histograms:null,
          rocCurve:null
        },
        plots:{
          showSampleRocCurves:true,
          showEmpiricalRocCurve:DEFAULT_OPTIONS.showEmpiricalRoc??false,
          showEstimatedCurve:true,
          showConfidenceBands:true,
          histogramMode:'sample',
          showEmpiricalHistogram:DEFAULT_OPTIONS.showEmpiricalHistogram??true,
          showEmpiricalPoints:DEFAULT_OPTIONS.showEmpiricalPoints??false
        }
      };

      thresholdInput.value=(Number(state.threshold)||0).toFixed(3);
      prevalenceSlider.value=state.prevalence;
      prevalenceValEl.textContent=STRINGS.controls.prevalenceValue(Number(state.prevalence)||0);

      const autoResampleToggle=document.getElementById('autoResampleToggle');
      const resampleButton=document.getElementById('resampleButton');
      const numSamplesInput=document.getElementById('numSamplesInput');
      const sampleSizeInput=document.getElementById('sampleSizeInput');
      const rocBandModeSelect=document.getElementById('rocBandMode');
      if(resampleButton){resampleButton.title=STRINGS.tooltips?.newSampleButton||'';}
      if(sampleSizeInput){sampleSizeInput.title=STRINGS.tooltips?.sampleSizeInput||'';}
      if(numSamplesInput){numSamplesInput.title=STRINGS.tooltips?.numSamplesInput||'';}
      // map legacy properties to theoretical container
      const initialThreshold=state.theoretical.threshold;
      const initialPrevalence=state.theoretical.prevalence;
      const initialThresholdInitialized=state.theoretical.thresholdInitialized;
      ['threshold','prevalence','thresholdInitialized'].forEach(key=>{
        Object.defineProperty(state,key,{
          get(){return state.theoretical[key];},
          set(v){state.theoretical[key]=v;}
        });
      });
      Object.defineProperty(state,'posComponents',{
        get(){return state.theoretical.posComponents;},
        set(v){state.theoretical.posComponents=v;}
      });
      Object.defineProperty(state,'negComponents',{
        get(){return state.theoretical.negComponents;},
        set(v){state.theoretical.negComponents=v;}
      });
      ['samplesROC','samplesHist','confBand','delongBand','estimatedCurve','numSamples'].forEach(key=>{
        Object.defineProperty(state,key,{
          get(){return state.samples[key==='samplesROC'?'curves':key==='samplesHist'?'histograms':key==='estimatedCurve'?'estimatedCurve':key];},
          set(v){
            if(key==='samplesROC'){state.samples.curves=v;return;}
            if(key==='samplesHist'){state.samples.histograms=v;return;}
            if(key==='estimatedCurve'){state.samples.estimatedCurve=v;return;}
            if(key==='numSamples'){state.samples.numSamples=v;return;}
            state.samples[key]=v;
          }
        });
      });
      // map imported / plot flags to structured containers
      Object.defineProperty(state,'dataImported',{
        get(){return state.imported.dataImported;},
        set(v){state.imported.dataImported=v;}
      });
      Object.defineProperty(state,'importedDataFilename',{
        get(){return state.imported.filename;},
        set(v){state.imported.filename=v;}
      });
      Object.defineProperty(state,'importedSampleCount',{
        get(){return state.imported.sampleCount;},
        set(v){state.imported.sampleCount=v;}
      });
      Object.defineProperty(state,'importedRawPos',{
        get(){return state.imported.positives;},
        set(v){state.imported.positives=v;}
      });
      Object.defineProperty(state,'importedRawNeg',{
        get(){return state.imported.negatives;},
        set(v){state.imported.negatives=v;}
      });
      Object.defineProperty(state,'empiricalPoints',{
        get(){return state.imported.rows;},
        set(v){state.imported.rows=v;}
      });
      Object.defineProperty(state,'showEmpiricalHistogram',{
        get(){return state.plots.showEmpiricalHistogram;},
        set(v){state.plots.showEmpiricalHistogram=v;}
      });
      Object.defineProperty(state,'showEmpiricalRoc',{
        get(){return state.plots.showEmpiricalRocCurve;},
        set(v){state.plots.showEmpiricalRocCurve=v;}
      });
      Object.defineProperty(state,'showEmpiricalPoints',{
        get(){return state.plots.showEmpiricalPoints;},
        set(v){state.plots.showEmpiricalPoints=v;}
      });
      state.threshold=initialThreshold;
      state.prevalence=initialPrevalence;
      state.thresholdInitialized=initialThresholdInitialized;
      // initialize mirrors
      state.theoretical.positive=state.theoretical.posComponents;
      state.theoretical.negative=state.theoretical.negComponents;
      state.samples={curves:state.samplesROC,estimatedCurve:state.estimatedCurve};
      state.imported={datasetName:currentEmpiricalDataset.name||'',rows:state.empiricalPoints,histograms:null,rocCurve:null};
      state.plots={showSampleRocCurves:true,showEmpiricalRocCurve:true,showEstimatedCurve:true,showConfidenceBands:true,histogramMode:'sample',showEmpiricalHistogram:true,showEmpiricalPoints:true};
      autoResampleToggle.checked=state.autoResample;
      autoResampleToggle.addEventListener('change',event=>{
        state.autoResample=event.target.checked;
        if(state.autoResample && currentEmpiricalDataset.source==='simulated'){
          resampleFromState();
          regenerateSampleRocs();
        }
      });
      resampleButton.addEventListener('click',async ()=>{
        resampleFromState(true);
        await regenerateSampleRocs(true);
      });
      if(numSamplesInput){
        numSamplesInput.value=Number(state.samples?.numSamples)||20;
        numSamplesInput.addEventListener('input',async event=>{
          const val=Math.max(1,Math.round(Number(event.target.value)||1));
          state.samples.numSamples=val;
          event.target.value=String(val);
        });
      }
      if(sampleSizeInput){
        sampleSizeInput.addEventListener('input',()=>{
          // avoid resampling on every keystroke
        });
        sampleSizeInput.addEventListener('change',async ()=>{
          await regenerateSampleRocs(true);
        });
      }
      if(rocBandModeSelect){
        rocBandModeSelect.value=state.rocBandMode;
        rocBandModeSelect.addEventListener('change',event=>{
          const value=event.target.value;
          state.rocBandMode=value;
          update();
        });
      }

      const dataImportInput=document.getElementById('dataImportInput');
      if(dataImportInput){dataImportInput.title=STRINGS.tooltips?.datasetImport||'';}
      dataImportInput.addEventListener('change',event=>{
        const file=event.target.files?.[0];
        if(file){handleDataFile(file);}
      });

      const dataImportDropZone=document.getElementById('dataImportDropZone');
      ['dragenter','dragover'].forEach(evt=>{
        dataImportDropZone.addEventListener(evt,event=>{
          event.preventDefault();
          event.stopPropagation();
          dataImportDropZone.classList.add('dragover');
        });
      });
      ['dragleave','drop'].forEach(evt=>{
        dataImportDropZone.addEventListener(evt,event=>{
          event.preventDefault();
          event.stopPropagation();
          dataImportDropZone.classList.remove('dragover');
          if(event.type==='drop'){
            const file=event.dataTransfer?.files?.[0];
            if(file){
              handleDataFile(file);
              dataImportInput.value='';
            }
          }
        });
      });

      const distDims={width:540,height:420,margin:{top:40,right:24,bottom:60,left:64}};
      const rocDims={width:540,height:420,margin:{top:40,right:24,bottom:60,left:64}};

      const distSvg=d3.select('#distPlot').append('svg')
        .attr('viewBox',`0 0 ${distDims.width} ${distDims.height}`)
        .attr('preserveAspectRatio','xMidYMid meet');
      const distContent=distSvg.append('g')
        .attr('transform',`translate(${distDims.margin.left},${distDims.margin.top})`);
      const distWidth=distDims.width-distDims.margin.left-distDims.margin.right;
      const distHeight=distDims.height-distDims.margin.top-distDims.margin.bottom;

      distSvg.append('text')
        .attr('class','chart-title')
        .attr('x',distDims.width/2)
        .attr('y',24)
        .attr('text-anchor','middle')
        .text(STRINGS.plots.scoreTitle);

      const distXScale=d3.scaleLinear().range([0,distWidth]);
      const distYScale=d3.scaleLinear().range([distHeight,0]);
      const distXAxisGroup=distContent.append('g').attr('transform',`translate(0,${distHeight})`);
      const distYAxisGroup=distContent.append('g');

      distContent.append('text')
        .attr('class','axis-label')
        .attr('x',distWidth/2)
        .attr('y',distHeight+42)
        .attr('text-anchor','middle')
        .text(STRINGS.plots.scoreXAxis);

      function refreshScoreLegend(){
        buildLegend(scoreLegendContainer,getScoreLegendItems(),'score');
      }
      function refreshRocLegend(){
        const items=[{key:'theoretical',label:'Theoretical ROC',color:COLOR_HELPERS.roc}];
        if(state.samples?.estimatedCurve){
          items.push({key:'estimated',label:'Estimated ROC',color:COLOR_HELPERS.estimated});
        }
        if(state.samples?.curves && state.samples.curves.length){
          items.push({key:'sampleCurves',label:'Sample ROC Curves',color:COLOR_HELPERS.sample});
        }
        if(state.imported?.rocCurve){
          items.push({key:'empirical',label:'Empirical ROC',color:COLOR_HELPERS.empirical});
        }
        const hasBand=(state.samples?.estimatedCurve && Array.isArray(state.samples.estimatedCurve.bands) && state.samples.estimatedCurve.bands.length) || state.confBand || state.delongBand;
        if(hasBand){
          items.push({key:'confidenceBand',label:'Confidence band',color:COLOR_HELPERS.sample});
        }
        buildLegend(rocLegendContainer,items,'roc');
      }
      refreshScoreLegend();
      refreshRocLegend();
      renderLegendSelection();
      distContent.append('text')
        .attr('class','axis-label')
        .attr('transform','rotate(-90)')
        .attr('x',-distHeight/2)
        .attr('y',-46)
        .attr('text-anchor','middle')
        .text(STRINGS.plots.scoreYAxis);

      const empiricalGroup=distContent.append('g').attr('class','empirical-group');
      const rugNegGroup=empiricalGroup.append('g').attr('class','rug-neg');
      const rugPosGroup=empiricalGroup.append('g').attr('class','rug-pos');
      const histNegGroup=empiricalGroup.append('g').attr('class','hist-neg');
      const histPosGroup=empiricalGroup.append('g').attr('class','hist-pos');

      const distAreaGroup=distContent.append('g').attr('class','area-group');
      const areaTNPath=distAreaGroup.append('path').attr('class','area-tn');
      const areaFPPath=distAreaGroup.append('path').attr('class','area-fp');
      const areaFNPath=distAreaGroup.append('path').attr('class','area-fn');
      const areaTPPath=distAreaGroup.append('path').attr('class','area-tp');

      const distPosLinePath=distContent.append('path').attr('class','pdf-line-positive').attr('fill',COLOR_HELPERS.posPdfFill).attr('stroke',COLOR_HELPERS.posPdf);
      const distNegLinePath=distContent.append('path').attr('class','pdf-line-negative').attr('fill',COLOR_HELPERS.negPdfFill).attr('stroke',COLOR_HELPERS.negPdf);
      const distPosRect=distContent.append('rect').attr('class','pdf-line-positive').attr('fill',COLOR_HELPERS.posPdfFill).attr('stroke',COLOR_HELPERS.posPdf).style('display','none');
      const distNegRect=distContent.append('rect').attr('class','pdf-line-negative').attr('fill',COLOR_HELPERS.negPdfFill).attr('stroke',COLOR_HELPERS.negPdf).style('display','none');
      const thresholdLine=distContent.append('line').attr('class','threshold-line');
      const thresholdHandle=distContent.append('circle').attr('class','threshold-handle').attr('r',6);
      thresholdLine.append('title').text(STRINGS.tooltips?.thresholdLine||'');
      thresholdHandle.append('title').text(STRINGS.tooltips?.thresholdLine||'');

      const distAreaGenerator=d3.area().curve(d3.curveMonotoneX)
        .x(d=>distXScale(d.x))
        .y0(()=>distYScale(0))
        .y1(d=>distYScale(d.y));
      const distPosLineGenerator=d3.line().curve(d3.curveMonotoneX)
        .x(d=>distXScale(d.x))
        .y(d=>distYScale(d.posPDF));
      const distNegLineGenerator=d3.line().curve(d3.curveMonotoneX)
        .x(d=>distXScale(d.x))
        .y(d=>distYScale(d.negPDF));

      const dragOverlay=distContent.append('rect')
        .attr('class','drag-overlay')
        .attr('width',distWidth)
        .attr('height',distHeight)
        .attr('fill','transparent')
        .style('cursor','ew-resize');

      const tooltip=d3.select('body').append('div')
        .style('position','absolute')
        .style('padding','6px 10px')
        .style('background','#222')
        .style('color','#fff')
        .style('border-radius','6px')
        .style('font-size','12px')
        .style('pointer-events','none')
        .style('opacity',0);

      function showTooltip(text,event){
        const e=event.touches?.[0]||event;
        if(!e){return;}
        tooltip.style('opacity',1)
          .style('left',`${(e.pageX??e.clientX+window.scrollX)+12}px`)
          .style('top',`${(e.pageY??e.clientY+window.scrollY)-24}px`)
          .text(text);
      }
      function hideTooltip(){tooltip.style('opacity',0);}

      dragOverlay.call(d3.drag()
        .on('start',handleDrag)
        .on('drag',handleDrag)
        .on('end',()=>hideTooltip()));
      thresholdLine.call(d3.drag()
        .on('start',handleDrag)
        .on('drag',handleDrag)
        .on('end',()=>hideTooltip()));
      thresholdHandle.call(d3.drag()
        .on('start',handleDrag)
        .on('drag',handleDrag)
        .on('end',()=>hideTooltip()))
        .on('mouseenter',event=>showTooltip(STRINGS.metrics.thresholdHandleTooltip(state.threshold),event))
        .on('mousemove',event=>showTooltip(STRINGS.metrics.thresholdHandleTooltip(state.threshold),event))
        .on('mouseleave',hideTooltip);

      const rocSvg=d3.select('#rocPlot').append('svg')
        .attr('viewBox',`0 0 ${rocDims.width} ${rocDims.height}`)
        .attr('preserveAspectRatio','xMidYMid meet')
        .attr('width',rocDims.width)
        .attr('height',rocDims.height);
      const rocContent=rocSvg.append('g')
        .attr('transform',`translate(${rocDims.margin.left},${rocDims.margin.top})`);
      const rocWidth=rocDims.width-rocDims.margin.left-rocDims.margin.right;
      const rocHeight=rocDims.height-rocDims.margin.top-rocDims.margin.bottom;
      const rocClip=rocContent.append('clipPath').attr('id','rocClip');
      rocClip.append('rect').attr('x',0).attr('y',0).attr('width',rocWidth).attr('height',rocHeight);

      const rocTitle=rocSvg.append('text')
        .attr('class','chart-title')
        .attr('x',rocDims.width/2)
        .attr('y',24)
        .attr('text-anchor','middle');

      const rocXScale=d3.scaleLinear().domain([0,1]).range([0,rocWidth]);
      const rocYScale=d3.scaleLinear().domain([0,1]).range([rocHeight,0]);
      const rocXAxisGroup=rocContent.append('g').attr('transform',`translate(0,${rocHeight})`);
      const rocYAxisGroup=rocContent.append('g');

      rocContent.append('text')
        .attr('class','axis-label')
        .attr('x',rocWidth/2)
        .attr('y',rocHeight+42)
        .attr('text-anchor','middle')
        .text(STRINGS.plots.rocXAxis);
      rocContent.append('text')
        .attr('class','axis-label')
        .attr('transform','rotate(-90)')
        .attr('x',-rocHeight/2)
        .attr('y',-48)
        .attr('text-anchor','middle')
        .text(STRINGS.plots.rocYAxis);

      const rocBandGroup=rocContent.append('g').attr('class','roc-bands roc-ci-band').attr('clip-path','url(#rocClip)');
      const rocSampleGroup=rocContent.append('g').attr('class','roc-samples').attr('clip-path','url(#rocClip)');
      const estimatedRocPath=rocContent.append('path').attr('class','roc-estimated').attr('clip-path','url(#rocClip)');
      const rocLinePath=rocContent.append('path').attr('class','roc-line').attr('clip-path','url(#rocClip)');
      const empiricalRocPath=rocContent.append('path').attr('class','roc-empirical').style('opacity',0).attr('clip-path','url(#rocClip)');
      rocContent.append('path').attr('class','roc-random')
        .attr('d',`M${rocXScale(0)},${rocYScale(0)} L${rocXScale(1)},${rocYScale(1)}`);
      const rocPoint=rocContent.append('circle').attr('class','roc-point').attr('r',6);
      rocPoint.append('title').text(STRINGS.tooltips?.rocPoint||'');

      const rocLineGenerator=d3.line().curve(d3.curveMonotoneX)
        .x(d=>rocXScale(d.fpr))
        .y(d=>rocYScale(d.tpr));

      rocPoint.call(d3.drag()
        .on('start',handleRocDrag)
        .on('drag',handleRocDrag)
        .on('end',()=>hideTooltip()))
        .on('mouseenter',event=>showTooltip(STRINGS.metrics.thresholdHandleTooltip(state.threshold),event))
        .on('mousemove',event=>showTooltip(STRINGS.metrics.thresholdHandleTooltip(state.threshold),event))
        .on('mouseleave',hideTooltip);

      const areaTooltips=STRINGS.metrics.areaTooltips;
      const addAreaTooltip=(path,label)=>{
        path.on('mousemove',event=>{if(path.attr('d')){showTooltip(label,event);}});
        path.on('mouseleave',hideTooltip);
      };
      addAreaTooltip(areaTPPath,areaTooltips.tp);
      addAreaTooltip(areaFNPath,areaTooltips.fn);
      addAreaTooltip(areaTNPath,areaTooltips.tn);
      addAreaTooltip(areaFPPath,areaTooltips.fp);

      function getDistributionKeys(){
        return DISTRIBUTION_KEYS.slice();
      }

      function generateParameterUI(def, component, onChange){
        const container=document.createElement('div');
        (def.parameters||[]).forEach(meta=>{
          const row=document.createElement('div');
          row.className='param-row';
          const label=document.createElement('label');
          label.textContent=meta.label||meta.id;
          label.style.minWidth='110px';
          row.appendChild(label);
          const paramId=meta.id;
          const setValue=(val)=>{
            component.parameters[paramId]=val;
            if(typeof onChange==='function'){onChange(paramId,val);}
          };
          const defaultVal=component.parameters[paramId]!==undefined?component.parameters[paramId]:meta.value;
          if(meta.slider){
            const controls=document.createElement('div');
            controls.className='parameter-controls';
            const slider=document.createElement('input');
            slider.type='range';
            slider.className='parameter-slider';
            const numeric=document.createElement('input');
            numeric.type='number';
            numeric.className='parameter-number';
            ['min','max','step'].forEach(attr=>{
              const val=meta.slider[attr]??meta[attr];
              if(val!==undefined){slider[attr]=val;}
            });
            ['min','max','step'].forEach(attr=>{
              const val=meta[attr];
              if(val!==undefined){numeric[attr]=val;}
            });
            slider.value=String(defaultVal);
            numeric.value=String(defaultVal);
            slider.addEventListener('input',e=>{
              const v=Number(e.target.value);
              if(Number.isFinite(v)){
                numeric.value=String(v);
                setValue(v);
              }
            });
            numeric.addEventListener('input',e=>{
              const v=Number(e.target.value);
              if(Number.isFinite(v)){
                slider.value=String(v);
                setValue(v);
              }
            });
            controls.appendChild(slider);
            controls.appendChild(numeric);
            row.appendChild(controls);
          } else {
            const input=document.createElement('input');
            input.type=meta.type||'number';
            if(meta.step!==undefined){input.step=meta.step;}
            if(meta.min!==undefined){input.min=meta.min;}
            if(meta.max!==undefined){input.max=meta.max;}
            input.value=String(defaultVal);
            input.addEventListener('input',e=>{
              const v=Number(e.target.value);
              if(Number.isFinite(v)){
                setValue(v);
              }
            });
            row.appendChild(input);
          }
          container.appendChild(row);
        });
        return container;
      }

      function normalizeWeightsForClass(className,{mutate=true}={}){
        if(!FEATURES.allowMultiComponents){return [];}
        const normalizedClass=(className||'').toLowerCase();
        let prefix=null;
        if(normalizedClass.startsWith('neg')){prefix='neg';}
        if(normalizedClass.startsWith('pos')){prefix='pos';}
        if(!prefix){return [];}
        const components=state[prefix+'Components']||[];
        if(!components.length){return [];}
        const normalized=ROCUtils.normalizeWeightsForClass(prefix==='neg'?'negative':'positive',components.map(c=>({...c})));
        if(mutate){
          normalized.forEach((norm,idx)=>{
            if(components[idx]){
              components[idx].weight=norm.weight;
            }
          });
        }
        return normalized;
      }

      function getNormalizedComponents(prefix){
        if(!FEATURES.allowMultiComponents){return state[prefix+'Components']||[];}
        const source=state[prefix+'Components']||[];
        if(source.length<=1){
          return source.map(comp=>({...comp,weight:1}));
        }
        const normalized=normalizeWeightsForClass(prefix==='neg'?'negative':'positive',{mutate:false});
        return normalized.length?normalized:source;
      }

      function getStudentTStats(parameters={}){
        const mu=Number(parameters.mu);
        const sigmaRaw=Number(parameters.sigma);
        const nu=Number(parameters.nu);
        const muVal=Number.isFinite(mu)?mu:0;
        const sigma=Math.max(Number.isFinite(sigmaRaw)?sigmaRaw:1,1e-6);
        const nuVal=Number.isFinite(nu)?nu:0;
        const isCauchy=nuVal>0 && nuVal<=1.01;
        let meanLabel='undefined';
        if(!isCauchy && nuVal>1){
          meanLabel=muVal.toFixed(3);
        }
        let varianceLabel='undefined';
        if(!isCauchy && nuVal>2){
          const variance=sigma*sigma*nuVal/(nuVal-2);
          varianceLabel=Number.isFinite(variance)?variance.toFixed(3):'∞';
        } else if(!isCauchy && nuVal>1){
          varianceLabel='∞';
        }
        return {meanLabel,varianceLabel,mu:muVal,sigma,nu:nuVal,isCauchy};
      }

      function refreshStudentTInfo(){
        ['neg','pos'].forEach(prefix=>{
          const components=state[prefix+'Components'];
          components.forEach((component,index)=>{
            const card=document.querySelector(`#${prefix}Params .component-card[data-component-index="${index}"]`);
            if(!card){return;}
            card.dataset.distribution=component.distribution;
            const infoEl=card.querySelector('[data-role="studentt-stats"]');
            const headerEl=card.querySelector('[data-role="component-header"]');
          const def=DISTRIBUTIONS_INTERNAL[component.distribution];
            const defaultLabel=(FEATURES.allowMultiComponents?`${STRINGS.multi.componentLabel(index)} — `:'')+(def?.label||component.distribution);
            if(component.distribution!=='studentT'){
              if(infoEl){
                infoEl.textContent='';
                infoEl.style.display='none';
              }
              if(headerEl){headerEl.textContent=defaultLabel;}
              card.removeAttribute('title');
              return;
            }
            if(headerEl){
              const nu=Number(component.parameters.nu);
              if(Number.isFinite(nu) && Math.abs(nu-1)<=0.01){
                const prefix=FEATURES.allowMultiComponents?`${STRINGS.multi.componentLabel(index)} — `:'';
                headerEl.textContent=`${prefix}Cauchy distribution (ν = 1)`;
              } else {
                headerEl.textContent=defaultLabel;
              }
            }
            if(infoEl){
              infoEl.style.display='';
              const stats=getStudentTStats(component.parameters);
              if(stats.isCauchy){
                const message='Mean and variance undefined for ν ≤ 1 (Cauchy).';
                infoEl.textContent=message;
                card.title=message;
              } else {
                infoEl.textContent=`Mean: ${stats.meanLabel} • Variance: ${stats.varianceLabel}`;
                card.title=`Student t — Mean: ${stats.meanLabel}, Variance: ${stats.varianceLabel}`;
              }
            }
          });
        });
      }

      function hasEmpiricalData(){
        return state.dataImported && (state.importedRawPos.length>0 || state.importedRawNeg.length>0);
      }

      function getProcessedEmpiricalSamples(){
        if(!hasEmpiricalData()){
      return {positives:[],negatives:[]};
    }
    const positives=[...state.importedRawPos];
    const negatives=[...state.importedRawNeg];
    return {positives,negatives};
  }

  function getProcessedEmpiricalPoints(){
    if(!hasEmpiricalData()){
      return [];
    }
    return state.empiricalPoints;
  }


      function refreshDataImportStatus(){
        const statusEl=document.getElementById('dataImportStatus');
        if(!hasEmpiricalData()){
          statusEl.textContent='No empirical data loaded.';
          return;
        }
        const positives=state.importedRawPos.length;
        const negatives=state.importedRawNeg.length;
        const name=state.imported.datasetName || currentEmpiricalDataset.name || state.importedDataFilename || 'dataset';
        if(state.simulatedDataActive){
          statusEl.textContent=`${name}: ${positives+negatives} simulated samples (${positives} positive, ${negatives} negative).`;
        } else {
          statusEl.textContent=`${name}: ${positives+negatives} samples imported (${positives} positive, ${negatives} negative).`;
        }
      }

      function refreshDatasetExportState(){
        const exportBtn=document.getElementById('dataExportButton');
        if(!exportBtn) return;
        exportBtn.style.display=currentEmpiricalDataset.source==='simulated'?'':'none';
      }

      function setDatasetName(name){
        const input=document.getElementById('datasetNameInput');
        if(input){input.value=name;}
        currentEmpiricalDataset.name=name;
      }

      function applyImportedData({positives,negatives,points,filename,simulated=false}){
        state.importedRawPos=positives;
        state.importedRawNeg=negatives;
        state.empiricalPoints=points;
        state.dataImported=true;
        state.importedDataFilename=filename||'dataset.csv';
        state.importedSampleCount=points.length;
        state.simulatedDataActive=Boolean(simulated);
        const fileInput=document.getElementById('dataImportInput');
        if(fileInput){fileInput.value='';}
        const previousSource=currentEmpiricalDataset.source;
        currentEmpiricalDataset.source=simulated?'simulated':'imported';
        if(simulated){
          const input=document.getElementById('datasetNameInput');
          const existing=(input?.value||'').trim();
          if(!existing || previousSource!=='simulated'){
            setDatasetName('simulated_dataset');
            state.imported.datasetName='simulated_dataset';
          }else{
            currentEmpiricalDataset.name=existing;
            state.imported.datasetName=existing;
          }
        }else{
          const defaultName=(filename||'dataset.csv').replace(/\.[^.]+$/, '')||'imported_dataset';
          setDatasetName(defaultName);
          state.imported.datasetName=defaultName;
        }
        state.imported.rows=points||[];
        state.imported.positives=positives||[];
        state.imported.negatives=negatives||[];
        const hist=computeSampleHistogramsFromSample(positives||[],negatives||[]);
        state.imported.histograms=hist;
        const rocCurve=ROCUtils.computeEmpiricalRocCurve(points||[],{name:`${state.imported.datasetName||'Empirical'} ROC`,id:'empirical'});
        state.imported.rocCurve=rocCurve;
        state.plots.histogramMode='empirical';
        refreshDatasetExportState();
        refreshDataImportStatus();
        refreshScoreLegend();
        refreshRocLegend();
        renderLegendSelection();
        update();
      }

      function applySimulatedData(posSamples,negSamples){
        const points=[
          ...posSamples.map(score=>({score,label:1})),
          ...negSamples.map(score=>({score,label:0}))
        ];
        applyImportedData({
          positives:posSamples,
          negatives:negSamples,
          points,
          filename:'simulated_in_memory.csv',
          simulated:true
        });
      }

      function getSampleCounts(){
        const N=Math.max(10,Number(document.getElementById('sampleSizeInput')?.value)||200);
        const p=clamp(state.prevalence,0,1);
        const nPos=Math.round(N*p);
        const nNeg=Math.max(0,N-nPos);
        return {N,nPos,nNeg};
      }

      function resampleFromState(force=false){
        if(!force && !state.simulatedDataActive){
          return;
        }
        const {nPos,nNeg}=getSampleCounts();
        const posSamples=sampleDistribution('pos',state.posComponents,nPos);
        const negSamples=sampleDistribution('neg',state.negComponents,nNeg);
        applySimulatedData(posSamples,negSamples);
      }

      async function maybeAutoResample(){
        if(state.autoResample && currentEmpiricalDataset.source==='simulated'){
          resampleFromState();
          await regenerateSampleRocs();
        }
      }
      async function regenerateSampleRocs(force=false){
        if(!force && !state.autoResample){return;}
        await withBusy(async ()=>{
          const numSamples=Math.max(1,Number(document.getElementById('numSamplesInput')?.value)||Number(state.samples?.numSamples)||1);
          const {nPos,nNeg}=getSampleCounts();
          const curves=[];
          let lastPosSamples=null;
          let lastNegSamples=null;
          for(let i=0;i<numSamples;i++){
            const posSamples=sampleDistribution('pos',state.posComponents,nPos);
            const negSamples=sampleDistribution('neg',state.negComponents,nNeg);
            lastPosSamples=posSamples;
            lastNegSamples=negSamples;
            const points=[
              ...posSamples.map(score=>({score,label:1})),
              ...negSamples.map(score=>({score,label:0}))
            ];
            const rocPoints=ROCUtils.computeEmpiricalRoc(points);
            if(rocPoints.length){
              const mapped=pointsToRocArrays(rocPoints);
              if(mapped){curves.push(mapped);}
            }
          }
          state.samplesROC=curves;
          if(lastPosSamples||lastNegSamples){
            state.samplesHist=computeSampleHistogramsFromSample(lastPosSamples||[],lastNegSamples||[]);
            if(state.rocBandMode==='delong'){
              const fprGrid=d3.range(0,1.000001,0.01);
              state.delongBand=ROCUtils.computeDelongTPRBand(lastPosSamples||[],lastNegSamples||[],fprGrid,1.96);
            } else {
              state.delongBand=null;
            }
          } else {
            state.samplesHist=null;
            state.delongBand=null;
          }
          if(state.rocBandMode==='bootstrap'){
            await computeConfidenceBand();
          } else {
            state.confBand=null;
          }
          state.estimatedCurve=computeEstimatedCurveFromSamples(state.samplesROC,state.confBand,state.delongBand,state.rocBandMode);
          state.samples.curves=state.samplesROC;
          state.samples.estimatedCurve=state.estimatedCurve;
          visibilityState.roc.sample={sampleCurves:true};
          state.samplesROC.forEach((_,idx)=>{visibilityState.roc.sample[idx]=true;});
          refreshRocLegend();
          update();
        });
      }

      async function computeConfidenceBand(){
        const samples=state.samplesROC||[];
        if(!samples.length){state.confBand=null;return;}
        if(state.rocBandMode!=='bootstrap'){state.confBand=null;return;}
        await withBusy(async ()=>{
          const fprGrid=d3.range(0,1.000001,0.01);
          const quantile=(arr,p)=>{
            if(!arr.length){return null;}
            const sorted=[...arr].sort((a,b)=>a-b);
            return d3.quantileSorted(sorted,p);
          };
          const interpolate=(fprArr,tprArr,x)=>{
            const n=fprArr.length;
            if(!n){return null;}
            if(x<=fprArr[0]){return tprArr[0];}
            if(x>=fprArr[n-1]){return tprArr[n-1];}
            const idx=d3.bisectLeft(fprArr,x);
            const x0=fprArr[idx-1],x1=fprArr[idx];
            const y0=tprArr[idx-1],y1=tprArr[idx];
            if(x1===x0){return y0;}
            const t=(x-x0)/(x1-x0);
            return y0+(y1-y0)*t;
          };
          const lower=[];
          const upper=[];
          fprGrid.forEach(fprVal=>{
            const values=[];
            samples.forEach(sample=>{
              const fpr=Array.isArray(sample.fpr)?sample.fpr:null;
              const tpr=Array.isArray(sample.tpr)?sample.tpr:null;
              if(!fpr||!tpr||fpr.length!==tpr.length||!fpr.length){return;}
              const v=interpolate(fpr,tpr,fprVal);
              if(Number.isFinite(v)){values.push(v);}
            });
            lower.push(quantile(values,0.025));
            upper.push(quantile(values,0.975));
          });
          lower.forEach((v,idx)=>{if(!Number.isFinite(v)){lower[idx]=0;}});
          upper.forEach((v,idx)=>{if(!Number.isFinite(v)){upper[idx]=1;}});
          state.confBand={fpr:fprGrid,lower,upper,method:'bootstrap',level:0.95,n_samples:samples.length};
        });
      }
      function parseEmpiricalCsv(text, filename){
        let parsed;
        try{
          parsed=d3.csvParse(text,d=>({
            score:+d.score,
            label:+d.label
          }));
        } catch(err){
          console.error(err);
          alert('Failed to parse CSV: '+err.message);
          return;
        }
        if(!parsed.length || !('score' in parsed[0]) || !('label' in parsed[0])){
          alert('CSV must contain columns: score, label');
          return;
        }
        const cleaned=parsed.filter(d=>Number.isFinite(d.score)&&(d.label===0||d.label===1));
        if(!cleaned.length){
          alert('No valid rows with numeric score and binary label were found.');
          return;
        }
        const positives=cleaned.filter(d=>d.label===1).map(d=>d.score);
        const negatives=cleaned.filter(d=>d.label===0).map(d=>d.score);
        applyImportedData({positives,negatives,points:cleaned,filename});
      }

      function handleDataFile(file){
        if(!file){return;}
        const reader=new FileReader();
        reader.onload=e=>{
          const text=e.target?.result;
          if(typeof text!=='string'){return;}
          parseEmpiricalCsv(text,file.name);
        };
        reader.readAsText(file);
      }

      function renderComponents(prefix){
        const container=document.getElementById(prefix+'Params');
        const allowMulti=FEATURES.allowMultiComponents;
        const distributionKeys=getDistributionKeys();
        if(!distributionKeys.length){container.textContent='No distributions configured.';return;}
        const components=state[prefix+'Components'];
        if(!components.length){components.push(cloneComponent({distribution:distributionKeys[0]}));}
        if(!allowMulti && components.length>1){components.splice(1);}
        container.innerHTML='';

        const list=document.createElement('div');
        list.className='component-list';
        components.forEach((component,index)=>{
          if(!DISTRIBUTIONS_INTERNAL[component.distribution]){
            component.distribution=distributionKeys[0];
            component.parameters=cloneComponent({distribution:distributionKeys[0]}).parameters;
          }
          const def=DISTRIBUTIONS_INTERNAL[component.distribution];
          const card=document.createElement('div');
          card.className='component-card';
          card.dataset.componentPrefix=prefix;
          card.dataset.componentIndex=String(index);
          card.dataset.distribution=component.distribution;

          const header=document.createElement('div');
          header.className='component-header';
          header.dataset.role='component-header';
          header.textContent=allowMulti?`${STRINGS.multi.componentLabel(index)} — ${def.label}`:def.label;
          card.appendChild(header);
          const canRemove=allowMulti && components.length>1 && index>0;
          if(canRemove){
            const removeRow=document.createElement('div');
            removeRow.className='component-remove-row';
            const removeBtn=document.createElement('button');
            removeBtn.type='button';
            removeBtn.className='component-remove-btn';
            removeBtn.textContent=STRINGS.distributions?.removeComponent?.label||'×';
            const tip=STRINGS.distributions?.removeComponent?.tooltip||STRINGS.multi.removeComponent;
            removeBtn.title=tip;
            removeBtn.setAttribute('aria-label',tip);
            removeBtn.addEventListener('click',()=>{
              components.splice(index,1);
              renderComponents(prefix);
              update();
              maybeAutoResample();
            });
            removeRow.appendChild(removeBtn);
            card.appendChild(removeRow);
          }

          const distRow=document.createElement('div');
          distRow.className='component-row';
          const distLabel=document.createElement('label');
          distLabel.textContent=STRINGS.controls.distributionLabel;
          const distSelect=document.createElement('select');
          distributionKeys.forEach(key=>{
            const opt=document.createElement('option');
            opt.value=key;
            opt.textContent=DISTRIBUTIONS_INTERNAL[key].label;
            distSelect.appendChild(opt);
          });
          distSelect.value=component.distribution;
            distSelect.addEventListener('change',event=>{
              if(isRestoringImportedState){return;}
              components[index]=cloneComponent({distribution:event.target.value,weight:component.weight});
              renderComponents(prefix);
              update();
              maybeAutoResample();
            });
          distRow.appendChild(distLabel);
          distRow.appendChild(distSelect);
          card.appendChild(distRow);

          if(allowMulti){
            const weightRow=document.createElement('div');
            weightRow.className='component-row';
            const weightLabel=document.createElement('label');
            weightLabel.textContent=STRINGS.multi.weight;
            const weightInput=document.createElement('input');
            weightInput.type='number';
            weightInput.step='0.01';
            weightInput.min='0';
            weightInput.value=component.weight??1;
            weightInput.addEventListener('input',event=>{
              const numeric=Number(event.target.value);
              component.weight=Number.isFinite(numeric)?numeric:0;
              update();
              maybeAutoResample();
            });
            weightRow.appendChild(weightLabel);
            weightRow.appendChild(weightInput);
            card.appendChild(weightRow);
          }

          const paramsUI=generateParameterUI(def,component,(id,val)=>{
            component.parameters[id]=val;
            update();
            maybeAutoResample();
          });
          card.appendChild(paramsUI);

          if(component.distribution==='studentT'){
            const info=document.createElement('div');
            info.className='component-info';
            info.dataset.role='studentt-stats';
            card.appendChild(info);
          }

          list.appendChild(card);
        });

        container.appendChild(list);

        if(allowMulti){
          const actionRow=document.createElement('div');
          actionRow.className='component-actions';

          if(components.length>=2){
            const normalizeBtn=document.createElement('button');
            normalizeBtn.type='button';
            normalizeBtn.className='add-component-btn';
            normalizeBtn.textContent=prefix==='pos'?'Normalize Positive Weights':'Normalize Negative Weights';
            normalizeBtn.addEventListener('click',()=>{
              normalizeWeightsForClass(prefix==='neg'?'negative':'positive',{mutate:true});
              renderComponents(prefix);
              update();
              maybeAutoResample();
            });
            actionRow.appendChild(normalizeBtn);
          }

          if(!FEATURES.maxComponents || components.length<FEATURES.maxComponents){
            const addBtn=document.createElement('button');
            addBtn.type='button';
            addBtn.className='add-component-btn';
            addBtn.textContent=STRINGS.multi.addComponent;
            addBtn.addEventListener('click',()=>{
              components.push(cloneComponent({distribution:getDistributionKeys()[0],weight:1}));
              renderComponents(prefix);
              update();
              maybeAutoResample();
            });
            actionRow.insertBefore(addBtn, actionRow.firstChild);
          }

          if(actionRow.childElementCount>0){
            container.appendChild(actionRow);
          }
        }
      }

      function sanitizePDF(value){return Number.isFinite(value)&&value>=0?value:0;}
      function clamp(val,min,max){return Math.min(Math.max(val,min),max);}
      function disableUiDuringBusy(disabled){
        const controls=document.querySelectorAll('input,button,select,textarea');
        controls.forEach(el=>{
          if(disabled){
            el.setAttribute('data-prev-disabled',el.disabled);
            el.disabled=true;
          } else {
            const prev=el.getAttribute('data-prev-disabled');
            if(prev==="true"){el.disabled=true;}else{el.disabled=false;}
            el.removeAttribute('data-prev-disabled');
          }
        });
      }

      function setBusy(flag){
        state.busy=Boolean(flag);
        if(state.busy){
          console.debug('[Busy] Activating spinner');
        } else {
          console.debug('[Busy] Deactivating spinner');
        }
        document.body.classList.toggle('busy',state.busy);
        const overlay=document.getElementById('busyOverlay');
        if(overlay){overlay.style.display=state.busy?'flex':'none';}
        disableUiDuringBusy(state.busy);
      }

      async function withBusy(fn){
        setBusy(true);
        // Allow DOM to paint spinner before heavy work (use animation frame)
        await new Promise(requestAnimationFrame);
        try{
          return await fn();
        }finally{
          setBusy(false);
        }
      }

      function buildDistribution(prefix){
        const allowMulti=FEATURES.allowMultiComponents;
        const components=allowMulti?getNormalizedComponents(prefix):(state[prefix+'Components']||[]);
        const resolved=components.map(component=>{
          const def=DISTRIBUTIONS_INTERNAL[component.distribution];
          const params=def.mapper?def.mapper(component.parameters):component.parameters;
          const domain=def.domain?def.domain(params):[-5,5];
          const weight=allowMulti?(Math.max(Number(component.weight)||0,0)||0):1;
          return {def,params,weight:allowMulti?weight:1,domain};
        });
        if(!allowMulti||resolved.length===1){
          resolved.forEach(item=>item.weight=1);
        }
        let minDomain=Math.min(...resolved.map(item=>item.domain[0]));
        let maxDomain=Math.max(...resolved.map(item=>item.domain[1]));
        if(!Number.isFinite(minDomain)){minDomain=0;}
        if(!Number.isFinite(maxDomain)){maxDomain=minDomain+1;}
        if(maxDomain<=minDomain){maxDomain=minDomain+1;}
        return {
          pdf:x=>resolved.reduce((sum,item)=>sum+item.weight*item.def.pdf(item.params,x),0),
          cdf:x=>resolved.reduce((sum,item)=>sum+item.weight*item.def.cdf(item.params,x),0),
          domain:[minDomain,maxDomain]
        };
      }

      function update(){
        const pos=buildDistribution('pos');
        const neg=buildDistribution('neg');
        refreshStudentTInfo();

        const empiricalSamples=getProcessedEmpiricalSamples();
        const hasEmpiricalSamples=empiricalSamples.positives.length>0||empiricalSamples.negatives.length>0;
        const fprGrid=d3.range(0,1.000001,0.01);
        if(!(hasEmpiricalSamples && state.rocBandMode==='delong')){
          state.delongBand=null;
        }
        const hasSampleHist=state.samplesHist && Array.isArray(state.samplesHist.positives) && Array.isArray(state.samplesHist.negatives);
        const empiricalPointList=hasEmpiricalSamples?getProcessedEmpiricalPoints():[];

        let minX=Math.min(pos.domain[0],neg.domain[0]);
        let maxX=Math.max(pos.domain[1],neg.domain[1]);
        if(hasSampleHist && Array.isArray(state.samplesHist.domain)){
          const [dMin,dMax]=state.samplesHist.domain;
          if(Number.isFinite(dMin)&&Number.isFinite(dMax)){
            minX=Math.min(minX,dMin);
            maxX=Math.max(maxX,dMax);
          }
        }
        if(hasEmpiricalSamples){
          const combined=[...empiricalSamples.positives,...empiricalSamples.negatives];
          if(combined.length){
            const dataMin=Math.min(...combined);
            const dataMax=Math.max(...combined);
            if(Number.isFinite(dataMin)&&Number.isFinite(dataMax)){
              minX=Math.min(minX,dataMin);
              maxX=Math.max(maxX,dataMax);
            }
          }
        }
        if(!Number.isFinite(minX)||!Number.isFinite(maxX)){minX=0;maxX=1;}
        if(maxX<=minX){maxX=minX+1;}

        state.domain=[minX,maxX];
        if(!state.thresholdInitialized){
        state.threshold=clamp(Number(state.theoretical?.threshold??DEFAULT_OPTIONS.threshold??(minX+maxX)/2)||((minX+maxX)/2),minX,maxX);
        state.thresholdInitialized=true;
      } else if(state.threshold<minX || state.threshold>maxX){
        state.threshold=clamp((minX+maxX)/2,minX,maxX);
      }
        const threshold=state.threshold;
        thresholdInput.value=threshold.toFixed(3);
        state.theoretical.threshold=state.threshold;
        state.theoretical.prevalence=state.prevalence;
        state.theoretical.positive=state.posComponents;
        state.theoretical.negative=state.negComponents;

        const N=500;
        const xs=Array.from({length:N},(_,i)=>minX+(maxX-minX)*i/(N-1));
        if(!xs.some(x=>Math.abs(x-threshold)<1e-8)){
          xs.push(threshold);
          xs.sort((a,b)=>a-b);
        }

        const dataPoints=xs.map(x=>{
          const posPDF=sanitizePDF(pos.pdf(x));
          const negPDF=sanitizePDF(neg.pdf(x));
          return {x,posPDF,negPDF,posCDF:clamp(pos.cdf(x),0,1),negCDF:clamp(neg.cdf(x),0,1)};
        });
        state.dataPoints=dataPoints;

        const theoreticalMax=d3.max(dataPoints,d=>Math.max(d.posPDF,d.negPDF))||0;
        let histPosData=[];
        let histNegData=[];
        let histMaxDensity=0;
        const histMode=state.plots.histogramMode||'sample';
        const empiricalHistData=state.imported.histograms;
        let histActive=false;
        if(histMode==='empirical' && hasEmpiricalData() && empiricalHistData && (visibilityState.score.posHist||visibilityState.score.negHist)){
          const toDensity=bins=>{
            return (bins||[]).map(bin=>{
              const density=Number(bin.density)||0;
              histMaxDensity=Math.max(histMaxDensity,density);
              return {...bin,density};
            });
          };
          histPosData=toDensity(empiricalHistData.positives);
          histNegData=toDensity(empiricalHistData.negatives);
          histActive=true;
        } else if(histMode==='sample' && hasSampleHist && (visibilityState.score.posHist||visibilityState.score.negHist)){
          const toDensity=(bins)=>{
            return bins.map(bin=>{
              const width=(bin.x1??bin.x0)-(bin.x0??bin.x1);
              const density=width>0?(bin.density ?? 0):0;
              histMaxDensity=Math.max(histMaxDensity,density);
              return {...bin,density};
            });
          };
          histPosData=toDensity(state.samplesHist.positives||[]);
          histNegData=toDensity(state.samplesHist.negatives||[]);
          histActive=true;
        }

        const yMax=Math.max(theoreticalMax,histMaxDensity);
        const yUpper=yMax>0?yMax*1.05:1;
        distXScale.domain([minX,maxX]);
        distYScale.domain([0,yUpper]);
        distXAxisGroup.call(d3.axisBottom(distXScale));
        distYAxisGroup.call(d3.axisLeft(distYScale));

        const renderUniformRect=(rectEl,lineEl,distKey)=>{
          const comps=state[distKey+'Components']||[];
          const first=comps[0];
          const isUniform=first && first.distribution==='uniform';
          if(!isUniform){return false;}
          const params=first.parameters||{};
          const min=Math.min(Number(params.min)||0,Number(params.max)||0);
          const max=Math.max(Number(params.min)||0,Number(params.max)||0);
          const width=max-min;
          if(width<=0){rectEl.style('display','none');lineEl.style('display','none');return true;}
          const height=1/width;
          rectEl
            .style('display',visibilityState.score[distKey==='pos'?'posPDF':'negPDF']?null:'none')
            .attr('x',distXScale(min))
            .attr('width',distXScale(max)-distXScale(min))
            .attr('y',distYScale(height))
            .attr('height',distYScale(0)-distYScale(height))
            .attr('fill',distKey==='pos'?COLOR_HELPERS.posPdfFill:COLOR_HELPERS.negPdfFill)
            .attr('stroke',distKey==='pos'?COLOR_HELPERS.posPdf:COLOR_HELPERS.negPdf);
          lineEl.style('display','none').attr('d',null);
          return true;
        };

        const usedPosRect=renderUniformRect(distPosRect,distPosLinePath,'pos');
        const usedNegRect=renderUniformRect(distNegRect,distNegLinePath,'neg');

        if(!usedPosRect){
          if(visibilityState.score.posPDF){
            distPosLinePath
              .style('display',null)
              .attr('fill',COLOR_HELPERS.posPdfFill)
              .attr('stroke',COLOR_HELPERS.posPdf)
              .datum(dataPoints).attr('d',distPosLineGenerator);
            distPosRect.style('display','none');
          } else {
            distPosLinePath.style('display','none').attr('d',null);
            distPosRect.style('display','none');
          }
        }
        if(!usedNegRect){
          if(visibilityState.score.negPDF){
            distNegLinePath
              .style('display',null)
              .attr('fill',COLOR_HELPERS.negPdfFill)
              .attr('stroke',COLOR_HELPERS.negPdf)
              .datum(dataPoints).attr('d',distNegLineGenerator);
            distNegRect.style('display','none');
          } else {
            distNegLinePath.style('display','none').attr('d',null);
            distNegRect.style('display','none');
          }
        }

        const renderHist=(group,data,className)=>{
          const selection=group.selectAll('rect').data(data);
          selection.join(
            enter=>enter.append('rect').attr('class',className),
            update=>update,
            exit=>exit.remove()
          )
          .attr('x',d=>distXScale(d.x0))
          .attr('width',d=>{
            const w=distXScale(d.x1)-distXScale(d.x0);
            return Number.isFinite(w)&&w>0?w:0;
          })
          .attr('y',d=>distYScale(d.density))
          .attr('height',d=>Math.max(0,distYScale(0)-distYScale(d.density)));
        };

        if(histActive){
          const showPos = visibilityState.score.posHist!==false;
          const showNeg = visibilityState.score.negHist!==false;
          if(showPos){
            histPosGroup.style('display',null);
            renderHist(histPosGroup,histPosData,'hist-pos-bar');
          } else {
            histPosGroup.selectAll('rect').remove();
            histPosGroup.style('display','none');
          }
          if(showNeg){
            histNegGroup.style('display',null);
            renderHist(histNegGroup,histNegData,'hist-neg-bar');
          } else {
            histNegGroup.selectAll('rect').remove();
            histNegGroup.style('display','none');
          }
        } else {
          histPosGroup.selectAll('rect').remove();
          histNegGroup.selectAll('rect').remove();
          histPosGroup.style('display','none');
          histNegGroup.style('display','none');
        }

        const pointsActive=visibilityState.score.empiricalPoints && hasEmpiricalSamples;
        const rugHeight=8;
        const baseY=distYScale.range()[0];
        const renderRugLines=(group,data)=>{
          group.style('display',null);
          group.selectAll('line')
            .data(data,(_,i)=>i)
            .join(
              enter=>enter.append('line'),
              update=>update,
              exit=>exit.remove()
            )
            .attr('x1',d=>distXScale(d.score))
            .attr('x2',d=>distXScale(d.score))
            .attr('y1',baseY)
            .attr('y2',baseY-rugHeight);
        };
        if(pointsActive){
          const positivePoints=[];
          const negativePoints=[];
          empiricalPointList.forEach(pt=>{
            const score=Number(pt.score);
            if(!Number.isFinite(score)) return;
            const clampedScore=clamp(score,minX,maxX);
            if(Number(pt.label)===1){
              positivePoints.push({score:clampedScore});
            }else{
              negativePoints.push({score:clampedScore});
            }
          });
          renderRugLines(rugPosGroup,positivePoints);
          renderRugLines(rugNegGroup,negativePoints);
        }else{
          rugPosGroup.selectAll('line').remove();
          rugNegGroup.selectAll('line').remove();
          rugPosGroup.style('display','none');
          rugNegGroup.style('display','none');
        }

        const posLeft=dataPoints.filter(d=>d.x<=threshold).map(d=>({x:d.x,y:d.posPDF}));
        const posRight=dataPoints.filter(d=>d.x>=threshold).map(d=>({x:d.x,y:d.posPDF}));
        const negLeft=dataPoints.filter(d=>d.x<=threshold).map(d=>({x:d.x,y:d.negPDF}));
        const negRight=dataPoints.filter(d=>d.x>=threshold).map(d=>({x:d.x,y:d.negPDF}));

        const setArea=(path,data)=>{path.attr('d',data.length>=2?distAreaGenerator(data):null);};
        setArea(areaTNPath,negLeft);
        setArea(areaFPPath,negRight);
        setArea(areaFNPath,posLeft);
        setArea(areaTPPath,posRight);

        thresholdLine
          .attr('x1',distXScale(threshold))
          .attr('x2',distXScale(threshold))
          .attr('y1',distYScale.range()[0])
          .attr('y2',distYScale.range()[1])
          .raise();
        thresholdHandle
          .attr('cx',distXScale(threshold))
          .attr('cy',distYScale.range()[1]-10)
          .raise();

        const rocPairs=dataPoints.map(d=>({thr:d.x,fpr:1-d.negCDF,tpr:1-d.posCDF}));
        const rocSorted=ROCUtils.ensureMonotoneRoc(rocPairs);
        state.rocPairs=rocPairs;
        state.rocPairsSorted=rocSorted;
        const auc=ROCUtils.computeAuc(rocSorted);
        rocTitle.text(STRINGS.plots.rocTitle(auc));

        const sampleCurves=(state.samplesROC||[]).map((entry,idx)=>{
          if(!entry || typeof entry!=='object'){return null;}
          const fpr=Array.isArray(entry.fpr)?entry.fpr:null;
          const tpr=Array.isArray(entry.tpr)?entry.tpr:null;
          if(!fpr||!tpr||fpr.length!==tpr.length||!fpr.length){return null;}
          const points=fpr.map((f,i)=>({fpr:Number(f),tpr:Number(tpr[i])})).filter(pt=>Number.isFinite(pt.fpr)&&Number.isFinite(pt.tpr));
          if(points.length!==fpr.length){return null;}
          return {key:idx,points};
        }).filter(Boolean);
        const samplePaths=rocSampleGroup.selectAll('path.sample-roc')
          .data(sampleCurves,d=>d.key);
        samplePaths.exit().remove();
        samplePaths.enter()
          .append('path')
          .attr('class','sample-roc')
          .merge(samplePaths)
          .attr('d',d=>rocLineGenerator(d.points))
          .attr('stroke',COLOR_HELPERS.sample)
          .attr('stroke-width',1)
          .attr('fill','none')
          .style('display',()=>{
            const visible=state.plots.showSampleRocCurves;
            return visible===false?'none':null;
          })
          .lower();

        if(state.estimatedCurve && state.plots.showEstimatedCurve!==false){
          const estPoints=(state.estimatedCurve.fpr||[]).map((fprVal,idx)=>({fpr:fprVal,tpr:state.estimatedCurve.tpr[idx]})).filter(pt=>Number.isFinite(pt.fpr)&&Number.isFinite(pt.tpr));
          if(estPoints.length>=2){
            estimatedRocPath
              .style('display',null)
              .datum(estPoints)
              .attr('d',rocLineGenerator)
              .attr('stroke',COLOR_HELPERS.estimated)
              .attr('stroke-width',2)
              .attr('fill','none');
          } else {
            estimatedRocPath.style('display','none').attr('d',null);
          }
        } else {
          estimatedRocPath.style('display','none').attr('d',null);
        }

        const drawRocBand=(band,prefix,color)=>{
          const visible=state.plots.showConfidenceBands!==false && state.plots.showEstimatedCurve!==false && state.rocBandMode===prefix && band && Array.isArray(band.fpr) && Array.isArray(band.lower) && Array.isArray(band.upper);
          const bandData=visible?band.fpr.map((fprVal,idx)=>({
            fpr:fprVal,
            lower:band.lower[idx],
            upper:band.upper[idx]
          })).filter(d=>Number.isFinite(d.lower)&&Number.isFinite(d.upper)):[];
          const areaGen=d3.area().curve(d3.curveMonotoneX)
            .x(d=>rocXScale(d.fpr))
            .y0(d=>rocYScale(d.lower))
            .y1(d=>rocYScale(d.upper));
          const lowerLine=d3.line().curve(d3.curveMonotoneX)
            .x(d=>rocXScale(d.fpr))
            .y(d=>rocYScale(d.lower));
          const upperLine=d3.line().curve(d3.curveMonotoneX)
            .x(d=>rocXScale(d.fpr))
            .y(d=>rocYScale(d.upper));
          const areaSel=rocBandGroup.selectAll(`path.band-${prefix}-area`).data(bandData.length?[bandData]:[]);
          areaSel.exit().remove();
          areaSel.enter().append('path').attr('class',`band-${prefix}-area`).merge(areaSel)
            .attr('d',d=>areaGen(d))
            .attr('fill',color)
            .attr('opacity',0.18);
          const lowerSel=rocBandGroup.selectAll(`path.band-${prefix}-lower`).data(bandData.length?[bandData]:[]);
          lowerSel.exit().remove();
          lowerSel.enter().append('path').attr('class',`band-${prefix}-lower`).merge(lowerSel)
            .attr('d',d=>lowerLine(d))
            .attr('stroke',color)
            .attr('stroke-width',1)
            .attr('fill','none');
          const upperSel=rocBandGroup.selectAll(`path.band-${prefix}-upper`).data(bandData.length?[bandData]:[]);
          upperSel.exit().remove();
          upperSel.enter().append('path').attr('class',`band-${prefix}-upper`).merge(upperSel)
            .attr('d',d=>upperLine(d))
            .attr('stroke',color)
            .attr('stroke-width',1)
            .attr('fill','none');
        };

        const findBand=(method)=>{
          if(state.estimatedCurve?.bands){
            const match=state.estimatedCurve.bands.find(b=>b.method===method);
            if(match){return match;}
          }
          return method==='bootstrap'?state.confBand:method==='delong'?state.delongBand:null;
        };
        if(state.plots.showConfidenceBands!==false){
          if(state.rocBandMode==='bootstrap'){
            drawRocBand(findBand('bootstrap'),'bootstrap',COLOR_HELPERS.sample);
            drawRocBand(null,'delong',COLOR_HELPERS.sample);
          } else if(state.rocBandMode==='delong'){
            drawRocBand(null,'bootstrap',COLOR_HELPERS.sample);
            drawRocBand(findBand('delong'),'delong',COLOR_HELPERS.sample);
          } else {
            drawRocBand(null,'bootstrap',COLOR_HELPERS.sample);
            drawRocBand(null,'delong',COLOR_HELPERS.sample);
          }
        } else {
          drawRocBand(null,'bootstrap',COLOR_HELPERS.sample);
          drawRocBand(null,'delong',COLOR_HELPERS.sample);
        }

        if(visibilityState.roc.theoretical && rocSorted.length>=2){
          rocLinePath.style('display',null).datum(rocSorted).attr('d',rocLineGenerator);
        } else {
          rocLinePath.style('display','none').attr('d',null);
        }
        rocXAxisGroup.call(d3.axisBottom(rocXScale).ticks(6));
        rocYAxisGroup.call(d3.axisLeft(rocYScale).ticks(6));

        const empiricalCurve=state.imported.rocCurve;
        if(state.plots.showEmpiricalRocCurve!==false && empiricalCurve && Array.isArray(empiricalCurve.fpr) && Array.isArray(empiricalCurve.tpr) && empiricalCurve.fpr.length===empiricalCurve.tpr.length && empiricalCurve.fpr.length>=2){
          const empiricalPoints=empiricalCurve.fpr.map((fprVal,idx)=>({fpr:fprVal,tpr:empiricalCurve.tpr[idx]})).filter(pt=>Number.isFinite(pt.fpr)&&Number.isFinite(pt.tpr));
          if(empiricalPoints.length>=2){
            empiricalRocPath.datum(empiricalPoints).attr('d',rocLineGenerator).style('opacity',1).raise();
          } else {
            empiricalRocPath.attr('d',null).style('opacity',0);
          }
        } else {
          empiricalRocPath.attr('d',null).style('opacity',0);
        }

        const thrPoint=rocPairs.reduce((prev,curr)=>Math.abs(curr.thr-threshold)<Math.abs(prev.thr-threshold)?curr:prev,rocPairs[0]);
        rocPoint.attr('cx',rocXScale(thrPoint.fpr)).attr('cy',rocYScale(thrPoint.tpr)).raise();

        renderThresholdMetrics(thrPoint);
        renderPrevalenceMetrics(thrPoint);

        renderLegendSelection();
      }

      function handleDrag(event){
        const [x]=d3.pointer(event,distContent.node());
        const domainX=distXScale.invert(x);
        if(!Number.isFinite(domainX)){return;}
        const clamped=clamp(domainX,state.domain[0],state.domain[1]);
        if(Math.abs(clamped-state.threshold)<1e-6){return;}
        state.thresholdInitialized=true;
        state.threshold=clamped;
        thresholdInput.value=clamped.toFixed(3);
        update();
        showTooltip(STRINGS.metrics.thresholdHandleTooltip(state.threshold),event.sourceEvent||event);
      }

      function handleRocDrag(event){
        const pool=state.rocPairsSorted.length?state.rocPairsSorted:state.rocPairs;
        if(!pool.length){return;}
        const [x]=d3.pointer(event,rocContent.node());
        const targetFpr=clamp(rocXScale.invert(x),0,1);
        const closest=pool.reduce((prev,curr)=>Math.abs(curr.fpr-targetFpr)<Math.abs(prev.fpr-targetFpr)?curr:prev,pool[0]);
        if(Math.abs(closest.thr-state.threshold)>1e-6){
          state.thresholdInitialized=true;
          state.threshold=closest.thr;
          thresholdInput.value=closest.thr.toFixed(3);
          update();
        }
        showTooltip(STRINGS.metrics.thresholdHandleTooltip(state.threshold),event.sourceEvent||event);
      }

      function handleThresholdInput(event){
        const numeric=Number(event.target.value);
        if(!Number.isFinite(numeric)){event.target.value=state.threshold.toFixed(3);return;}
        state.thresholdInitialized=true;
        state.threshold=clamp(numeric,state.domain[0],state.domain[1]);
        update();
      }

      thresholdInput.addEventListener('change',handleThresholdInput);
      thresholdInput.addEventListener('keypress',event=>{
        if(event.key==='Enter'){event.preventDefault();handleThresholdInput(event);} });

      prevalenceSlider.addEventListener('input',event=>{
        const numeric=Number(event.target.value);
        state.prevalence=clamp(numeric,0,1);
        prevalenceValEl.textContent=STRINGS.controls.prevalenceValue(state.prevalence);
        update();
        maybeAutoResample();
      });

      const datasetNameInput=document.getElementById('datasetNameInput');
      if(datasetNameInput){
        datasetNameInput.title=STRINGS.tooltips?.datasetName||'';
        datasetNameInput.addEventListener('input',event=>{
          currentEmpiricalDataset.name=event.target.value.trim();
          refreshDataImportStatus();
        });
        setDatasetName(datasetNameInput.value || 'simulated_dataset');
      }else{
        setDatasetName('simulated_dataset');
      }
      refreshDatasetExportState();
      refreshDataImportStatus();

      document.getElementById('dataExportButton').addEventListener('click', exportDataset);
      const dataExportButton=document.getElementById('dataExportButton');
      if(dataExportButton){dataExportButton.title=STRINGS.tooltips?.datasetExport||'';}
      const rocExportJsonButton=document.getElementById('rocExportJsonButton');
      const rocExportCsvButton=document.getElementById('rocExportCsvButton');
      const rocImportButton=document.getElementById('rocImportJsonButton');
      const rocImportFile=document.getElementById('rocImportFile');
      if(rocExportJsonButton){
        rocExportJsonButton.addEventListener('click', exportRocAsJson);
      }
      if(rocExportCsvButton){
        const showCsvButton=ROC_CONFIG.showAdvancedRocCsvExport !== false;
        rocExportCsvButton.style.display=showCsvButton?'block':'none';
        if(showCsvButton){
          rocExportCsvButton.addEventListener('click', exportRocAsCsv);
        }
      }
      if(rocImportButton && rocImportFile){
        rocImportButton.addEventListener('click',()=>{
          rocImportFile.value='';
          rocImportFile.click();
        });
        rocImportFile.addEventListener('change',event=>{
          const file=event.target.files?.[0];
          if(file){
            const reader=new FileReader();
            reader.onload=e=>{
              try{
                const text=e.target?.result;
                if(typeof text!=='string'){throw new Error('File read failed');}
                const {data}=ROCUtils.parseRocDataFromText(text,file.name);
                handleImportedRocData(data);
              }catch(err){
                alert('Failed to import ROC JSON: '+(err?.message||err));
              }
            };
            reader.readAsText(file);
          }
        });
      }

      function sampleDistribution(prefix, components, nSamples) {
        const samples = [];
        const allowMulti = FEATURES.allowMultiComponents;
        const normalized = allowMulti ? getNormalizedComponents(prefix) : components;
        const totalWeight = allowMulti
          ? normalized.reduce((a, c) => a + (c.weight || 0), 0)
          : 1;

        for (const comp of normalized) {
          const def = DISTRIBUTIONS_INTERNAL[comp.distribution];
          const w = allowMulti ? (comp.weight || 0) / totalWeight : 1;
          const nComp = Math.max(1, Math.round(w * nSamples));
          const params = def.mapper ? def.mapper(comp.parameters) : comp.parameters;

          // Try direct sampling via jStat
          let sampler;
          if (comp.distribution === 'studentT') {
            const mu = Number(params.mu) || 0;
            const sigma = Math.max(Number(params.sigma) || 0, 1e-6);
            const nu = Number(params.nu);
            if (Number.isFinite(nu) && nu <= 1.01) {
              if (jStat.cauchy && jStat.cauchy.sample) {
                sampler = () => jStat.cauchy.sample(mu, sigma);
              } else {
                sampler = () => mu + sigma * Math.tan(Math.PI * (Math.random() - 0.5));
              }
            } else {
              const safeNu = Math.max(nu || 0, 1.01);
              sampler = () => mu + sigma * jStat.studentt.sample(safeNu);
            }
          } else if (jStat[comp.distribution] && jStat[comp.distribution].sample) {
            const vals = Object.values(params);
            sampler = () => jStat[comp.distribution].sample(...vals);
          } else {
            // fallback: inverse-CDF sampling
            sampler = () => {
              const u = Math.random();
              const [lo0, hi0] = def.domain(params);
              let lo = lo0, hi = hi0;
              for (let i = 0; i < 25; i++) {
                const mid = (lo + hi) / 2;
                if (def.cdf(params, mid) < u) lo = mid; else hi = mid;
              }
              return (lo + hi) / 2;
            };
          }

          for (let i = 0; i < nComp; i++) samples.push(sampler());
        }
        return samples;
      }

      function exportDataset() {
        const N = Math.max(10, Number(document.getElementById('sampleSizeInput').value) || 200);
        const prevalence = state.prevalence;
        const nPos = Math.round(N * prevalence);
        const nNeg = N - nPos;

      const posSamples = sampleDistribution('pos', state.posComponents, nPos);
      const negSamples = sampleDistribution('neg', state.negComponents, nNeg);

        applySimulatedData(posSamples, negSamples);

        const rows = [
          ['score', 'label'],
          ...posSamples.map(s => [s.toFixed(6), 1]),
          ...negSamples.map(s => [s.toFixed(6), 0])
        ];

        const csv = rows.map(r => r.join(',')).join('\n');
        const blob = new Blob([csv], { type: 'text/csv' });
        const url = URL.createObjectURL(blob);

        const datasetName = (currentEmpiricalDataset.name || 'simulated_dataset').trim() || 'simulated_dataset';
        const a = document.createElement('a');
        a.href = url;
        a.download = `${datasetName}.csv`;
        a.click();
        URL.revokeObjectURL(url);

        document.getElementById('exportStatus').textContent =
          `Exported ${datasetName} with ${N} samples (${nPos} positive, ${nNeg} negative).`;
      }

      function getExportCurveName(){
        const input=document.getElementById('rocExportName');
        if(!input){
          return 'exported_curve';
        }
        const trimmed=(input.value||'').trim();
        if(!trimmed){
          input.value='exported_curve';
          return 'exported_curve';
        }
        return trimmed;
      }

      function snapshotDistributions(){
        const cloneComponentData=comp=>{
          if(!comp || typeof comp.distribution!=='string' || !comp.distribution.trim()){
            throw new Error('Component is missing a valid distribution id for export.');
          }
          if(!DISTRIBUTIONS_INTERNAL[comp.distribution]){
            console.error('Unknown distribution key during export:', comp.distribution);
            throw new Error(`Unknown distribution key during export: ${comp.distribution}`);
          }
          return {
            distribution:comp.distribution,
            weight:comp.weight,
            parameters:{...comp.parameters}
          };
        };
        return {
          positives:(state.posComponents||[]).map(cloneComponentData),
          negatives:(state.negComponents||[]).map(cloneComponentData)
        };
      }

      function computeEmpiricalHistograms(minX,maxX){
        const hasData=hasEmpiricalData();
        if(!hasData){
          return {positives:[],negatives:[],domain:[minX,maxX],binCount:0};
        }
        const positives=state.importedRawPos;
        const negatives=state.importedRawNeg;
        const total=Math.max(positives.length+negatives.length,1);
        const binCount=Math.min(40,Math.max(10,Math.round(Math.sqrt(total))));
        const binGenerator=(d3.histogram?d3.histogram():d3.bin()).domain([minX,maxX]).thresholds(binCount);
        const toDensity=(bins,totalCount)=>bins.map(bin=>{
          const width=(bin.x1??bin.x0)-(bin.x0??bin.x1);
          const density=(totalCount>0 && width>0)?bin.length/(totalCount*width):0;
          return {x0:bin.x0,x1:bin.x1,density};
        });
        const posBins=positives.length?toDensity(binGenerator(positives),positives.length):[];
        const negBins=negatives.length?toDensity(binGenerator(negatives),negatives.length):[];
        return {positives:posBins,negatives:negBins,domain:[minX,maxX],binCount};
      }

      function computeSampleHistogramsFromSample(posScores,negScores){
        const positives=Array.isArray(posScores)?posScores.map(Number).filter(Number.isFinite):[];
        const negatives=Array.isArray(negScores)?negScores.map(Number).filter(Number.isFinite):[];
        if(!positives.length && !negatives.length){
          return {positives:[],negatives:[],domain:[0,1],binCount:0};
        }
        const minX=Math.min(...positives,...negatives);
        const maxX=Math.max(...positives,...negatives);
        const total=Math.max(positives.length+negatives.length,1);
        const binCount=Math.min(40,Math.max(10,Math.round(Math.sqrt(total))));
        const binGenerator=(d3.histogram?d3.histogram():d3.bin()).domain([minX,maxX]).thresholds(binCount);
        const toDensity=(bins,totalCount)=>bins.map(bin=>{
          const width=(bin.x1??bin.x0)-(bin.x0??bin.x1);
          const density=(totalCount>0 && width>0)?bin.length/(totalCount*width):0;
          return {x0:bin.x0,x1:bin.x1,density};
        });
        const posBins=positives.length?toDensity(binGenerator(positives),positives.length):[];
        const negBins=negatives.length?toDensity(binGenerator(negatives),negatives.length):[];
        return {positives:posBins,negatives:negBins,domain:[minX,maxX],binCount};
      }

      function computeEstimatedCurveFromSamples(samples, bootstrapBand, delongBand, mode){
        if(!Array.isArray(samples) || !samples.length){return null;}
        const fprGrid=d3.range(0,1.000001,0.01);
        const interpolate=(fprArr,tprArr,x)=>{
          const n=fprArr.length;
          if(!n){return null;}
          if(x<=fprArr[0]){return tprArr[0];}
          if(x>=fprArr[n-1]){return tprArr[n-1];}
          const idx=d3.bisectLeft(fprArr,x);
          const x0=fprArr[idx-1],x1=fprArr[idx];
          const y0=tprArr[idx-1],y1=tprArr[idx];
          if(x1===x0){return y0;}
          const t=(x-x0)/(x1-x0);
          return y0+(y1-y0)*t;
        };
        const tpr=[];
        fprGrid.forEach(fpr=>{
          const vals=[];
          samples.forEach(sample=>{
            const fprArr=sample.fpr;
            const tprArr=sample.tpr;
            if(!Array.isArray(fprArr)||!Array.isArray(tprArr)||fprArr.length!==tprArr.length||!fprArr.length){return;}
            const v=interpolate(fprArr,tprArr,fpr);
            if(Number.isFinite(v)){vals.push(v);}
          });
          if(vals.length){
            const mean=vals.reduce((a,b)=>a+b,0)/vals.length;
            tpr.push(mean);
          } else {
            tpr.push(0);
          }
        });
        const points=fprGrid.map((f,i)=>({fpr:f,tpr:tpr[i]}));
        const bands=[];
        if(mode==='bootstrap' && bootstrapBand){
          bands.push({...bootstrapBand,level:0.95,method:'bootstrap',n_samples:samples.length});
        } else if(mode==='delong' && delongBand){
          bands.push({...delongBand,level:0.95,method:'delong',n_samples:samples.length});
        }
        return {fpr:fprGrid,tpr,bands,auc:ROCUtils.computeAuc(points)};
      }

      function pointsToRocArrays(points){
        if(!Array.isArray(points)||!points.length){return null;}
        const fpr=[];
        const tpr=[];
        const thr=[];
        points.forEach(pt=>{
          const f=Number(pt?.fpr);
          const t=Number(pt?.tpr);
          const h=pt?.thr;
          if(Number.isFinite(f)&&Number.isFinite(t)){
            fpr.push(f);
            tpr.push(t);
            thr.push(Number.isFinite(Number(h))?Number(h):null);
          }
        });
        if(!fpr.length||fpr.length!==tpr.length){return null;}
        const hasThr=thr.some(v=>v!==null);
        return hasThr?{fpr,tpr,thr}:{fpr,tpr};
      }

      function buildContinuousMetadata(curveName, auc, minX, maxX, empiricalPointList){
        const distributions=snapshotDistributions();
        const samplingSettings={
          prevalence:state.prevalence,
          sampleSize:Number(document.getElementById('sampleSizeInput')?.value)||200,
          autoResample:state.autoResample,
          dataImported:state.dataImported,
          datasetName:currentEmpiricalDataset.name||null,
          importedSampleCount:state.importedSampleCount||0
        };
        const samplesROC=empiricalPointList?.length?ROCUtils.computeEmpiricalRoc(empiricalPointList):[];
        const samplesArray=[];
        const sampleObject=pointsToRocArrays(samplesROC);
        if(sampleObject){samplesArray.push(sampleObject);}
        const samplesHist=computeEmpiricalHistograms(minX,maxX);
        return {
          name:curveName,
          auc,
          distributions,
          samplingSettings,
          samplesROC:state.samplesROC||samplesArray,
          samplesHist
        };
      }

      function applyImportedContinuousMetadata(curve){
        if(!curve){return false;}
        const meta=ROCUtils.extractContinuousRocMetadata(curve);
        if(!meta){
          state.samplesROC=[];
          state.samplesHist=null;
          visibilityState.roc.sample={sampleCurves:true};
          state.samples={curves:[],estimatedCurve:null};
          refreshRocLegend();
          renderLegendSelection();
          return false;
        }
        state.samplesROC=Array.isArray(meta.samplesROC)?meta.samplesROC:[];
        state.samplesHist=meta.samplesHist||null;
        visibilityState.roc.sample={sampleCurves:true};
        state.samplesROC.forEach((_,idx)=>{
          visibilityState.roc.sample[idx]=true;
        });
        state.samples.curves=state.samplesROC;
        computeConfidenceBand();
        refreshRocLegend();
        renderLegendSelection();
        let applied=false;
        isRestoringImportedState=true;
        try{
          const coerceComponents=(arr)=>{
            if(!Array.isArray(arr)){return null;}
            const collection=[];
            arr.forEach(entry=>{
              const distKey=typeof entry.distribution==='string'?entry.distribution.trim():'';
              if(!distKey){
                console.warn('Skipping component with missing distribution key during import.', entry);
                return;
              }
              if(!DISTRIBUTIONS_INTERNAL[distKey]){
                console.warn('Skipping unknown distribution key during import:', distKey);
                return;
              }
              if(typeof entry.weight!=='number' || Number.isNaN(entry.weight)){
                console.warn('Skipping component with invalid weight during import.', entry);
                return;
              }
              if(!entry.parameters || typeof entry.parameters!=='object'){
                console.warn('Skipping component with invalid parameters during import.', entry);
                return;
              }
              const cloned=cloneComponent({distribution:distKey,parameters:entry.parameters,weight:entry.weight});
              collection.push(cloned);
            });
            return collection.length?collection:null;
          };
          if(meta.distributions){
            const pos=meta.distributions.positives;
            const neg=meta.distributions.negatives;
            const posComponents=coerceComponents(pos);
            const negComponents=coerceComponents(neg);
            if(posComponents){
              state.posComponents=posComponents;
              applied=true;
            }
            if(negComponents){
              state.negComponents=negComponents;
              applied=true;
            }
          }
          if(meta.samplingSettings){
            if(meta.samplingSettings.prevalence!==undefined){
              const p=Number(meta.samplingSettings.prevalence);
              if(Number.isFinite(p)){
                state.prevalence=clamp(p,0,1);
                prevalenceSlider.value=state.prevalence;
                prevalenceValEl.textContent=STRINGS.controls.prevalenceValue(state.prevalence);
                applied=true;
              }
            }
            if(meta.samplingSettings.sampleSize!==undefined){
              const input=document.getElementById('sampleSizeInput');
              const val=Number(meta.samplingSettings.sampleSize);
              if(input && Number.isFinite(val) && val>0){
                input.value=val;
                applied=true;
              }
            }
            if(meta.samplingSettings.autoResample!==undefined){
              state.autoResample=Boolean(meta.samplingSettings.autoResample);
              const autoToggle=document.getElementById('autoResampleToggle');
              if(autoToggle){autoToggle.checked=state.autoResample;}
              applied=true;
            }
          }
          if(Array.isArray(meta.samplesROC)){
            state.samplesROC=meta.samplesROC;
            state.samplesROC.forEach((_,idx)=>{
              const key=`sample_${idx}`;
              if(!visibilityState.roc.sample){visibilityState.roc.sample={};}
              if(visibilityState.roc.sample[key]===undefined){visibilityState.roc.sample[key]=true;}
            });
            refreshRocLegend();
            applied=true;
          } else {
            state.samplesROC=[];
            if(visibilityState.roc.sample){visibilityState.roc.sample={};}
            refreshRocLegend();
          }
          if(meta.roc && meta.roc.name){
            const name=String(meta.roc.name);
            const nameInput=document.getElementById('rocExportName');
            if(nameInput){
              nameInput.value=name;
            }
            applied=true;
          }
          resetVisibilityState();
          if(applied){
            renderComponents('neg');
            renderComponents('pos');
            update();
          }
          return applied;
        } finally {
          isRestoringImportedState=false;
        }
      }

      function getPreferredRocPoints(){
        const rocPoints=(state.rocPairsSorted&&state.rocPairsSorted.length?state.rocPairsSorted:state.rocPairs)||[];
        if(rocPoints.length>=2){
          return {points:rocPoints,source:'continuous'};
        }
        return null;
      }

      function buildCanonicalExportCurve(curveName){
        const selection=getPreferredRocPoints();
        if(!selection){
          throw new Error('No ROC curve available to export.');
        }
        const fpr=[];
        const tpr=[];
        selection.points.forEach(point=>{
          const fVal=Number(point.fpr);
          const tVal=Number(point.tpr);
          if(!Number.isFinite(fVal) || !Number.isFinite(tVal)){
            throw new Error('ROC curve contains invalid values.');
          }
          fpr.push(fVal);
          tpr.push(tVal);
        });
        if(!fpr.length){
          throw new Error('ROC curve is empty.');
        }
        const theoreticalName=`${curveName} (theoretical)`;
        const empiricalSamples=getProcessedEmpiricalSamples();
        const hasEmpiricalSamples=empiricalSamples.positives.length>0||empiricalSamples.negatives.length>0;
        const empiricalPointList=hasEmpiricalSamples?getProcessedEmpiricalPoints():[];
        const metadata=buildContinuousMetadata(
          curveName,
          ROCUtils.computeAuc(selection.points),
          state.domain?.[0],
          state.domain?.[1],
          empiricalPointList
        );
        const theoreticalCurve={
          id:theoreticalName,
          name:theoreticalName,
          role:'theoretical',
          type:'ROC',
          fpr,
          tpr,
          auc:ROCUtils.computeAuc(selection.points),
          metadata:{continuous_roc_explorer:metadata}
        };
        const curves=[theoreticalCurve];
        if(state.estimatedCurve && Array.isArray(state.estimatedCurve.fpr) && Array.isArray(state.estimatedCurve.tpr) && state.estimatedCurve.fpr.length===state.estimatedCurve.tpr.length && state.estimatedCurve.fpr.length){
          const estimatedName=`${curveName} (estimated)`;
          const estCurve={
            id:estimatedName,
            name:estimatedName,
            role:'estimated',
            type:'ROC',
            fpr:state.estimatedCurve.fpr,
            tpr:state.estimatedCurve.tpr,
            auc:ROCUtils.computeAuc(state.estimatedCurve.fpr.map((fprVal,idx)=>({fpr:fprVal,tpr:state.estimatedCurve.tpr[idx]}))),
            bands:state.estimatedCurve.bands||[],
            metadata:{
              continuous_roc_explorer:{
                samplesROC:metadata.samplesROC,
                samplingSettings:metadata.samplingSettings,
                distributions:metadata.distributions
              }
            }
          };
          curves.push(estCurve);
        }
        return {curves,source:selection.source};
      }

      function downloadBlob(blob,filename){
        const url=URL.createObjectURL(blob);
        const link=document.createElement('a');
        link.href=url;
        link.download=filename;
        link.click();
        URL.revokeObjectURL(url);
      }

      function exportRocAsJson(){
        const statusEl=document.getElementById('exportStatus');
        const curveName=getExportCurveName();
        try{
          const {curves}=buildCanonicalExportCurve(curveName);
          const canonicalMap=ROCUtils.exportCurvesToJson(curves);
          const blob=ROCUtils.toRocJsonBlob(canonicalMap,`${curveName}.json`);
          downloadBlob(blob,`${curveName}.json`);
          if(statusEl){
            statusEl.textContent=`Exported ${curveName} as JSON.`;
          }
        }catch(err){
          console.error(err);
          if(statusEl){
            statusEl.textContent=err.message||'Failed to export ROC JSON.';
          }
        }
      }

      function exportRocAsCsv(){
        const statusEl=document.getElementById('exportStatus');
        const curveName=getExportCurveName();
        try{
          const {canonicalCurve}=buildCanonicalExportCurve(curveName);
          const canonicalMap={[curveName]:canonicalCurve};
          const csvText=ROCUtils.rocToCsv(canonicalMap);
          const blob=new Blob([csvText],{type:'text/csv'});
          downloadBlob(blob,`${curveName}.csv`);
          if(statusEl){
            statusEl.textContent=`Exported ${curveName} as CSV.`;
          }
        }catch(err){
          console.error(err);
          if(statusEl){
            statusEl.textContent=err.message||'Failed to export ROC CSV.';
          }
        }
      }

      function handleImportedRocData(curveMap){
        try{
          const curves=ROCUtils.importCurvesFromJson(curveMap);
          let applied=false;
          let estimatedApplied=false;
          curves.forEach(curve=>{
            const name=curve.name||'';
            if(name.endsWith('(theoretical)') && curve.metadata?.continuous_roc_explorer){
              const ok=applyImportedContinuousMetadata({metadata:{continuous_roc_explorer:curve.metadata.continuous_roc_explorer}});
              applied=applied||ok;
            } else if(name.endsWith('(estimated)')){
              state.estimatedCurve={
                fpr:curve.fpr||[],
                tpr:curve.tpr||[],
                bands:curve.bands||[]
              };
              if(curve.bands && curve.bands.length){
                const band=curve.bands[0];
                if(band.method==='bootstrap'){state.confBand=band;state.rocBandMode='bootstrap';}
                if(band.method==='delong'){state.delongBand=band;state.rocBandMode='delong';}
              }
      visibilityState.roc.estimated=true;
      estimatedApplied=true;
    }
  });
          refreshRocLegend();
          renderLegendSelection();
          update();
          alert(`Imported ${curves.length} ROC curve${curves.length===1?'':'s'}.`);
        }catch(err){
          console.error(err);
          alert('Failed to import ROC JSON.');
        }
      }

      renderComponents('neg');
      renderComponents('pos');
      update();
      window.applyContinuousRocMetadata=applyImportedContinuousMetadata;
    });
  </script>
</body>
</html>
