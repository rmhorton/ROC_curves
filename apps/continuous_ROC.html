<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Continuous ROC Explorer</title>
  <script src="https://cdn.jsdelivr.net/npm/jstat@latest/dist/jstat.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/d3@7"></script>
  <script src="jstat_extra.js"></script>
  <script src="continuous_ROC_config.js"></script>
  <script src="ROC_lib.js"></script>
  <style>
    body{font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif;margin:18px;background:#fcfcff;color:#21213a}
    body.busy{cursor:progress!important}
    body.busy *{cursor:progress!important}
    h2{margin:0 0 6px 0;font-size:24px;font-weight:650;color:#1e1e31}
    p.description{margin:0 0 18px 0;font-size:14px;color:#515172}
    .controls{display:grid;grid-template-columns:repeat(auto-fit,minmax(320px,1fr));gap:18px;margin-bottom:22px}
    .ctrl{background:#f5f5fd;border:1px solid #e2e2f2;border-radius:14px;padding:14px;box-shadow:0 1px 3px rgba(15,15,35,0.08)}
    .ctrl h3{margin:0 0 10px 0;font-size:16px;font-weight:600;color:#2d2d48}
    .component-list{display:flex;flex-direction:column;gap:12px}
    .component-card{background:#fff;border:1px solid #d9d9ea;border-radius:10px;padding:10px}
    .component-header{display:flex;justify-content:space-between;align-items:center;font-size:13px;font-weight:600;color:#2f2f50;margin-bottom:8px}
    .component-remove-row{display:flex;justify-content:flex-end;margin-bottom:6px}
    .component-controls{display:flex;align-items:center;gap:6px;margin-left:8px}
    .component-controls button,.add-component-btn{background:#ececf9;border:1px solid #cfcfe4;border-radius:6px;padding:4px 8px;font-size:12px;cursor:pointer;color:#383856}
    .component-controls button:hover,.add-component-btn:hover{background:#dedef4}
    .component-remove-btn{min-width:120px;padding:6px 10px;text-align:center;background:#ffeaea;border-color:#e0a3a3;color:#a41a1a;font-weight:700;border-radius:8px}
    .component-remove-btn:hover{background:#ffd8d8}
    .param-row{display:flex;align-items:center;gap:8px;margin:6px 0;font-size:13px;color:#30304a}
    .component-row{display:flex;align-items:center;gap:8px;margin:6px 0;font-size:13px;color:#30304a}
    .component-row label{min-width:110px}
    .component-row input:not([type=range]),.component-row select{flex:1;padding:5px 6px;border-radius:6px;border:1px solid #c6c6db;font-size:13px}
    .component-row input[type=range]{flex:1}
    .parameter-controls{flex:1;display:flex;align-items:center;gap:8px}
    .parameter-number{width:80px;flex:0 0 auto;padding:5px 6px;border-radius:6px;border:1px solid #c6c6db;font-size:13px}
    .parameter-slider{flex:1}
    .component-info{font-size:12px;color:#4e4e70;margin:4px 0 0 110px}
    .empirical-group rect{stroke:none}
    .hist-pos-bar{}
    .hist-neg-bar{}
    #empiricalPanel{display:flex;flex-direction:column;gap:10px;font-size:13px;color:#30304a}
    #dataImportDropZone{border:1px dashed #8a8ac5;border-radius:10px;padding:10px;text-align:center;background:#f5f5fd;cursor:pointer;transition:background 0.2s,border-color 0.2s}
    #dataImportDropZone.dragover{background:#e7e7fb;border-color:#5c5cb8}
    #dataImportStatus{font-size:12px;color:#4e4e70}
    .data-import-options{display:flex;flex-direction:column;gap:6px}
    .data-import-options label{display:flex;align-items:center;gap:6px;font-size:12px;color:#3a3a5a}
    .plot-with-legend{position:relative}
    .rug-pos line{stroke-width:1.2;opacity:0.75}
    .rug-neg line{stroke-width:1.2;opacity:0.75}
    .roc-empirical{stroke-width:2;fill:none;stroke-dasharray:5 4}
    .roc-bands path{vector-effect:non-scaling-stroke}
    .legend-bar{display:flex;flex-wrap:wrap;gap:10px;margin-top:10px;font-size:12px;color:#30304a}
    #rocLegend{display:flex;flex-wrap:wrap;gap:6px 12px;max-width:540px;align-items:flex-start}
    #rocLegend .legend-item{flex:0 0 auto;white-space:nowrap;display:flex;align-items:center;min-width:120px}
    .legend-item{display:flex;align-items:center;gap:6px;padding:6px 10px;border:1px solid #dcdcee;border-radius:8px;cursor:pointer;user-select:none;background:#f9f9ff;transition:background 0.15s,border-color 0.15s,opacity 0.15s}
    .legend-item:hover{background:#f0f0ff}
    .legend-item.inactive{opacity:0.45;background:#f4f4f7}
    .legend-swatch{width:14px;height:14px;border-radius:3px;flex:0 0 auto;border:1px solid #d1d1e0}
    .sim-options{display:flex;flex-direction:column;gap:6px;margin-top:10px;font-size:12px;color:#3a3a5a}
    .sim-options label{display:flex;align-items:center;gap:6px}
    .add-component-btn{margin-top:0;padding:6px 10px}
    #busyOverlay{position:fixed;inset:0;background:rgba(255,255,255,0.65);display:none;align-items:center;justify-content:center;z-index:9999}
    #busySpinner{width:48px;height:48px;border:5px solid rgba(0,0,0,0.1);border-top-color:#4a4a90;border-radius:50%;animation:spin 1s linear infinite}
    @keyframes spin{to{transform:rotate(360deg)}}
    /*
    .plots{display:flex;flex-wrap:wrap;gap:20px;margin-bottom:50px}
    .plot-block{flex:1;min-width:360px}
    #distPlot,#rocPlot{width:100%;height:420px}
    #rocPlot{max-width:540px}
    #rocPlot svg{max-width:540px;width:100%;height:auto}
    .roc-samples path{vector-effect:non-scaling-stroke}
    #rocLegend{flex-wrap:wrap;max-width:540px}
    #thresholdArea{display:flex;flex-wrap:wrap;gap:40px;align-items:flex-start;margin-bottom:28px}
    #thresholdControl,#prevalenceControl{flex:1;min-width:280px}
    #thresholdControl .hint{font-size:12px;color:#60607a;margin-top:6px}
    */ 
    /* --- Layout Stability Patch --- */

/* Keep plots on one line, allow horizontal scroll if needed */
.plots {
  display: flex;
  flex-wrap: nowrap;           /* prevent wrapping */
  flex-direction: row;
  justify-content: space-between;
  align-items: flex-start;
  gap: 24px;
  margin-bottom: 60px;
  overflow-x: auto;            /* enable scroll instead of overlap */
  overflow-y: visible;
}

/* Ensure each plot maintains its full height */
.plot-block {
  flex: 0 0 auto;              /* prevent shrinking */
  min-width: 520px;            /* fits standard aspect ratio */
}

/* Prevent threshold + prevalence areas from collapsing or overlapping */
#thresholdArea {
  display: flex;
  flex-wrap: nowrap;           /* keep them side by side */
  align-items: flex-start;
  justify-content: space-between;
  gap: 40px;
  margin-bottom: 32px;
  overflow-x: auto;
  overflow-y: visible;
}

/* Ensure internal panels resize properly and stay visible */
#thresholdControl,
    #prevalenceControl {
      flex: 0 0 auto;
      min-width: 340px;
      background: #fafaff;
      border: 1px solid #ddddee;
  border-radius: 10px;
  padding: 12px;
  box-shadow: 0 1px 3px rgba(15,15,35,0.08);
}

/* Optional: constrain entire app width for cleaner screenshots */
body {
  max-width: 1400px;
  margin: auto;
  background-color: #ffffff;
}

/* --- End of Layout Patch --- */
    .threshold-input{display:flex;flex-direction:column;gap:6px;margin-top:8px;font-size:13px;color:#32324e}
    .threshold-input input{width:140px;padding:5px 6px;border-radius:6px;border:1px solid #c8c8dc}
    #prevalenceControl{display:flex;align-items:center;gap:8px;font-size:13px;color:#30304a}
    #prevalenceControl input[type=range]{flex:1}
    .component-actions{display:flex;gap:8px;flex-wrap:wrap;margin-top:10px}
    table{border-collapse:collapse;margin-top:12px;font-size:13px}
    th,td{border:1px solid #d7d7e8;padding:4px 10px;text-align:center}
    .chart-title{font-size:16px;font-weight:600;fill:#202038}
    .axis-label{font-size:13px;fill:#4a4a66}
    .pdf-line-positive{stroke-width:2.4;}
    .pdf-line-negative{stroke-width:2.4;}
    .area-tp{fill:rgba(54,184,84,0.28);stroke:none}
    .area-fn{fill:rgba(220,67,67,0.30);stroke:none}
    .area-tn{fill:rgba(54,184,84,0.28);stroke:none;opacity:0.75}
    .area-fp{fill:rgba(220,67,67,0.30);stroke:none;opacity:0.75}
    .roc-point, .threshold-handle{fill:#1a73ff;stroke:#fff;stroke-width:2;cursor:grab}
    .threshold-line{stroke:#1b1b32;stroke-width:2;stroke-dasharray:6 4;cursor:ew-resize}
    .roc-point:active, .threshold-handle:active{cursor:grabbing}
    .roc-line{stroke:#30307c;stroke-width:2.5;fill:none}
    .roc-random{stroke:#a0a0ba;stroke-width:1.4;stroke-dasharray:4 4;fill:none}
  </style>
  <!--  
   .roc-point{fill:#d62728;stroke:#fff;stroke-width:1.6;cursor:pointer}-->
</head>
<body>
  <h2 id="pageTitle">Continuous ROC Explorer</h2>
  <p class="description" id="pageIntro"></p>

  <div class="controls">
    <div id="distParamContainer" class="dist-param-container">
      <div class="ctrl" id="negControl">
        <h3 id="negTitle">Negatives</h3>
        <div id="negParams"></div>
      </div>
      <div class="ctrl" id="posControl">
        <h3 id="posTitle">Positives</h3>
        <div id="posParams"></div>
      </div>
    </div>
  </div>

  <div class="plots">
    <div class="plot-block">
      <div class="plot-with-legend">
        <div id="distPlot"></div>
      </div>
      <div id="scoreLegend" class="legend-bar"></div>
    </div>
    <div class="plot-block">
      <div id="rocPlot"></div>
      <div id="rocLegend" class="legend-bar"></div>
    </div>
  </div>

  <div id="thresholdArea">
    <div id="thresholdControl">
      <div id="thresholdLabel">Threshold: <span id="thresholdVal">0.50</span></div>
      <div class="threshold-input">
        <label for="thresholdInput" id="thresholdInputLabel">Set exact threshold:</label>
        <input type="number" id="thresholdInput" step="0.001" value="0.5">
      </div>
      <div class="hint" id="thresholdHint"></div>
      <div id="metrics"></div>
    </div>
    <div id="prevalenceControl">
      <label for="prevalenceSlider" id="prevalenceLabel">Prevalence:</label>
      <input type="range" id="prevalenceSlider" min="0" max="1" step="0.01" value="0.5">
      <span id="prevalenceVal">0.50</span>
      <div id="metricsPrev"></div>
    </div>
    <div id="empiricalPanel" class="ctrl">
      <h3>Empirical Dataset</h3>
      <div class="component-row">
        <label for="datasetNameInput">Dataset name:</label>
        <input type="text" id="datasetNameInput" value="simulated_dataset">
      </div>
      <div class="component-row">
        <label for="sampleSizeInput">Sample size:</label>
        <input type="number" id="sampleSizeInput" value="200" min="10" step="10">
      </div>
      <div class="component-row">
        <label for="numSamplesInput"># samples (ROC reps):</label>
        <input type="number" id="numSamplesInput" value="20" min="1" step="1">
      </div>
      <button id="resampleButton" style="margin-top:10px;">New sample</button>
      <div id="dataImportDropZone" style="margin-top:14px;">
        <label for="dataImportInput">Load empirical data (scores + labels):</label>
        <input type="file" id="dataImportInput" accept=".csv" style="margin-top:6px;">
        <div style="font-size:11px;color:#666;margin-top:6px;">Drop a CSV here or use the file picker. Required columns: <code>score</code>, <code>label</code>.</div>
      </div>
      <div id="dataImportStatus">No empirical data loaded.</div>
      <button id="dataExportButton" style="margin-top:10px;">Export Dataset CSV</button>
      <div id="exportStatus" style="font-size:12px;color:#666;margin-top:6px;"></div>
      <div class="sim-options">
        <label><input type="checkbox" id="autoResampleToggle">Auto-resample on parameter change</label>
      </div>
    </div>
      <div id="rocPanel" class="ctrl">
        <h3>ROC Curves</h3>
        <div class="component-row">
          <label for="rocExportName">Curve name:</label>
          <input type="text" id="rocExportName" value="exported_curve">
        </div>
        <div class="component-row">
          <label for="rocBandMode">Confidence band:</label>
          <select id="rocBandMode">
            <option value="none">None</option>
            <option value="bootstrap">Bootstrap</option>
            <option value="delong">DeLong</option>
          </select>
        </div>
        <button id="rocExportJsonButton" style="margin-top:10px;">Export ROC (JSON)</button>
        <button id="rocExportCsvButton" style="margin-top:10px;">Export ROC (CSV – human readable)</button>
        <button id="rocImportJsonButton" style="margin-top:10px;">Import ROC JSON…</button>
        <input type="file" id="rocImportFile" accept=".json,application/json" style="display:none">
      </div>
  </div>
  <div id="busyOverlay"><div id="busySpinner"></div></div>

  <script>
    window.addEventListener('DOMContentLoaded',()=>{
      const CONFIG=window.MULTIDISTRIBUTION_CONFIG||{};
      const {STRINGS,FEATURES,DISTRIBUTIONS,DISTRIBUTION_ORDER,DEFAULT_OPTIONS}=CONFIG;
      const ROC_CONFIG=window.ROC_EXPLORER_CONFIG||{};
      let isRestoringImportedState=false;
      const visibilityState={
        score:{
          posPDF:true,
          negPDF:true,
          posHist:DEFAULT_OPTIONS.showEmpiricalHistogram??true,
          negHist:DEFAULT_OPTIONS.showEmpiricalHistogram??true,
          empiricalPoints:DEFAULT_OPTIONS.showEmpiricalPoints??false
        },
        roc:{
          theoretical:true,
          empirical:DEFAULT_OPTIONS.showEmpiricalRoc??false,
          confidenceBand:true,
          estimated:true,
          sample:{}
        }
      };
      let currentEmpiricalDataset={name:'simulated_dataset', source:'simulated'};
      window.currentEmpiricalDataset=currentEmpiricalDataset;
      if(!STRINGS||!FEATURES||!DISTRIBUTIONS||!DISTRIBUTION_ORDER||!DEFAULT_OPTIONS){
        document.body.innerHTML='<p style="color:#a20000">Configuration not found. Ensure multidistribution_config.js is loaded.</p>';
        return;
      }
      const DISTRIBUTIONS_INTERNAL=Object.fromEntries(
        Object.entries(DISTRIBUTIONS||{}).map(([key,def])=>{
          const trimmed=String(key||'').trim();
          return trimmed?[trimmed,def]:null;
        }).filter(Boolean)
      );
      const DISTRIBUTION_KEYS=Array.isArray(DISTRIBUTION_ORDER)
        ? DISTRIBUTION_ORDER.map(key=>String(key||'').trim()).filter(key=>DISTRIBUTIONS_INTERNAL[key])
        : Object.keys(DISTRIBUTIONS_INTERNAL);
      if(!DISTRIBUTION_KEYS.length){
        document.body.innerHTML='<p style="color:#a20000">No distributions configured. Check multidistribution_config.js.</p>';
        return;
      }

      const DEFAULT_COLOR_CONFIG={
        positive:{hue:'#1f77b4',histogramOpacity:0.4,rugOpacity:0.75,pdfOpacity:1,rocOpacity:1},
        negative:{hue:'#d62728',histogramOpacity:0.4,rugOpacity:0.75,pdfOpacity:1,rocOpacity:1},
        sample:{hue:'#7d3cff',opacity:0.7},
        empirical:{hue:'#7d3cff',opacity:1},
        randomRoc:{hue:'#30307c',opacity:1},
        confidenceBand:{hue:'#7d3cff',opacity:0.18,strokeOpacity:1},
        positiveCurveFill:{hue:'#1f77b4',opacity:0.08},
        negativeCurveFill:{hue:'#d62728',opacity:0.08},
        estimatedCurve:{hue:'#17becf',opacity:1}
      };

      function resolveColorConfig(source){
        const result={
          positive:{...DEFAULT_COLOR_CONFIG.positive},
          negative:{...DEFAULT_COLOR_CONFIG.negative},
          sample:{...DEFAULT_COLOR_CONFIG.sample},
          empirical:{...DEFAULT_COLOR_CONFIG.empirical},
          randomRoc:{...DEFAULT_COLOR_CONFIG.randomRoc},
          confidenceBand:{...DEFAULT_COLOR_CONFIG.confidenceBand},
          positiveCurveFill:{...DEFAULT_COLOR_CONFIG.positiveCurveFill},
          negativeCurveFill:{...DEFAULT_COLOR_CONFIG.negativeCurveFill},
          estimatedCurve:{...DEFAULT_COLOR_CONFIG.estimatedCurve}
        };
        ['positive','negative'].forEach(key=>{
          const entry=source?.[key];
          if(!entry){return;}
          if(typeof entry.hue==='string' && entry.hue.trim()){result[key].hue=entry.hue;}
          ['histogramOpacity','rugOpacity','pdfOpacity','rocOpacity'].forEach(field=>{
            const val=Number(entry[field]);
            if(Number.isFinite(val)){result[key][field]=val;}
          });
        });
        ['sample','empirical','randomRoc','confidenceBand','positiveCurveFill','negativeCurveFill'].forEach(key=>{
          const entry=source?.[key];
          if(!entry){return;}
          if(typeof entry.hue==='string' && entry.hue.trim()){result[key].hue=entry.hue;}
          if(entry.opacity!==undefined){
            const val=Number(entry.opacity);
            if(Number.isFinite(val)){result[key].opacity=val;}
          }
          if(entry.strokeOpacity!==undefined){
            const val=Number(entry.strokeOpacity);
            if(Number.isFinite(val)){result[key].strokeOpacity=val;}
          }
        });
        return result;
      }

      function getColor(key, fallback='#000'){
        const entry=COLOR_CONFIG?.[key];
        if(!entry){return fallback;}
        if(entry.hue){
          const opacity=entry.opacity!==undefined?entry.opacity:1;
          return ROCUtils.hexOpacityToRgba(entry.hue,opacity);
        }
        return fallback;
      }

      function applyColorStyles(colors){
        const toRgba=ROCUtils.hexOpacityToRgba;
        document.querySelectorAll('style[data-role="color-theme"]').forEach(node=>node.remove());
        const css=`
.hist-pos-bar{fill:${getColor('positive', '#1f77b4')};opacity:${colors?.positive?.histogramOpacity??0.4};}
.hist-neg-bar{fill:${getColor('negative', '#d62728')};opacity:${colors?.negative?.histogramOpacity??0.4};}
.rug-pos line{stroke:${getColor('positive', '#1f77b4')};opacity:${colors?.positive?.rugOpacity??0.75};}
.rug-neg line{stroke:${getColor('negative', '#d62728')};opacity:${colors?.negative?.rugOpacity??0.75};}
.legend-pos{background:${getColor('positive', '#1f77b4')};opacity:${colors?.positive?.histogramOpacity??0.4};}
.legend-neg{background:${getColor('negative', '#d62728')};opacity:${colors?.negative?.histogramOpacity??0.4};}
.pdf-line-positive{stroke:${getColor('positive', '#1f77b4')};fill:${getColor('positiveCurveFill','#1f77b4')};opacity:${colors?.positive?.pdfOpacity??1};}
.pdf-line-negative{stroke:${getColor('negative', '#d62728')};fill:${getColor('negativeCurveFill','#d62728')};opacity:${colors?.negative?.pdfOpacity??1};}
`;
        const styleEl=document.createElement('style');
        styleEl.setAttribute('data-role','color-theme');
        styleEl.textContent=css;
        document.head.appendChild(styleEl);
      }

      const COLOR_CONFIG=resolveColorConfig(CONFIG.COLORS);
      applyColorStyles(COLOR_CONFIG);
const COLOR_HELPERS={
        posPdf:getColor('positive', '#1f77b4'),
        negPdf:getColor('negative', '#d62728'),
        posPdfFill:getColor('positiveCurveFill', '#1f77b4'),
        negPdfFill:getColor('negativeCurveFill', '#d62728'),
        posHist:getColor('positive', '#1f77b4'),
        negHist:getColor('negative', '#d62728'),
        posRug:getColor('positive', '#1f77b4'),
        negRug:getColor('negative', '#d62728'),
        empirical:getColor('empirical', '#7d3cff'),
        roc:getColor('randomRoc', '#30307c'),
        sample:getColor('sample', '#7d3cff'),
        estimated:getColor('estimatedCurve', '#17becf'),
        confBandFill:()=>ROCUtils.hexOpacityToRgba(COLOR_CONFIG.confidenceBand?.hue||'#7d3cff',COLOR_CONFIG.confidenceBand?.opacity??0.18),
        confBandStroke:getColor('confidenceBand', '#7d3cff')
      };

      const scoreLegendContainer=document.getElementById('scoreLegend');
      const rocLegendContainer=document.getElementById('rocLegend');
      const scoreLegendItems=[
        {key:'posPDF',label:'Positive PDF',color:COLOR_HELPERS.posPdfFill},
        {key:'negPDF',label:'Negative PDF',color:COLOR_HELPERS.negPdfFill},
        {key:'posHist',label:'Positive histogram',color:COLOR_HELPERS.posHist},
        {key:'negHist',label:'Negative histogram',color:COLOR_HELPERS.negHist},
        {key:'empiricalPoints',label:'Empirical points',color:COLOR_HELPERS.empirical}
      ];
      const baseRocLegendItems=[
        {key:'theoretical',label:'Theoretical ROC',color:COLOR_HELPERS.roc},
        {key:'estimated',label:'Estimated ROC',color:COLOR_HELPERS.estimated},
        {key:'sampleCurves',label:'Sample ROC Curves',color:COLOR_HELPERS.sample},
        {key:'confidenceBand',label:'Confidence band',color:COLOR_HELPERS.sample}
      ];

      function buildLegend(container, items, sectionKey){
        if(!container){return;}
        container.innerHTML='';
        items.forEach(item=>{
          const el=document.createElement('div');
          el.className='legend-item';
          el.dataset.section=sectionKey;
          el.dataset.key=item.key;
          const swatch=document.createElement('span');
          swatch.className='legend-swatch';
          swatch.style.background=item.color;
          const label=document.createElement('span');
          label.textContent=item.label;
          el.appendChild(swatch);
          el.appendChild(label);
          el.addEventListener('click',()=>{
            const section=visibilityState[sectionKey]||{};
            if(sectionKey==='roc' && typeof item.key==='number'){
              section.sample=section.sample||{};
              const current=section.sample[item.key];
              section.sample[item.key]=!current;
            } else if(sectionKey==='roc' && item.key==='sampleCurves'){
              section.sample=section.sample||{};
              const current=section.sample.sampleCurves;
              section.sample.sampleCurves=!current;
            } else {
              const current=section[item.key];
              section[item.key]=!current;
            }
            visibilityState[sectionKey]=section;
            renderLegendSelection();
            update();
          });
          container.appendChild(el);
        });
      }

      function renderLegendSelection(){
        document.querySelectorAll('.legend-item').forEach(el=>{
          const section=el.dataset.section;
          const key=el.dataset.key;
          let active=visibilityState?.[section]?.[key];
          if(section==='roc' && key!==undefined && key!==''){
            const numericKey=Number(key);
            if(Number.isFinite(numericKey)){
              active=visibilityState.roc.sample?.[numericKey];
              if(active===undefined){
                if(!visibilityState.roc.sample){visibilityState.roc.sample={};}
                visibilityState.roc.sample[numericKey]=true;
                active=true;
              }
            } else if(key==='sampleCurves'){
              active=visibilityState.roc.sample?.sampleCurves;
              if(active===undefined){
                if(!visibilityState.roc.sample){visibilityState.roc.sample={};}
                visibilityState.roc.sample.sampleCurves=true;
                active=true;
              }
            }
          }
          el.classList.toggle('inactive',!active);
        });
      }

      function resetVisibilityState(){
        ['score','roc'].forEach(section=>{
          if(!visibilityState[section]){visibilityState[section]={};}
          Object.keys(visibilityState[section]).forEach(key=>{
            visibilityState[section][key]=true;
          });
          if(section==='roc'){
            visibilityState.roc.sample=visibilityState.roc.sample||{};
            Object.keys(visibilityState.roc.sample).forEach(key=>{
              visibilityState.roc.sample[key]=true;
            });
            visibilityState.roc.confidenceBand=true;
            visibilityState.roc.sample.sampleCurves=true;
          }
        });
        renderLegendSelection();
      }

      const prevalenceSlider=document.getElementById('prevalenceSlider');
      const thresholdInput=document.getElementById('thresholdInput');
      const thresholdValEl=document.getElementById('thresholdVal');
      const prevalenceValEl=document.getElementById('prevalenceVal');

      document.title=STRINGS.pageTitle;
      document.getElementById('pageTitle').textContent=STRINGS.pageTitle;
      document.getElementById('pageIntro').textContent=STRINGS.introText;
      document.getElementById('negTitle').textContent=STRINGS.controls.negativesTitle;
      document.getElementById('posTitle').textContent=STRINGS.controls.positivesTitle;
      document.getElementById('thresholdLabel').firstChild.textContent=STRINGS.controls.thresholdDisplay+' ';
      document.getElementById('thresholdInputLabel').textContent=STRINGS.controls.thresholdInputLabel;
      document.getElementById('thresholdHint').textContent=STRINGS.metrics.thresholdHint;
      document.getElementById('prevalenceLabel').textContent=STRINGS.controls.prevalenceLabel;

      function cloneComponent(src={}){
        const fallback=DISTRIBUTION_KEYS.find(key=>DISTRIBUTIONS_INTERNAL[key])||Object.keys(DISTRIBUTIONS_INTERNAL)[0];
        const key=(src.distribution&&DISTRIBUTIONS_INTERNAL[src.distribution])?src.distribution:fallback;
        const def=DISTRIBUTIONS_INTERNAL[key];
        const params={};
        const source=src.parameters||{};
        def.parameters.forEach(meta=>{
          let value;
          if(Object.prototype.hasOwnProperty.call(source,meta.id)){
            value=source[meta.id];
          } else if(meta.alias){
            const aliases=Array.isArray(meta.alias)?meta.alias:[meta.alias];
            const match=aliases.find(alias=>Object.prototype.hasOwnProperty.call(source,alias));
            if(match!==undefined){value=source[match];}
          }
          if(value===undefined){value=meta.value;}
          params[meta.id]=value;
        });
        return {distribution:key,weight:src.weight??1,parameters:params};
      }

      function cloneSet(opts){
        if(FEATURES.allowMultiComponents){
          if(opts?.components?.length){
            return opts.components.map(cloneComponent);
          }
          const count=Math.max(1,Math.min(FEATURES.defaultComponents||1,FEATURES.maxComponents||Infinity));
          return Array.from({length:count},()=>cloneComponent({distribution:opts?.distribution||DISTRIBUTION_ORDER[0],parameters:opts?.parameters||{},weight:1/count}));
        }
        return [cloneComponent(opts||{distribution:DISTRIBUTION_ORDER[0]})];
      }

        const state={
        threshold:DEFAULT_OPTIONS.threshold??0.5,
        prevalence:DEFAULT_OPTIONS.prevalence??0.5,
        thresholdInitialized:false,
        domain:[0,1],
        rocPairs:[],
        rocPairsSorted:[],
        dataPoints:[],
        posComponents:cloneSet(DEFAULT_OPTIONS.positives),
        negComponents:cloneSet(DEFAULT_OPTIONS.negatives),
        dataImported:DEFAULT_OPTIONS.dataImported||false,
        importedDataFilename:DEFAULT_OPTIONS.importedDataFilename||null,
        importedSampleCount:DEFAULT_OPTIONS.importedSampleCount||0,
        importedRawPos:[],
        importedRawNeg:[],
        showEmpiricalHistogram:DEFAULT_OPTIONS.showEmpiricalHistogram??true,
        showEmpiricalRoc:DEFAULT_OPTIONS.showEmpiricalRoc??false,
        showEmpiricalPoints:DEFAULT_OPTIONS.showEmpiricalPoints??false,
        empiricalPoints:[],
        autoResample:DEFAULT_OPTIONS.autoResample??false,
        simulatedDataActive:false,
        samplesROC:[],
        samplesHist:null,
        confBand:null,
        delongBand:null,
        estimatedCurve:null,
        numSamples:20,
        rocBandMode:'none',
        busy:false
      };

      thresholdValEl.textContent=STRINGS.controls.thresholdValue(state.threshold);
      thresholdInput.value=state.threshold.toFixed(3);
      prevalenceSlider.value=state.prevalence;
      prevalenceValEl.textContent=STRINGS.controls.prevalenceValue(state.prevalence);

      const autoResampleToggle=document.getElementById('autoResampleToggle');
      const resampleButton=document.getElementById('resampleButton');
      const numSamplesInput=document.getElementById('numSamplesInput');
      const sampleSizeInput=document.getElementById('sampleSizeInput');
      const rocBandModeSelect=document.getElementById('rocBandMode');
      autoResampleToggle.checked=state.autoResample;
      autoResampleToggle.addEventListener('change',event=>{
        state.autoResample=event.target.checked;
        if(state.autoResample && currentEmpiricalDataset.source==='simulated'){
          resampleFromState();
          regenerateSampleRocs();
        }
      });
      resampleButton.addEventListener('click',async ()=>{
        resampleFromState(true);
        await regenerateSampleRocs(true);
      });
      if(numSamplesInput){
        numSamplesInput.value=state.numSamples;
        numSamplesInput.addEventListener('input',async event=>{
          const val=Math.max(1,Math.round(Number(event.target.value)||1));
          state.numSamples=val;
          event.target.value=String(val);
        });
      }
      if(sampleSizeInput){
        sampleSizeInput.addEventListener('input',()=>{
          // avoid resampling on every keystroke
        });
        sampleSizeInput.addEventListener('change',async ()=>{
          await regenerateSampleRocs(true);
        });
      }
      if(rocBandModeSelect){
        rocBandModeSelect.value=state.rocBandMode;
        rocBandModeSelect.addEventListener('change',event=>{
          const value=event.target.value;
          state.rocBandMode=value;
          update();
        });
      }

      const dataImportInput=document.getElementById('dataImportInput');
      dataImportInput.addEventListener('change',event=>{
        const file=event.target.files?.[0];
        if(file){handleDataFile(file);}
      });

      const dataImportDropZone=document.getElementById('dataImportDropZone');
      ['dragenter','dragover'].forEach(evt=>{
        dataImportDropZone.addEventListener(evt,event=>{
          event.preventDefault();
          event.stopPropagation();
          dataImportDropZone.classList.add('dragover');
        });
      });
      ['dragleave','drop'].forEach(evt=>{
        dataImportDropZone.addEventListener(evt,event=>{
          event.preventDefault();
          event.stopPropagation();
          dataImportDropZone.classList.remove('dragover');
          if(event.type==='drop'){
            const file=event.dataTransfer?.files?.[0];
            if(file){
              handleDataFile(file);
              dataImportInput.value='';
            }
          }
        });
      });

      const distDims={width:540,height:420,margin:{top:40,right:24,bottom:60,left:64}};
      const rocDims={width:540,height:420,margin:{top:40,right:24,bottom:60,left:64}};

      const distSvg=d3.select('#distPlot').append('svg')
        .attr('viewBox',`0 0 ${distDims.width} ${distDims.height}`)
        .attr('preserveAspectRatio','xMidYMid meet');
      const distContent=distSvg.append('g')
        .attr('transform',`translate(${distDims.margin.left},${distDims.margin.top})`);
      const distWidth=distDims.width-distDims.margin.left-distDims.margin.right;
      const distHeight=distDims.height-distDims.margin.top-distDims.margin.bottom;

      distSvg.append('text')
        .attr('class','chart-title')
        .attr('x',distDims.width/2)
        .attr('y',24)
        .attr('text-anchor','middle')
        .text(STRINGS.plots.scoreTitle);

      const distXScale=d3.scaleLinear().range([0,distWidth]);
      const distYScale=d3.scaleLinear().range([distHeight,0]);
      const distXAxisGroup=distContent.append('g').attr('transform',`translate(0,${distHeight})`);
      const distYAxisGroup=distContent.append('g');

      distContent.append('text')
        .attr('class','axis-label')
        .attr('x',distWidth/2)
        .attr('y',distHeight+42)
        .attr('text-anchor','middle')
        .text(STRINGS.plots.scoreXAxis);

      buildLegend(scoreLegendContainer,scoreLegendItems,'score');
      function refreshRocLegend(){
        buildLegend(rocLegendContainer,[...baseRocLegendItems],'roc');
      }
      refreshRocLegend();
      renderLegendSelection();
      distContent.append('text')
        .attr('class','axis-label')
        .attr('transform','rotate(-90)')
        .attr('x',-distHeight/2)
        .attr('y',-46)
        .attr('text-anchor','middle')
        .text(STRINGS.plots.scoreYAxis);

      const empiricalGroup=distContent.append('g').attr('class','empirical-group');
      const rugNegGroup=empiricalGroup.append('g').attr('class','rug-neg');
      const rugPosGroup=empiricalGroup.append('g').attr('class','rug-pos');
      const histNegGroup=empiricalGroup.append('g').attr('class','hist-neg');
      const histPosGroup=empiricalGroup.append('g').attr('class','hist-pos');

      const distAreaGroup=distContent.append('g').attr('class','area-group');
      const areaTNPath=distAreaGroup.append('path').attr('class','area-tn');
      const areaFPPath=distAreaGroup.append('path').attr('class','area-fp');
      const areaFNPath=distAreaGroup.append('path').attr('class','area-fn');
      const areaTPPath=distAreaGroup.append('path').attr('class','area-tp');

      const distPosLinePath=distContent.append('path').attr('class','pdf-line-positive').attr('fill',COLOR_HELPERS.posPdfFill).attr('stroke',COLOR_HELPERS.posPdf);
      const distNegLinePath=distContent.append('path').attr('class','pdf-line-negative').attr('fill',COLOR_HELPERS.negPdfFill).attr('stroke',COLOR_HELPERS.negPdf);
      const thresholdLine=distContent.append('line').attr('class','threshold-line');
      const thresholdHandle=distContent.append('circle').attr('class','threshold-handle').attr('r',6);

      const distAreaGenerator=d3.area().curve(d3.curveMonotoneX)
        .x(d=>distXScale(d.x))
        .y0(()=>distYScale(0))
        .y1(d=>distYScale(d.y));
      const distPosLineGenerator=d3.line().curve(d3.curveMonotoneX)
        .x(d=>distXScale(d.x))
        .y(d=>distYScale(d.posPDF));
      const distNegLineGenerator=d3.line().curve(d3.curveMonotoneX)
        .x(d=>distXScale(d.x))
        .y(d=>distYScale(d.negPDF));

      const dragOverlay=distContent.append('rect')
        .attr('class','drag-overlay')
        .attr('width',distWidth)
        .attr('height',distHeight)
        .attr('fill','transparent')
        .style('cursor','ew-resize');

      const tooltip=d3.select('body').append('div')
        .style('position','absolute')
        .style('padding','6px 10px')
        .style('background','#222')
        .style('color','#fff')
        .style('border-radius','6px')
        .style('font-size','12px')
        .style('pointer-events','none')
        .style('opacity',0);

      function showTooltip(text,event){
        const e=event.touches?.[0]||event;
        if(!e){return;}
        tooltip.style('opacity',1)
          .style('left',`${(e.pageX??e.clientX+window.scrollX)+12}px`)
          .style('top',`${(e.pageY??e.clientY+window.scrollY)-24}px`)
          .text(text);
      }
      function hideTooltip(){tooltip.style('opacity',0);}

      dragOverlay.call(d3.drag()
        .on('start',handleDrag)
        .on('drag',handleDrag)
        .on('end',()=>hideTooltip()));
      thresholdLine.call(d3.drag()
        .on('start',handleDrag)
        .on('drag',handleDrag)
        .on('end',()=>hideTooltip()));
      thresholdHandle.call(d3.drag()
        .on('start',handleDrag)
        .on('drag',handleDrag)
        .on('end',()=>hideTooltip()))
        .on('mouseenter',event=>showTooltip(STRINGS.metrics.thresholdHandleTooltip(state.threshold),event))
        .on('mousemove',event=>showTooltip(STRINGS.metrics.thresholdHandleTooltip(state.threshold),event))
        .on('mouseleave',hideTooltip);

      const rocSvg=d3.select('#rocPlot').append('svg')
        .attr('viewBox',`0 0 ${rocDims.width} ${rocDims.height}`)
        .attr('preserveAspectRatio','xMidYMid meet')
        .attr('width',rocDims.width)
        .attr('height',rocDims.height);
      const rocContent=rocSvg.append('g')
        .attr('transform',`translate(${rocDims.margin.left},${rocDims.margin.top})`);
      const rocWidth=rocDims.width-rocDims.margin.left-rocDims.margin.right;
      const rocHeight=rocDims.height-rocDims.margin.top-rocDims.margin.bottom;
      const rocClip=rocContent.append('clipPath').attr('id','rocClip');
      rocClip.append('rect').attr('x',0).attr('y',0).attr('width',rocWidth).attr('height',rocHeight);

      const rocTitle=rocSvg.append('text')
        .attr('class','chart-title')
        .attr('x',rocDims.width/2)
        .attr('y',24)
        .attr('text-anchor','middle');

      const rocXScale=d3.scaleLinear().domain([0,1]).range([0,rocWidth]);
      const rocYScale=d3.scaleLinear().domain([0,1]).range([rocHeight,0]);
      const rocXAxisGroup=rocContent.append('g').attr('transform',`translate(0,${rocHeight})`);
      const rocYAxisGroup=rocContent.append('g');

      rocContent.append('text')
        .attr('class','axis-label')
        .attr('x',rocWidth/2)
        .attr('y',rocHeight+42)
        .attr('text-anchor','middle')
        .text(STRINGS.plots.rocXAxis);
      rocContent.append('text')
        .attr('class','axis-label')
        .attr('transform','rotate(-90)')
        .attr('x',-rocHeight/2)
        .attr('y',-48)
        .attr('text-anchor','middle')
        .text(STRINGS.plots.rocYAxis);

      const rocBandGroup=rocContent.append('g').attr('class','roc-bands roc-ci-band').attr('clip-path','url(#rocClip)');
      const rocSampleGroup=rocContent.append('g').attr('class','roc-samples').attr('clip-path','url(#rocClip)');
      const estimatedRocPath=rocContent.append('path').attr('class','roc-estimated').attr('clip-path','url(#rocClip)');
      const rocLinePath=rocContent.append('path').attr('class','roc-line').attr('clip-path','url(#rocClip)');
      const empiricalRocPath=rocContent.append('path').attr('class','roc-empirical').style('opacity',0).attr('clip-path','url(#rocClip)');
      rocContent.append('path').attr('class','roc-random')
        .attr('d',`M${rocXScale(0)},${rocYScale(0)} L${rocXScale(1)},${rocYScale(1)}`);
      const rocPoint=rocContent.append('circle').attr('class','roc-point').attr('r',6);

      const rocLineGenerator=d3.line().curve(d3.curveMonotoneX)
        .x(d=>rocXScale(d.fpr))
        .y(d=>rocYScale(d.tpr));

      rocPoint.call(d3.drag()
        .on('start',handleRocDrag)
        .on('drag',handleRocDrag)
        .on('end',()=>hideTooltip()))
        .on('mouseenter',event=>showTooltip(STRINGS.metrics.thresholdHandleTooltip(state.threshold),event))
        .on('mousemove',event=>showTooltip(STRINGS.metrics.thresholdHandleTooltip(state.threshold),event))
        .on('mouseleave',hideTooltip);

      const areaTooltips=STRINGS.metrics.areaTooltips;
      const addAreaTooltip=(path,label)=>{
        path.on('mousemove',event=>{if(path.attr('d')){showTooltip(label,event);}});
        path.on('mouseleave',hideTooltip);
      };
      addAreaTooltip(areaTPPath,areaTooltips.tp);
      addAreaTooltip(areaFNPath,areaTooltips.fn);
      addAreaTooltip(areaTNPath,areaTooltips.tn);
      addAreaTooltip(areaFPPath,areaTooltips.fp);

      function getDistributionKeys(){
        return DISTRIBUTION_KEYS.slice();
      }

      function generateParameterUI(def, component, onChange){
        const container=document.createElement('div');
        (def.parameters||[]).forEach(meta=>{
          const row=document.createElement('div');
          row.className='param-row';
          const label=document.createElement('label');
          label.textContent=meta.label||meta.id;
          label.style.minWidth='110px';
          row.appendChild(label);
          const paramId=meta.id;
          const setValue=(val)=>{
            component.parameters[paramId]=val;
            if(typeof onChange==='function'){onChange(paramId,val);}
          };
          const defaultVal=component.parameters[paramId]!==undefined?component.parameters[paramId]:meta.value;
          if(meta.slider){
            const controls=document.createElement('div');
            controls.className='parameter-controls';
            const slider=document.createElement('input');
            slider.type='range';
            slider.className='parameter-slider';
            const numeric=document.createElement('input');
            numeric.type='number';
            numeric.className='parameter-number';
            ['min','max','step'].forEach(attr=>{
              const val=meta.slider[attr]??meta[attr];
              if(val!==undefined){slider[attr]=val;}
            });
            ['min','max','step'].forEach(attr=>{
              const val=meta[attr];
              if(val!==undefined){numeric[attr]=val;}
            });
            slider.value=String(defaultVal);
            numeric.value=String(defaultVal);
            slider.addEventListener('input',e=>{
              const v=Number(e.target.value);
              if(Number.isFinite(v)){
                numeric.value=String(v);
                setValue(v);
              }
            });
            numeric.addEventListener('input',e=>{
              const v=Number(e.target.value);
              if(Number.isFinite(v)){
                slider.value=String(v);
                setValue(v);
              }
            });
            controls.appendChild(slider);
            controls.appendChild(numeric);
            row.appendChild(controls);
          } else {
            const input=document.createElement('input');
            input.type=meta.type||'number';
            if(meta.step!==undefined){input.step=meta.step;}
            if(meta.min!==undefined){input.min=meta.min;}
            if(meta.max!==undefined){input.max=meta.max;}
            input.value=String(defaultVal);
            input.addEventListener('input',e=>{
              const v=Number(e.target.value);
              if(Number.isFinite(v)){
                setValue(v);
              }
            });
            row.appendChild(input);
          }
          container.appendChild(row);
        });
        return container;
      }

      function normalizeWeightsForClass(className,{mutate=true}={}){
        if(!FEATURES.allowMultiComponents){return [];}
        const normalizedClass=(className||'').toLowerCase();
        let prefix=null;
        if(normalizedClass.startsWith('neg')){prefix='neg';}
        if(normalizedClass.startsWith('pos')){prefix='pos';}
        if(!prefix){return [];}
        const components=state[prefix+'Components']||[];
        if(!components.length){return [];}
        const normalized=ROCUtils.normalizeWeightsForClass(prefix==='neg'?'negative':'positive',components.map(c=>({...c})));
        if(mutate){
          normalized.forEach((norm,idx)=>{
            if(components[idx]){
              components[idx].weight=norm.weight;
            }
          });
        }
        return normalized;
      }

      function getNormalizedComponents(prefix){
        if(!FEATURES.allowMultiComponents){return state[prefix+'Components']||[];}
        const source=state[prefix+'Components']||[];
        if(source.length<=1){
          return source.map(comp=>({...comp,weight:1}));
        }
        const normalized=normalizeWeightsForClass(prefix==='neg'?'negative':'positive',{mutate:false});
        return normalized.length?normalized:source;
      }

      function getStudentTStats(parameters={}){
        const mu=Number(parameters.mu);
        const sigmaRaw=Number(parameters.sigma);
        const nu=Number(parameters.nu);
        const muVal=Number.isFinite(mu)?mu:0;
        const sigma=Math.max(Number.isFinite(sigmaRaw)?sigmaRaw:1,1e-6);
        const nuVal=Number.isFinite(nu)?nu:0;
        const isCauchy=nuVal>0 && nuVal<=1.01;
        let meanLabel='undefined';
        if(!isCauchy && nuVal>1){
          meanLabel=muVal.toFixed(3);
        }
        let varianceLabel='undefined';
        if(!isCauchy && nuVal>2){
          const variance=sigma*sigma*nuVal/(nuVal-2);
          varianceLabel=Number.isFinite(variance)?variance.toFixed(3):'∞';
        } else if(!isCauchy && nuVal>1){
          varianceLabel='∞';
        }
        return {meanLabel,varianceLabel,mu:muVal,sigma,nu:nuVal,isCauchy};
      }

      function refreshStudentTInfo(){
        ['neg','pos'].forEach(prefix=>{
          const components=state[prefix+'Components'];
          components.forEach((component,index)=>{
            const card=document.querySelector(`#${prefix}Params .component-card[data-component-index="${index}"]`);
            if(!card){return;}
            card.dataset.distribution=component.distribution;
            const infoEl=card.querySelector('[data-role="studentt-stats"]');
            const headerEl=card.querySelector('[data-role="component-header"]');
          const def=DISTRIBUTIONS_INTERNAL[component.distribution];
            const defaultLabel=(FEATURES.allowMultiComponents?`${STRINGS.multi.componentLabel(index)} — `:'')+(def?.label||component.distribution);
            if(component.distribution!=='studentT'){
              if(infoEl){
                infoEl.textContent='';
                infoEl.style.display='none';
              }
              if(headerEl){headerEl.textContent=defaultLabel;}
              card.removeAttribute('title');
              return;
            }
            if(headerEl){
              const nu=Number(component.parameters.nu);
              if(Number.isFinite(nu) && Math.abs(nu-1)<=0.01){
                const prefix=FEATURES.allowMultiComponents?`${STRINGS.multi.componentLabel(index)} — `:'';
                headerEl.textContent=`${prefix}Cauchy distribution (ν = 1)`;
              } else {
                headerEl.textContent=defaultLabel;
              }
            }
            if(infoEl){
              infoEl.style.display='';
              const stats=getStudentTStats(component.parameters);
              if(stats.isCauchy){
                const message='Mean and variance undefined for ν ≤ 1 (Cauchy).';
                infoEl.textContent=message;
                card.title=message;
              } else {
                infoEl.textContent=`Mean: ${stats.meanLabel} • Variance: ${stats.varianceLabel}`;
                card.title=`Student t — Mean: ${stats.meanLabel}, Variance: ${stats.varianceLabel}`;
              }
            }
          });
        });
      }

      function hasEmpiricalData(){
        return state.dataImported && (state.importedRawPos.length>0 || state.importedRawNeg.length>0);
      }

      function getProcessedEmpiricalSamples(){
        if(!hasEmpiricalData()){
      return {positives:[],negatives:[]};
    }
    const positives=[...state.importedRawPos];
    const negatives=[...state.importedRawNeg];
    return {positives,negatives};
  }

  function getProcessedEmpiricalPoints(){
    if(!hasEmpiricalData()){
      return [];
    }
    return state.empiricalPoints;
  }


      function refreshDataImportStatus(){
        const statusEl=document.getElementById('dataImportStatus');
        if(!hasEmpiricalData()){
          statusEl.textContent='No empirical data loaded.';
          return;
        }
        const positives=state.importedRawPos.length;
        const negatives=state.importedRawNeg.length;
        const name=currentEmpiricalDataset.name || state.importedDataFilename || 'dataset';
        if(state.simulatedDataActive){
          statusEl.textContent=`${name}: ${positives+negatives} simulated samples (${positives} positive, ${negatives} negative).`;
        } else {
          statusEl.textContent=`${name}: ${positives+negatives} samples imported (${positives} positive, ${negatives} negative).`;
        }
      }

      function refreshDatasetExportState(){
        const exportBtn=document.getElementById('dataExportButton');
        if(!exportBtn) return;
        exportBtn.style.display=currentEmpiricalDataset.source==='simulated'?'':'none';
      }

      function setDatasetName(name){
        const input=document.getElementById('datasetNameInput');
        if(input){input.value=name;}
        currentEmpiricalDataset.name=name;
      }

      function applyImportedData({positives,negatives,points,filename,simulated=false}){
        state.importedRawPos=positives;
        state.importedRawNeg=negatives;
        state.empiricalPoints=points;
        state.dataImported=true;
        state.importedDataFilename=filename||'dataset.csv';
        state.importedSampleCount=points.length;
        state.simulatedDataActive=Boolean(simulated);
        const fileInput=document.getElementById('dataImportInput');
        if(fileInput){fileInput.value='';}
        const previousSource=currentEmpiricalDataset.source;
        currentEmpiricalDataset.source=simulated?'simulated':'imported';
        if(simulated){
          const input=document.getElementById('datasetNameInput');
          const existing=(input?.value||'').trim();
          if(!existing || previousSource!=='simulated'){
            setDatasetName('simulated_dataset');
          }else{
            currentEmpiricalDataset.name=existing;
          }
        }else{
          const defaultName=(filename||'dataset.csv').replace(/\.[^.]+$/, '')||'imported_dataset';
          setDatasetName(defaultName);
        }
        refreshDatasetExportState();
        refreshDataImportStatus();
        update();
      }

      function applySimulatedData(posSamples,negSamples){
        const points=[
          ...posSamples.map(score=>({score,label:1})),
          ...negSamples.map(score=>({score,label:0}))
        ];
        applyImportedData({
          positives:posSamples,
          negatives:negSamples,
          points,
          filename:'simulated_in_memory.csv',
          simulated:true
        });
      }

      function getSampleCounts(){
        const N=Math.max(10,Number(document.getElementById('sampleSizeInput')?.value)||200);
        const p=clamp(state.prevalence,0,1);
        const nPos=Math.round(N*p);
        const nNeg=Math.max(0,N-nPos);
        return {N,nPos,nNeg};
      }

      function resampleFromState(force=false){
        if(!force && !state.simulatedDataActive){
          return;
        }
        const {nPos,nNeg}=getSampleCounts();
        const posSamples=sampleDistribution('pos',state.posComponents,nPos);
        const negSamples=sampleDistribution('neg',state.negComponents,nNeg);
        applySimulatedData(posSamples,negSamples);
      }

      async function maybeAutoResample(){
        if(state.autoResample && currentEmpiricalDataset.source==='simulated'){
          resampleFromState();
          await regenerateSampleRocs();
        }
      }
      async function regenerateSampleRocs(force=false){
        if(!force && !state.autoResample){return;}
        await withBusy(async ()=>{
          const numSamples=Math.max(1,Number(state.numSamples)||1);
          const {nPos,nNeg}=getSampleCounts();
          const curves=[];
          let lastPosSamples=null;
          let lastNegSamples=null;
          for(let i=0;i<numSamples;i++){
            const posSamples=sampleDistribution('pos',state.posComponents,nPos);
            const negSamples=sampleDistribution('neg',state.negComponents,nNeg);
            lastPosSamples=posSamples;
            lastNegSamples=negSamples;
            const points=[
              ...posSamples.map(score=>({score,label:1})),
              ...negSamples.map(score=>({score,label:0}))
            ];
            const rocPoints=ROCUtils.computeEmpiricalRoc(points);
            if(rocPoints.length){
              const mapped=pointsToRocArrays(rocPoints);
              if(mapped){curves.push(mapped);}
            }
          }
          state.samplesROC=curves;
          if(lastPosSamples||lastNegSamples){
            state.samplesHist=computeSampleHistogramsFromSample(lastPosSamples||[],lastNegSamples||[]);
            if(state.rocBandMode==='delong'){
              const fprGrid=d3.range(0,1.000001,0.01);
              state.delongBand=ROCUtils.computeDelongTPRBand(lastPosSamples||[],lastNegSamples||[],fprGrid,1.96);
            } else {
              state.delongBand=null;
            }
          } else {
            state.samplesHist=null;
            state.delongBand=null;
          }
          if(state.rocBandMode==='bootstrap'){
            await computeConfidenceBand();
          } else {
            state.confBand=null;
          }
          state.estimatedCurve=computeEstimatedCurveFromSamples(state.samplesROC,state.confBand,state.delongBand,state.rocBandMode);
          visibilityState.roc.sample={sampleCurves:true};
          state.samplesROC.forEach((_,idx)=>{visibilityState.roc.sample[idx]=true;});
          refreshRocLegend();
          update();
        });
      }

      async function computeConfidenceBand(){
        const samples=state.samplesROC||[];
        if(!samples.length){state.confBand=null;return;}
        if(state.rocBandMode!=='bootstrap'){state.confBand=null;return;}
        await withBusy(async ()=>{
          const fprGrid=d3.range(0,1.000001,0.01);
          const quantile=(arr,p)=>{
            if(!arr.length){return null;}
            const sorted=[...arr].sort((a,b)=>a-b);
            return d3.quantileSorted(sorted,p);
          };
          const interpolate=(fprArr,tprArr,x)=>{
            const n=fprArr.length;
            if(!n){return null;}
            if(x<=fprArr[0]){return tprArr[0];}
            if(x>=fprArr[n-1]){return tprArr[n-1];}
            const idx=d3.bisectLeft(fprArr,x);
            const x0=fprArr[idx-1],x1=fprArr[idx];
            const y0=tprArr[idx-1],y1=tprArr[idx];
            if(x1===x0){return y0;}
            const t=(x-x0)/(x1-x0);
            return y0+(y1-y0)*t;
          };
          const lower=[];
          const upper=[];
          fprGrid.forEach(fprVal=>{
            const values=[];
            samples.forEach(sample=>{
              const fpr=Array.isArray(sample.fpr)?sample.fpr:null;
              const tpr=Array.isArray(sample.tpr)?sample.tpr:null;
              if(!fpr||!tpr||fpr.length!==tpr.length||!fpr.length){return;}
              const v=interpolate(fpr,tpr,fprVal);
              if(Number.isFinite(v)){values.push(v);}
            });
            lower.push(quantile(values,0.025));
            upper.push(quantile(values,0.975));
          });
          lower.forEach((v,idx)=>{if(!Number.isFinite(v)){lower[idx]=0;}});
          upper.forEach((v,idx)=>{if(!Number.isFinite(v)){upper[idx]=1;}});
          state.confBand={fpr:fprGrid,lower,upper,method:'bootstrap',level:0.95,n_samples:samples.length};
        });
      }
      function parseEmpiricalCsv(text, filename){
        let parsed;
        try{
          parsed=d3.csvParse(text,d=>({
            score:+d.score,
            label:+d.label
          }));
        } catch(err){
          console.error(err);
          alert('Failed to parse CSV: '+err.message);
          return;
        }
        if(!parsed.length || !('score' in parsed[0]) || !('label' in parsed[0])){
          alert('CSV must contain columns: score, label');
          return;
        }
        const cleaned=parsed.filter(d=>Number.isFinite(d.score)&&(d.label===0||d.label===1));
        if(!cleaned.length){
          alert('No valid rows with numeric score and binary label were found.');
          return;
        }
        const positives=cleaned.filter(d=>d.label===1).map(d=>d.score);
        const negatives=cleaned.filter(d=>d.label===0).map(d=>d.score);
        applyImportedData({positives,negatives,points:cleaned,filename});
      }

      function handleDataFile(file){
        if(!file){return;}
        const reader=new FileReader();
        reader.onload=e=>{
          const text=e.target?.result;
          if(typeof text!=='string'){return;}
          parseEmpiricalCsv(text,file.name);
        };
        reader.readAsText(file);
      }

      function renderComponents(prefix){
        const container=document.getElementById(prefix+'Params');
        const allowMulti=FEATURES.allowMultiComponents;
        const distributionKeys=getDistributionKeys();
        if(!distributionKeys.length){container.textContent='No distributions configured.';return;}
        const components=state[prefix+'Components'];
        if(!components.length){components.push(cloneComponent({distribution:distributionKeys[0]}));}
        if(!allowMulti && components.length>1){components.splice(1);}
        container.innerHTML='';

        const list=document.createElement('div');
        list.className='component-list';
        components.forEach((component,index)=>{
          if(!DISTRIBUTIONS_INTERNAL[component.distribution]){
            component.distribution=distributionKeys[0];
            component.parameters=cloneComponent({distribution:distributionKeys[0]}).parameters;
          }
          const def=DISTRIBUTIONS_INTERNAL[component.distribution];
          const card=document.createElement('div');
          card.className='component-card';
          card.dataset.componentPrefix=prefix;
          card.dataset.componentIndex=String(index);
          card.dataset.distribution=component.distribution;

          const header=document.createElement('div');
          header.className='component-header';
          header.dataset.role='component-header';
          header.textContent=allowMulti?`${STRINGS.multi.componentLabel(index)} — ${def.label}`:def.label;
          card.appendChild(header);
          const canRemove=allowMulti && components.length>1 && index>0;
          if(canRemove){
            const removeRow=document.createElement('div');
            removeRow.className='component-remove-row';
            const removeBtn=document.createElement('button');
            removeBtn.type='button';
            removeBtn.className='component-remove-btn';
            removeBtn.textContent='Remove component';
            removeBtn.title=STRINGS.multi.removeComponent;
            removeBtn.setAttribute('aria-label',STRINGS.multi.removeComponent);
            removeBtn.addEventListener('click',()=>{
              components.splice(index,1);
              renderComponents(prefix);
              update();
              maybeAutoResample();
            });
            removeRow.appendChild(removeBtn);
            card.appendChild(removeRow);
          }

          const distRow=document.createElement('div');
          distRow.className='component-row';
          const distLabel=document.createElement('label');
          distLabel.textContent=STRINGS.controls.distributionLabel;
          const distSelect=document.createElement('select');
          distributionKeys.forEach(key=>{
            const opt=document.createElement('option');
            opt.value=key;
            opt.textContent=DISTRIBUTIONS_INTERNAL[key].label;
            distSelect.appendChild(opt);
          });
          distSelect.value=component.distribution;
            distSelect.addEventListener('change',event=>{
              if(isRestoringImportedState){return;}
              components[index]=cloneComponent({distribution:event.target.value,weight:component.weight});
              renderComponents(prefix);
              update();
              maybeAutoResample();
            });
          distRow.appendChild(distLabel);
          distRow.appendChild(distSelect);
          card.appendChild(distRow);

          if(allowMulti){
            const weightRow=document.createElement('div');
            weightRow.className='component-row';
            const weightLabel=document.createElement('label');
            weightLabel.textContent=STRINGS.multi.weight;
            const weightInput=document.createElement('input');
            weightInput.type='number';
            weightInput.step='0.01';
            weightInput.min='0';
            weightInput.value=component.weight??1;
            weightInput.addEventListener('input',event=>{
              const numeric=Number(event.target.value);
              component.weight=Number.isFinite(numeric)?numeric:0;
              update();
              maybeAutoResample();
            });
            weightRow.appendChild(weightLabel);
            weightRow.appendChild(weightInput);
            card.appendChild(weightRow);
          }

          const paramsUI=generateParameterUI(def,component,(id,val)=>{
            component.parameters[id]=val;
            update();
            maybeAutoResample();
          });
          card.appendChild(paramsUI);

          if(component.distribution==='studentT'){
            const info=document.createElement('div');
            info.className='component-info';
            info.dataset.role='studentt-stats';
            card.appendChild(info);
          }

          list.appendChild(card);
        });

        container.appendChild(list);

        if(allowMulti){
          const actionRow=document.createElement('div');
          actionRow.className='component-actions';

          if(components.length>=2){
            const normalizeBtn=document.createElement('button');
            normalizeBtn.type='button';
            normalizeBtn.className='add-component-btn';
            normalizeBtn.textContent=prefix==='pos'?'Normalize Positive Weights':'Normalize Negative Weights';
            normalizeBtn.addEventListener('click',()=>{
              normalizeWeightsForClass(prefix==='neg'?'negative':'positive',{mutate:true});
              renderComponents(prefix);
              update();
              maybeAutoResample();
            });
            actionRow.appendChild(normalizeBtn);
          }

          if(!FEATURES.maxComponents || components.length<FEATURES.maxComponents){
            const addBtn=document.createElement('button');
            addBtn.type='button';
            addBtn.className='add-component-btn';
            addBtn.textContent=STRINGS.multi.addComponent;
            addBtn.addEventListener('click',()=>{
              components.push(cloneComponent({distribution:getDistributionKeys()[0],weight:1}));
              renderComponents(prefix);
              update();
              maybeAutoResample();
            });
            actionRow.insertBefore(addBtn, actionRow.firstChild);
          }

          if(actionRow.childElementCount>0){
            container.appendChild(actionRow);
          }
        }
      }

      function sanitizePDF(value){return Number.isFinite(value)&&value>=0?value:0;}
      function clamp(val,min,max){return Math.min(Math.max(val,min),max);}
      function disableUiDuringBusy(disabled){
        const controls=document.querySelectorAll('input,button,select,textarea');
        controls.forEach(el=>{
          if(disabled){
            el.setAttribute('data-prev-disabled',el.disabled);
            el.disabled=true;
          } else {
            const prev=el.getAttribute('data-prev-disabled');
            if(prev==="true"){el.disabled=true;}else{el.disabled=false;}
            el.removeAttribute('data-prev-disabled');
          }
        });
      }

      function setBusy(flag){
        state.busy=Boolean(flag);
        if(state.busy){
          console.debug('[Busy] Activating spinner');
        } else {
          console.debug('[Busy] Deactivating spinner');
        }
        document.body.classList.toggle('busy',state.busy);
        const overlay=document.getElementById('busyOverlay');
        if(overlay){overlay.style.display=state.busy?'flex':'none';}
        disableUiDuringBusy(state.busy);
      }

      async function withBusy(fn){
        setBusy(true);
        // Allow DOM to paint spinner before heavy work (use animation frame)
        await new Promise(requestAnimationFrame);
        try{
          return await fn();
        }finally{
          setBusy(false);
        }
      }

      function buildDistribution(prefix){
        const allowMulti=FEATURES.allowMultiComponents;
        const components=allowMulti?getNormalizedComponents(prefix):(state[prefix+'Components']||[]);
        const resolved=components.map(component=>{
          const def=DISTRIBUTIONS_INTERNAL[component.distribution];
          const params=def.mapper?def.mapper(component.parameters):component.parameters;
          const domain=def.domain?def.domain(params):[-5,5];
          const weight=allowMulti?(Math.max(Number(component.weight)||0,0)||0):1;
          return {def,params,weight:allowMulti?weight:1,domain};
        });
        if(!allowMulti||resolved.length===1){
          resolved.forEach(item=>item.weight=1);
        }
        let minDomain=Math.min(...resolved.map(item=>item.domain[0]));
        let maxDomain=Math.max(...resolved.map(item=>item.domain[1]));
        if(!Number.isFinite(minDomain)){minDomain=0;}
        if(!Number.isFinite(maxDomain)){maxDomain=minDomain+1;}
        if(maxDomain<=minDomain){maxDomain=minDomain+1;}
        return {
          pdf:x=>resolved.reduce((sum,item)=>sum+item.weight*item.def.pdf(item.params,x),0),
          cdf:x=>resolved.reduce((sum,item)=>sum+item.weight*item.def.cdf(item.params,x),0),
          domain:[minDomain,maxDomain]
        };
      }

      function update(){
        const pos=buildDistribution('pos');
        const neg=buildDistribution('neg');
        refreshStudentTInfo();

        const empiricalSamples=getProcessedEmpiricalSamples();
        const hasEmpiricalSamples=empiricalSamples.positives.length>0||empiricalSamples.negatives.length>0;
        const fprGrid=d3.range(0,1.000001,0.01);
        if(!(hasEmpiricalSamples && state.rocBandMode==='delong')){
          state.delongBand=null;
        }
        const hasSampleHist=state.samplesHist && Array.isArray(state.samplesHist.positives) && Array.isArray(state.samplesHist.negatives);
        const empiricalPointList=hasEmpiricalSamples?getProcessedEmpiricalPoints():[];

        let minX=Math.min(pos.domain[0],neg.domain[0]);
        let maxX=Math.max(pos.domain[1],neg.domain[1]);
        if(hasSampleHist && Array.isArray(state.samplesHist.domain)){
          const [dMin,dMax]=state.samplesHist.domain;
          if(Number.isFinite(dMin)&&Number.isFinite(dMax)){
            minX=Math.min(minX,dMin);
            maxX=Math.max(maxX,dMax);
          }
        }
        if(hasEmpiricalSamples){
          const combined=[...empiricalSamples.positives,...empiricalSamples.negatives];
          if(combined.length){
            const dataMin=Math.min(...combined);
            const dataMax=Math.max(...combined);
            if(Number.isFinite(dataMin)&&Number.isFinite(dataMax)){
              minX=Math.min(minX,dataMin);
              maxX=Math.max(maxX,dataMax);
            }
          }
        }
        if(!Number.isFinite(minX)||!Number.isFinite(maxX)){minX=0;maxX=1;}
        if(maxX<=minX){maxX=minX+1;}

        state.domain=[minX,maxX];
        if(!state.thresholdInitialized){
          state.threshold=clamp(DEFAULT_OPTIONS.threshold??(minX+maxX)/2,minX,maxX);
          state.thresholdInitialized=true;
        } else if(state.threshold<minX || state.threshold>maxX){
          state.threshold=clamp((minX+maxX)/2,minX,maxX);
        }
        const threshold=state.threshold;
        thresholdValEl.textContent=STRINGS.controls.thresholdValue(threshold);
        thresholdInput.value=threshold.toFixed(3);

        const N=500;
        const xs=Array.from({length:N},(_,i)=>minX+(maxX-minX)*i/(N-1));
        if(!xs.some(x=>Math.abs(x-threshold)<1e-8)){
          xs.push(threshold);
          xs.sort((a,b)=>a-b);
        }

        const dataPoints=xs.map(x=>{
          const posPDF=sanitizePDF(pos.pdf(x));
          const negPDF=sanitizePDF(neg.pdf(x));
          return {x,posPDF,negPDF,posCDF:clamp(pos.cdf(x),0,1),negCDF:clamp(neg.cdf(x),0,1)};
        });
        state.dataPoints=dataPoints;

        const theoreticalMax=d3.max(dataPoints,d=>Math.max(d.posPDF,d.negPDF))||0;
        let histPosData=[];
        let histNegData=[];
        let histMaxDensity=0;
        const histActive=(hasEmpiricalSamples||hasSampleHist) && (visibilityState.score.posHist||visibilityState.score.negHist);
        if(histActive){
          if(hasSampleHist){
            const toDensity=(bins)=>{
              return bins.map(bin=>{
                const width=(bin.x1??bin.x0)-(bin.x0??bin.x1);
                const density=width>0?(bin.density ?? 0):0;
                histMaxDensity=Math.max(histMaxDensity,density);
                return {...bin,density};
              });
            };
            histPosData=toDensity(state.samplesHist.positives||[]);
            histNegData=toDensity(state.samplesHist.negatives||[]);
          } else {
            const totalPos=empiricalSamples.positives.length;
            const totalNeg=empiricalSamples.negatives.length;
            const total=Math.max(totalPos+totalNeg,1);
            const binCount=Math.min(40,Math.max(10,Math.round(Math.sqrt(total))));
            const binGenerator=(d3.histogram?d3.histogram():d3.bin()).domain([minX,maxX]).thresholds(binCount);
            const toDensity=(bins,totalCount)=>bins.map(bin=>{
              const width=(bin.x1??bin.x0)-(bin.x0??bin.x1);
              const density=(totalCount>0 && width>0)?bin.length/(totalCount*width):0;
              histMaxDensity=Math.max(histMaxDensity,density);
              return {x0:bin.x0,x1:bin.x1,density};
            });
            histPosData=totalPos?toDensity(binGenerator(empiricalSamples.positives),totalPos):[];
            histNegData=totalNeg?toDensity(binGenerator(empiricalSamples.negatives),totalNeg):[];
          }
        }

        const yMax=Math.max(theoreticalMax,histMaxDensity);
        const yUpper=yMax>0?yMax*1.05:1;
        distXScale.domain([minX,maxX]);
        distYScale.domain([0,yUpper]);
        distXAxisGroup.call(d3.axisBottom(distXScale));
        distYAxisGroup.call(d3.axisLeft(distYScale));

        if(visibilityState.score.posPDF){
          distPosLinePath
            .style('display',null)
            .attr('fill',COLOR_HELPERS.posPdfFill)
            .attr('stroke',COLOR_HELPERS.posPdf)
            .datum(dataPoints).attr('d',distPosLineGenerator);
        } else {
          distPosLinePath.style('display','none').attr('d',null);
        }
        if(visibilityState.score.negPDF){
          distNegLinePath
            .style('display',null)
            .attr('fill',COLOR_HELPERS.negPdfFill)
            .attr('stroke',COLOR_HELPERS.negPdf)
            .datum(dataPoints).attr('d',distNegLineGenerator);
        } else {
          distNegLinePath.style('display','none').attr('d',null);
        }

        const renderHist=(group,data,className)=>{
          const selection=group.selectAll('rect').data(data);
          selection.join(
            enter=>enter.append('rect').attr('class',className),
            update=>update,
            exit=>exit.remove()
          )
          .attr('x',d=>distXScale(d.x0))
          .attr('width',d=>{
            const w=distXScale(d.x1)-distXScale(d.x0);
            return Number.isFinite(w)&&w>0?w:0;
          })
          .attr('y',d=>distYScale(d.density))
          .attr('height',d=>Math.max(0,distYScale(0)-distYScale(d.density)));
        };

        if(histActive){
          if(visibilityState.score.posHist){
            histPosGroup.style('display',null);
            renderHist(histPosGroup,histPosData,'hist-pos-bar');
          } else {
            histPosGroup.selectAll('rect').remove();
            histPosGroup.style('display','none');
          }
          if(visibilityState.score.negHist){
            histNegGroup.style('display',null);
            renderHist(histNegGroup,histNegData,'hist-neg-bar');
          } else {
            histNegGroup.selectAll('rect').remove();
            histNegGroup.style('display','none');
          }
        } else {
          histPosGroup.selectAll('rect').remove();
          histNegGroup.selectAll('rect').remove();
          histPosGroup.style('display','none');
          histNegGroup.style('display','none');
        }

        const pointsActive=visibilityState.score.empiricalPoints && hasEmpiricalSamples;
        const rugHeight=8;
        const baseY=distYScale.range()[0];
        const renderRugLines=(group,data)=>{
          group.style('display',null);
          group.selectAll('line')
            .data(data,(_,i)=>i)
            .join(
              enter=>enter.append('line'),
              update=>update,
              exit=>exit.remove()
            )
            .attr('x1',d=>distXScale(d.score))
            .attr('x2',d=>distXScale(d.score))
            .attr('y1',baseY)
            .attr('y2',baseY-rugHeight);
        };
        if(pointsActive){
          const positivePoints=[];
          const negativePoints=[];
          empiricalPointList.forEach(pt=>{
            const score=Number(pt.score);
            if(!Number.isFinite(score)) return;
            const clampedScore=clamp(score,minX,maxX);
            if(Number(pt.label)===1){
              positivePoints.push({score:clampedScore});
            }else{
              negativePoints.push({score:clampedScore});
            }
          });
          renderRugLines(rugPosGroup,positivePoints);
          renderRugLines(rugNegGroup,negativePoints);
        }else{
          rugPosGroup.selectAll('line').remove();
          rugNegGroup.selectAll('line').remove();
          rugPosGroup.style('display','none');
          rugNegGroup.style('display','none');
        }

        const posLeft=dataPoints.filter(d=>d.x<=threshold).map(d=>({x:d.x,y:d.posPDF}));
        const posRight=dataPoints.filter(d=>d.x>=threshold).map(d=>({x:d.x,y:d.posPDF}));
        const negLeft=dataPoints.filter(d=>d.x<=threshold).map(d=>({x:d.x,y:d.negPDF}));
        const negRight=dataPoints.filter(d=>d.x>=threshold).map(d=>({x:d.x,y:d.negPDF}));

        const setArea=(path,data)=>{path.attr('d',data.length>=2?distAreaGenerator(data):null);};
        setArea(areaTNPath,negLeft);
        setArea(areaFPPath,negRight);
        setArea(areaFNPath,posLeft);
        setArea(areaTPPath,posRight);

        thresholdLine
          .attr('x1',distXScale(threshold))
          .attr('x2',distXScale(threshold))
          .attr('y1',distYScale.range()[0])
          .attr('y2',distYScale.range()[1])
          .raise();
        thresholdHandle
          .attr('cx',distXScale(threshold))
          .attr('cy',distYScale.range()[1]-10)
          .raise();

        const rocPairs=dataPoints.map(d=>({thr:d.x,fpr:1-d.negCDF,tpr:1-d.posCDF}));
        const rocSorted=ROCUtils.ensureMonotoneRoc(rocPairs);
        state.rocPairs=rocPairs;
        state.rocPairsSorted=rocSorted;
        const auc=ROCUtils.computeAuc(rocSorted);
        rocTitle.text(STRINGS.plots.rocTitle(auc));

        const sampleCurves=(state.samplesROC||[]).map((entry,idx)=>{
          if(!entry || typeof entry!=='object'){return null;}
          const fpr=Array.isArray(entry.fpr)?entry.fpr:null;
          const tpr=Array.isArray(entry.tpr)?entry.tpr:null;
          if(!fpr||!tpr||fpr.length!==tpr.length||!fpr.length){return null;}
          const points=fpr.map((f,i)=>({fpr:Number(f),tpr:Number(tpr[i])})).filter(pt=>Number.isFinite(pt.fpr)&&Number.isFinite(pt.tpr));
          if(points.length!==fpr.length){return null;}
          return {key:idx,points};
        }).filter(Boolean);
        const samplePaths=rocSampleGroup.selectAll('path.sample-roc')
          .data(sampleCurves,d=>d.key);
        samplePaths.exit().remove();
        samplePaths.enter()
          .append('path')
          .attr('class','sample-roc')
          .merge(samplePaths)
          .attr('d',d=>rocLineGenerator(d.points))
          .attr('stroke',COLOR_HELPERS.sample)
          .attr('stroke-width',1)
          .attr('fill','none')
          .style('display',()=>{
            const visible=visibilityState.roc.sample?.sampleCurves;
            return visible===false?'none':null;
          })
          .lower();

        if(state.estimatedCurve && visibilityState.roc.estimated!==false){
          const estPoints=(state.estimatedCurve.fpr||[]).map((fprVal,idx)=>({fpr:fprVal,tpr:state.estimatedCurve.tpr[idx]})).filter(pt=>Number.isFinite(pt.fpr)&&Number.isFinite(pt.tpr));
          if(estPoints.length>=2){
            estimatedRocPath
              .style('display',null)
              .datum(estPoints)
              .attr('d',rocLineGenerator)
              .attr('stroke',COLOR_HELPERS.estimated)
              .attr('stroke-width',2)
              .attr('fill','none');
          } else {
            estimatedRocPath.style('display','none').attr('d',null);
          }
        } else {
          estimatedRocPath.style('display','none').attr('d',null);
        }

        const drawRocBand=(band,prefix,color)=>{
          const visible=visibilityState.roc.confidenceBand!==false && visibilityState.roc.estimated!==false && state.rocBandMode===prefix && band && Array.isArray(band.fpr) && Array.isArray(band.lower) && Array.isArray(band.upper);
          const bandData=visible?band.fpr.map((fprVal,idx)=>({
            fpr:fprVal,
            lower:band.lower[idx],
            upper:band.upper[idx]
          })).filter(d=>Number.isFinite(d.lower)&&Number.isFinite(d.upper)):[];
          const areaGen=d3.area().curve(d3.curveMonotoneX)
            .x(d=>rocXScale(d.fpr))
            .y0(d=>rocYScale(d.lower))
            .y1(d=>rocYScale(d.upper));
          const lowerLine=d3.line().curve(d3.curveMonotoneX)
            .x(d=>rocXScale(d.fpr))
            .y(d=>rocYScale(d.lower));
          const upperLine=d3.line().curve(d3.curveMonotoneX)
            .x(d=>rocXScale(d.fpr))
            .y(d=>rocYScale(d.upper));
          const areaSel=rocBandGroup.selectAll(`path.band-${prefix}-area`).data(bandData.length?[bandData]:[]);
          areaSel.exit().remove();
          areaSel.enter().append('path').attr('class',`band-${prefix}-area`).merge(areaSel)
            .attr('d',d=>areaGen(d))
            .attr('fill',color)
            .attr('opacity',0.18);
          const lowerSel=rocBandGroup.selectAll(`path.band-${prefix}-lower`).data(bandData.length?[bandData]:[]);
          lowerSel.exit().remove();
          lowerSel.enter().append('path').attr('class',`band-${prefix}-lower`).merge(lowerSel)
            .attr('d',d=>lowerLine(d))
            .attr('stroke',color)
            .attr('stroke-width',1)
            .attr('fill','none');
          const upperSel=rocBandGroup.selectAll(`path.band-${prefix}-upper`).data(bandData.length?[bandData]:[]);
          upperSel.exit().remove();
          upperSel.enter().append('path').attr('class',`band-${prefix}-upper`).merge(upperSel)
            .attr('d',d=>upperLine(d))
            .attr('stroke',color)
            .attr('stroke-width',1)
            .attr('fill','none');
        };

        const findBand=(method)=>{
          if(state.estimatedCurve?.bands){
            const match=state.estimatedCurve.bands.find(b=>b.method===method);
            if(match){return match;}
          }
          return method==='bootstrap'?state.confBand:method==='delong'?state.delongBand:null;
        };
        if(state.rocBandMode==='bootstrap'){
          drawRocBand(findBand('bootstrap'),'bootstrap',COLOR_HELPERS.sample);
          drawRocBand(null,'delong',COLOR_HELPERS.sample);
        } else if(state.rocBandMode==='delong'){
          drawRocBand(null,'bootstrap',COLOR_HELPERS.sample);
          drawRocBand(findBand('delong'),'delong',COLOR_HELPERS.sample);
        } else {
          drawRocBand(null,'bootstrap',COLOR_HELPERS.sample);
          drawRocBand(null,'delong',COLOR_HELPERS.sample);
        }

        if(visibilityState.roc.theoretical && rocSorted.length>=2){
          rocLinePath.style('display',null).datum(rocSorted).attr('d',rocLineGenerator);
        } else {
          rocLinePath.style('display','none').attr('d',null);
        }
        rocXAxisGroup.call(d3.axisBottom(rocXScale).ticks(6));
        rocYAxisGroup.call(d3.axisLeft(rocYScale).ticks(6));

        if(visibilityState.roc.empirical && hasEmpiricalSamples){
          const empiricalRoc=ROCUtils.computeEmpiricalRoc(empiricalPointList);
          if(empiricalRoc.length>=2){
            empiricalRocPath.datum(empiricalRoc).attr('d',rocLineGenerator).style('opacity',1).raise();
          } else {
            empiricalRocPath.attr('d',null).style('opacity',0);
          }
        } else {
          empiricalRocPath.attr('d',null).style('opacity',0);
        }

        const thrPoint=rocPairs.reduce((prev,curr)=>Math.abs(curr.thr-threshold)<Math.abs(prev.thr-threshold)?curr:prev,rocPairs[0]);
        rocPoint.attr('cx',rocXScale(thrPoint.fpr)).attr('cy',rocYScale(thrPoint.tpr)).raise();

        const sensitivity=thrPoint.tpr;
        const specificity=1-thrPoint.fpr;
        const [sensLabel,specLabel]=STRINGS.metrics.confusionHeader;
        document.getElementById('metrics').innerHTML=`<table><tr><th>${sensLabel}</th><th>${specLabel}</th></tr><tr><td>${sensitivity.toFixed(3)}</td><td>${specificity.toFixed(3)}</td></tr></table>`;

        const prevalence=state.prevalence;
        const ppvDen=(sensitivity*prevalence)+((1-specificity)*(1-prevalence));
        const npvDen=((1-sensitivity)*prevalence)+(specificity*(1-prevalence));
        const ppv=ppvDen>0?(sensitivity*prevalence)/ppvDen:0;
        const npv=npvDen>0?(specificity*(1-prevalence))/npvDen:0;
        const accuracy=sensitivity*prevalence+specificity*(1-prevalence);
        const headers=STRINGS.metrics.prevalenceHeader;
        document.getElementById('metricsPrev').innerHTML=`<table><tr><th>${headers[0]}</th><th>${headers[1]}</th><th>${headers[2]}</th></tr><tr><td>${ppv.toFixed(3)}</td><td>${npv.toFixed(3)}</td><td>${accuracy.toFixed(3)}</td></tr></table>`;
        renderLegendSelection();
      }

      function handleDrag(event){
        const [x]=d3.pointer(event,distContent.node());
        const domainX=distXScale.invert(x);
        if(!Number.isFinite(domainX)){return;}
        const clamped=clamp(domainX,state.domain[0],state.domain[1]);
        if(Math.abs(clamped-state.threshold)<1e-6){return;}
        state.thresholdInitialized=true;
        state.threshold=clamped;
        thresholdInput.value=clamped.toFixed(3);
        update();
        showTooltip(STRINGS.metrics.thresholdHandleTooltip(state.threshold),event.sourceEvent||event);
      }

      function handleRocDrag(event){
        const pool=state.rocPairsSorted.length?state.rocPairsSorted:state.rocPairs;
        if(!pool.length){return;}
        const [x]=d3.pointer(event,rocContent.node());
        const targetFpr=clamp(rocXScale.invert(x),0,1);
        const closest=pool.reduce((prev,curr)=>Math.abs(curr.fpr-targetFpr)<Math.abs(prev.fpr-targetFpr)?curr:prev,pool[0]);
        if(Math.abs(closest.thr-state.threshold)>1e-6){
          state.thresholdInitialized=true;
          state.threshold=closest.thr;
          thresholdInput.value=closest.thr.toFixed(3);
          update();
        }
        showTooltip(STRINGS.metrics.thresholdHandleTooltip(state.threshold),event.sourceEvent||event);
      }

      function handleThresholdInput(event){
        const numeric=Number(event.target.value);
        if(!Number.isFinite(numeric)){event.target.value=state.threshold.toFixed(3);return;}
        state.thresholdInitialized=true;
        state.threshold=clamp(numeric,state.domain[0],state.domain[1]);
        update();
      }

      thresholdInput.addEventListener('change',handleThresholdInput);
      thresholdInput.addEventListener('keypress',event=>{
        if(event.key==='Enter'){event.preventDefault();handleThresholdInput(event);} });

      prevalenceSlider.addEventListener('input',event=>{
        const numeric=Number(event.target.value);
        state.prevalence=clamp(numeric,0,1);
        prevalenceValEl.textContent=STRINGS.controls.prevalenceValue(state.prevalence);
        update();
        maybeAutoResample();
      });

      const datasetNameInput=document.getElementById('datasetNameInput');
      if(datasetNameInput){
        datasetNameInput.addEventListener('input',event=>{
          currentEmpiricalDataset.name=event.target.value.trim();
          refreshDataImportStatus();
        });
        setDatasetName(datasetNameInput.value || 'simulated_dataset');
      }else{
        setDatasetName('simulated_dataset');
      }
      refreshDatasetExportState();
      refreshDataImportStatus();

      document.getElementById('dataExportButton').addEventListener('click', exportDataset);
      const rocExportJsonButton=document.getElementById('rocExportJsonButton');
      const rocExportCsvButton=document.getElementById('rocExportCsvButton');
      const rocImportButton=document.getElementById('rocImportJsonButton');
      const rocImportFile=document.getElementById('rocImportFile');
      if(rocExportJsonButton){
        rocExportJsonButton.addEventListener('click', exportRocAsJson);
      }
      if(rocExportCsvButton){
        const showCsvButton=ROC_CONFIG.showAdvancedRocCsvExport !== false;
        rocExportCsvButton.style.display=showCsvButton?'block':'none';
        if(showCsvButton){
          rocExportCsvButton.addEventListener('click', exportRocAsCsv);
        }
      }
      if(rocImportButton && rocImportFile){
        rocImportButton.addEventListener('click',()=>{
          rocImportFile.value='';
          rocImportFile.click();
        });
        rocImportFile.addEventListener('change',event=>{
          const file=event.target.files?.[0];
          if(file){
            const reader=new FileReader();
            reader.onload=e=>{
              try{
                const text=e.target?.result;
                if(typeof text!=='string'){throw new Error('File read failed');}
                const {data}=ROCUtils.parseRocDataFromText(text,file.name);
                handleImportedRocData(data);
              }catch(err){
                alert('Failed to import ROC JSON: '+(err?.message||err));
              }
            };
            reader.readAsText(file);
          }
        });
      }

      function sampleDistribution(prefix, components, nSamples) {
        const samples = [];
        const allowMulti = FEATURES.allowMultiComponents;
        const normalized = allowMulti ? getNormalizedComponents(prefix) : components;
        const totalWeight = allowMulti
          ? normalized.reduce((a, c) => a + (c.weight || 0), 0)
          : 1;

        for (const comp of normalized) {
          const def = DISTRIBUTIONS_INTERNAL[comp.distribution];
          const w = allowMulti ? (comp.weight || 0) / totalWeight : 1;
          const nComp = Math.max(1, Math.round(w * nSamples));
          const params = def.mapper ? def.mapper(comp.parameters) : comp.parameters;

          // Try direct sampling via jStat
          let sampler;
          if (comp.distribution === 'studentT') {
            const mu = Number(params.mu) || 0;
            const sigma = Math.max(Number(params.sigma) || 0, 1e-6);
            const nu = Number(params.nu);
            if (Number.isFinite(nu) && nu <= 1.01) {
              if (jStat.cauchy && jStat.cauchy.sample) {
                sampler = () => jStat.cauchy.sample(mu, sigma);
              } else {
                sampler = () => mu + sigma * Math.tan(Math.PI * (Math.random() - 0.5));
              }
            } else {
              const safeNu = Math.max(nu || 0, 1.01);
              sampler = () => mu + sigma * jStat.studentt.sample(safeNu);
            }
          } else if (jStat[comp.distribution] && jStat[comp.distribution].sample) {
            const vals = Object.values(params);
            sampler = () => jStat[comp.distribution].sample(...vals);
          } else {
            // fallback: inverse-CDF sampling
            sampler = () => {
              const u = Math.random();
              const [lo0, hi0] = def.domain(params);
              let lo = lo0, hi = hi0;
              for (let i = 0; i < 25; i++) {
                const mid = (lo + hi) / 2;
                if (def.cdf(params, mid) < u) lo = mid; else hi = mid;
              }
              return (lo + hi) / 2;
            };
          }

          for (let i = 0; i < nComp; i++) samples.push(sampler());
        }
        return samples;
      }

      function exportDataset() {
        const N = Math.max(10, Number(document.getElementById('sampleSizeInput').value) || 200);
        const prevalence = state.prevalence;
        const nPos = Math.round(N * prevalence);
        const nNeg = N - nPos;

      const posSamples = sampleDistribution('pos', state.posComponents, nPos);
      const negSamples = sampleDistribution('neg', state.negComponents, nNeg);

        applySimulatedData(posSamples, negSamples);

        const rows = [
          ['score', 'label'],
          ...posSamples.map(s => [s.toFixed(6), 1]),
          ...negSamples.map(s => [s.toFixed(6), 0])
        ];

        const csv = rows.map(r => r.join(',')).join('\n');
        const blob = new Blob([csv], { type: 'text/csv' });
        const url = URL.createObjectURL(blob);

        const datasetName = (currentEmpiricalDataset.name || 'simulated_dataset').trim() || 'simulated_dataset';
        const a = document.createElement('a');
        a.href = url;
        a.download = `${datasetName}.csv`;
        a.click();
        URL.revokeObjectURL(url);

        document.getElementById('exportStatus').textContent =
          `Exported ${datasetName} with ${N} samples (${nPos} positive, ${nNeg} negative).`;
      }

      function getExportCurveName(){
        const input=document.getElementById('rocExportName');
        if(!input){
          return 'exported_curve';
        }
        const trimmed=(input.value||'').trim();
        if(!trimmed){
          input.value='exported_curve';
          return 'exported_curve';
        }
        return trimmed;
      }

      function snapshotDistributions(){
        const cloneComponentData=comp=>{
          if(!comp || typeof comp.distribution!=='string' || !comp.distribution.trim()){
            throw new Error('Component is missing a valid distribution id for export.');
          }
          if(!DISTRIBUTIONS_INTERNAL[comp.distribution]){
            console.error('Unknown distribution key during export:', comp.distribution);
            throw new Error(`Unknown distribution key during export: ${comp.distribution}`);
          }
          return {
            distribution:comp.distribution,
            weight:comp.weight,
            parameters:{...comp.parameters}
          };
        };
        return {
          positives:(state.posComponents||[]).map(cloneComponentData),
          negatives:(state.negComponents||[]).map(cloneComponentData)
        };
      }

      function computeEmpiricalHistograms(minX,maxX){
        const hasData=hasEmpiricalData();
        if(!hasData){
          return {positives:[],negatives:[],domain:[minX,maxX],binCount:0};
        }
        const positives=state.importedRawPos;
        const negatives=state.importedRawNeg;
        const total=Math.max(positives.length+negatives.length,1);
        const binCount=Math.min(40,Math.max(10,Math.round(Math.sqrt(total))));
        const binGenerator=(d3.histogram?d3.histogram():d3.bin()).domain([minX,maxX]).thresholds(binCount);
        const toDensity=(bins,totalCount)=>bins.map(bin=>{
          const width=(bin.x1??bin.x0)-(bin.x0??bin.x1);
          const density=(totalCount>0 && width>0)?bin.length/(totalCount*width):0;
          return {x0:bin.x0,x1:bin.x1,density};
        });
        const posBins=positives.length?toDensity(binGenerator(positives),positives.length):[];
        const negBins=negatives.length?toDensity(binGenerator(negatives),negatives.length):[];
        return {positives:posBins,negatives:negBins,domain:[minX,maxX],binCount};
      }

      function computeSampleHistogramsFromSample(posScores,negScores){
        const positives=Array.isArray(posScores)?posScores.map(Number).filter(Number.isFinite):[];
        const negatives=Array.isArray(negScores)?negScores.map(Number).filter(Number.isFinite):[];
        if(!positives.length && !negatives.length){
          return {positives:[],negatives:[],domain:[0,1],binCount:0};
        }
        const minX=Math.min(...positives,...negatives);
        const maxX=Math.max(...positives,...negatives);
        const total=Math.max(positives.length+negatives.length,1);
        const binCount=Math.min(40,Math.max(10,Math.round(Math.sqrt(total))));
        const binGenerator=(d3.histogram?d3.histogram():d3.bin()).domain([minX,maxX]).thresholds(binCount);
        const toDensity=(bins,totalCount)=>bins.map(bin=>{
          const width=(bin.x1??bin.x0)-(bin.x0??bin.x1);
          const density=(totalCount>0 && width>0)?bin.length/(totalCount*width):0;
          return {x0:bin.x0,x1:bin.x1,density};
        });
        const posBins=positives.length?toDensity(binGenerator(positives),positives.length):[];
        const negBins=negatives.length?toDensity(binGenerator(negatives),negatives.length):[];
        return {positives:posBins,negatives:negBins,domain:[minX,maxX],binCount};
      }

      function computeEstimatedCurveFromSamples(samples, bootstrapBand, delongBand, mode){
        if(!Array.isArray(samples) || !samples.length){return null;}
        const fprGrid=d3.range(0,1.000001,0.01);
        const interpolate=(fprArr,tprArr,x)=>{
          const n=fprArr.length;
          if(!n){return null;}
          if(x<=fprArr[0]){return tprArr[0];}
          if(x>=fprArr[n-1]){return tprArr[n-1];}
          const idx=d3.bisectLeft(fprArr,x);
          const x0=fprArr[idx-1],x1=fprArr[idx];
          const y0=tprArr[idx-1],y1=tprArr[idx];
          if(x1===x0){return y0;}
          const t=(x-x0)/(x1-x0);
          return y0+(y1-y0)*t;
        };
        const tpr=[];
        fprGrid.forEach(fpr=>{
          const vals=[];
          samples.forEach(sample=>{
            const fprArr=sample.fpr;
            const tprArr=sample.tpr;
            if(!Array.isArray(fprArr)||!Array.isArray(tprArr)||fprArr.length!==tprArr.length||!fprArr.length){return;}
            const v=interpolate(fprArr,tprArr,fpr);
            if(Number.isFinite(v)){vals.push(v);}
          });
          if(vals.length){
            const mean=vals.reduce((a,b)=>a+b,0)/vals.length;
            tpr.push(mean);
          } else {
            tpr.push(0);
          }
        });
        const points=fprGrid.map((f,i)=>({fpr:f,tpr:tpr[i]}));
        const bands=[];
        if(mode==='bootstrap' && bootstrapBand){
          bands.push({...bootstrapBand,level:0.95,method:'bootstrap',n_samples:samples.length});
        } else if(mode==='delong' && delongBand){
          bands.push({...delongBand,level:0.95,method:'delong',n_samples:samples.length});
        }
        return {fpr:fprGrid,tpr,bands,auc:ROCUtils.computeAuc(points)};
      }

      function pointsToRocArrays(points){
        if(!Array.isArray(points)||!points.length){return null;}
        const fpr=[];
        const tpr=[];
        const thr=[];
        points.forEach(pt=>{
          const f=Number(pt?.fpr);
          const t=Number(pt?.tpr);
          const h=pt?.thr;
          if(Number.isFinite(f)&&Number.isFinite(t)){
            fpr.push(f);
            tpr.push(t);
            thr.push(Number.isFinite(Number(h))?Number(h):null);
          }
        });
        if(!fpr.length||fpr.length!==tpr.length){return null;}
        const hasThr=thr.some(v=>v!==null);
        return hasThr?{fpr,tpr,thr}:{fpr,tpr};
      }

      function buildContinuousMetadata(curveName, auc, minX, maxX, empiricalPointList){
        const distributions=snapshotDistributions();
        const samplingSettings={
          prevalence:state.prevalence,
          sampleSize:Number(document.getElementById('sampleSizeInput')?.value)||200,
          autoResample:state.autoResample,
          dataImported:state.dataImported,
          datasetName:currentEmpiricalDataset.name||null,
          importedSampleCount:state.importedSampleCount||0
        };
        const samplesROC=empiricalPointList?.length?ROCUtils.computeEmpiricalRoc(empiricalPointList):[];
        const samplesArray=[];
        const sampleObject=pointsToRocArrays(samplesROC);
        if(sampleObject){samplesArray.push(sampleObject);}
        const samplesHist=computeEmpiricalHistograms(minX,maxX);
        return {
          name:curveName,
          auc,
          distributions,
          samplingSettings,
          samplesROC:state.samplesROC||samplesArray,
          samplesHist
        };
      }

      function applyImportedContinuousMetadata(curve){
        if(!curve){return false;}
        const meta=ROCUtils.extractContinuousRocMetadata(curve);
        if(!meta){
          state.samplesROC=[];
          state.samplesHist=null;
          visibilityState.roc.sample={sampleCurves:true};
          refreshRocLegend();
          renderLegendSelection();
          return false;
        }
        state.samplesROC=Array.isArray(meta.samplesROC)?meta.samplesROC:[];
        state.samplesHist=meta.samplesHist||null;
        visibilityState.roc.sample={sampleCurves:true};
        state.samplesROC.forEach((_,idx)=>{
          visibilityState.roc.sample[idx]=true;
        });
        computeConfidenceBand();
        refreshRocLegend();
        renderLegendSelection();
        let applied=false;
        isRestoringImportedState=true;
        try{
          const coerceComponents=(arr)=>{
            if(!Array.isArray(arr)){return null;}
            const collection=[];
            arr.forEach(entry=>{
              const distKey=typeof entry.distribution==='string'?entry.distribution.trim():'';
              if(!distKey){
                console.warn('Skipping component with missing distribution key during import.', entry);
                return;
              }
              if(!DISTRIBUTIONS_INTERNAL[distKey]){
                console.warn('Skipping unknown distribution key during import:', distKey);
                return;
              }
              if(typeof entry.weight!=='number' || Number.isNaN(entry.weight)){
                console.warn('Skipping component with invalid weight during import.', entry);
                return;
              }
              if(!entry.parameters || typeof entry.parameters!=='object'){
                console.warn('Skipping component with invalid parameters during import.', entry);
                return;
              }
              const cloned=cloneComponent({distribution:distKey,parameters:entry.parameters,weight:entry.weight});
              collection.push(cloned);
            });
            return collection.length?collection:null;
          };
          if(meta.distributions){
            const pos=meta.distributions.positives;
            const neg=meta.distributions.negatives;
            const posComponents=coerceComponents(pos);
            const negComponents=coerceComponents(neg);
            if(posComponents){
              state.posComponents=posComponents;
              applied=true;
            }
            if(negComponents){
              state.negComponents=negComponents;
              applied=true;
            }
          }
          if(meta.samplingSettings){
            if(meta.samplingSettings.prevalence!==undefined){
              const p=Number(meta.samplingSettings.prevalence);
              if(Number.isFinite(p)){
                state.prevalence=clamp(p,0,1);
                prevalenceSlider.value=state.prevalence;
                prevalenceValEl.textContent=STRINGS.controls.prevalenceValue(state.prevalence);
                applied=true;
              }
            }
            if(meta.samplingSettings.sampleSize!==undefined){
              const input=document.getElementById('sampleSizeInput');
              const val=Number(meta.samplingSettings.sampleSize);
              if(input && Number.isFinite(val) && val>0){
                input.value=val;
                applied=true;
              }
            }
            if(meta.samplingSettings.autoResample!==undefined){
              state.autoResample=Boolean(meta.samplingSettings.autoResample);
              const autoToggle=document.getElementById('autoResampleToggle');
              if(autoToggle){autoToggle.checked=state.autoResample;}
              applied=true;
            }
          }
          if(Array.isArray(meta.samplesROC)){
            state.samplesROC=meta.samplesROC;
            state.samplesROC.forEach((_,idx)=>{
              const key=`sample_${idx}`;
              if(!visibilityState.roc.sample){visibilityState.roc.sample={};}
              if(visibilityState.roc.sample[key]===undefined){visibilityState.roc.sample[key]=true;}
            });
            refreshRocLegend();
            applied=true;
          } else {
            state.samplesROC=[];
            if(visibilityState.roc.sample){visibilityState.roc.sample={};}
            refreshRocLegend();
          }
          if(meta.roc && meta.roc.name){
            const name=String(meta.roc.name);
            const nameInput=document.getElementById('rocExportName');
            if(nameInput){
              nameInput.value=name;
            }
            applied=true;
          }
          resetVisibilityState();
          if(applied){
            renderComponents('neg');
            renderComponents('pos');
            update();
          }
          return applied;
        } finally {
          isRestoringImportedState=false;
        }
      }

      function getPreferredRocPoints(){
        const rocPoints=(state.rocPairsSorted&&state.rocPairsSorted.length?state.rocPairsSorted:state.rocPairs)||[];
        if(rocPoints.length>=2){
          return {points:rocPoints,source:'continuous'};
        }
        return null;
      }

      function buildCanonicalExportCurve(curveName){
        const selection=getPreferredRocPoints();
        if(!selection){
          throw new Error('No ROC curve available to export.');
        }
        const fpr=[];
        const tpr=[];
        selection.points.forEach(point=>{
          const fVal=Number(point.fpr);
          const tVal=Number(point.tpr);
          if(!Number.isFinite(fVal) || !Number.isFinite(tVal)){
            throw new Error('ROC curve contains invalid values.');
          }
          fpr.push(fVal);
          tpr.push(tVal);
        });
        if(!fpr.length){
          throw new Error('ROC curve is empty.');
        }
        const theoreticalName=`${curveName} (theoretical)`;
        const empiricalSamples=getProcessedEmpiricalSamples();
        const hasEmpiricalSamples=empiricalSamples.positives.length>0||empiricalSamples.negatives.length>0;
        const empiricalPointList=hasEmpiricalSamples?getProcessedEmpiricalPoints():[];
        const metadata=buildContinuousMetadata(
          curveName,
          ROCUtils.computeAuc(selection.points),
          state.domain?.[0],
          state.domain?.[1],
          empiricalPointList
        );
        const theoreticalCurve={
          id:theoreticalName,
          name:theoreticalName,
          role:'theoretical',
          type:'ROC',
          fpr,
          tpr,
          auc:ROCUtils.computeAuc(selection.points),
          metadata:{continuous_roc_explorer:metadata}
        };
        const curves=[theoreticalCurve];
        if(state.estimatedCurve && Array.isArray(state.estimatedCurve.fpr) && Array.isArray(state.estimatedCurve.tpr) && state.estimatedCurve.fpr.length===state.estimatedCurve.tpr.length && state.estimatedCurve.fpr.length){
          const estimatedName=`${curveName} (estimated)`;
          const estCurve={
            id:estimatedName,
            name:estimatedName,
            role:'estimated',
            type:'ROC',
            fpr:state.estimatedCurve.fpr,
            tpr:state.estimatedCurve.tpr,
            auc:ROCUtils.computeAuc(state.estimatedCurve.fpr.map((fprVal,idx)=>({fpr:fprVal,tpr:state.estimatedCurve.tpr[idx]}))),
            bands:state.estimatedCurve.bands||[],
            metadata:{
              continuous_roc_explorer:{
                samplesROC:metadata.samplesROC,
                samplingSettings:metadata.samplingSettings,
                distributions:metadata.distributions
              }
            }
          };
          curves.push(estCurve);
        }
        return {curves,source:selection.source};
      }

      function downloadBlob(blob,filename){
        const url=URL.createObjectURL(blob);
        const link=document.createElement('a');
        link.href=url;
        link.download=filename;
        link.click();
        URL.revokeObjectURL(url);
      }

      function exportRocAsJson(){
        const statusEl=document.getElementById('exportStatus');
        const curveName=getExportCurveName();
        try{
          const {curves}=buildCanonicalExportCurve(curveName);
          const canonicalMap=ROCUtils.exportCurvesToJson(curves);
          const blob=ROCUtils.toRocJsonBlob(canonicalMap,`${curveName}.json`);
          downloadBlob(blob,`${curveName}.json`);
          if(statusEl){
            statusEl.textContent=`Exported ${curveName} as JSON.`;
          }
        }catch(err){
          console.error(err);
          if(statusEl){
            statusEl.textContent=err.message||'Failed to export ROC JSON.';
          }
        }
      }

      function exportRocAsCsv(){
        const statusEl=document.getElementById('exportStatus');
        const curveName=getExportCurveName();
        try{
          const {canonicalCurve}=buildCanonicalExportCurve(curveName);
          const canonicalMap={[curveName]:canonicalCurve};
          const csvText=ROCUtils.rocToCsv(canonicalMap);
          const blob=new Blob([csvText],{type:'text/csv'});
          downloadBlob(blob,`${curveName}.csv`);
          if(statusEl){
            statusEl.textContent=`Exported ${curveName} as CSV.`;
          }
        }catch(err){
          console.error(err);
          if(statusEl){
            statusEl.textContent=err.message||'Failed to export ROC CSV.';
          }
        }
      }

      function handleImportedRocData(curveMap){
        try{
          const curves=ROCUtils.importCurvesFromJson(curveMap);
          let applied=false;
          let estimatedApplied=false;
          curves.forEach(curve=>{
            const name=curve.name||'';
            if(name.endsWith('(theoretical)') && curve.metadata?.continuous_roc_explorer){
              const ok=applyImportedContinuousMetadata({metadata:{continuous_roc_explorer:curve.metadata.continuous_roc_explorer}});
              applied=applied||ok;
            } else if(name.endsWith('(estimated)')){
              state.estimatedCurve={
                fpr:curve.fpr||[],
                tpr:curve.tpr||[],
                bands:curve.bands||[]
              };
              if(curve.bands && curve.bands.length){
                const band=curve.bands[0];
                if(band.method==='bootstrap'){state.confBand=band;state.rocBandMode='bootstrap';}
                if(band.method==='delong'){state.delongBand=band;state.rocBandMode='delong';}
              }
              visibilityState.roc.estimated=true;
              estimatedApplied=true;
            }
          });
          refreshRocLegend();
          renderLegendSelection();
          update();
          alert(`Imported ${curves.length} ROC curve${curves.length===1?'':'s'}.`);
        }catch(err){
          console.error(err);
          alert('Failed to import ROC JSON.');
        }
      }

      renderComponents('neg');
      renderComponents('pos');
      update();
      window.applyContinuousRocMetadata=applyImportedContinuousMetadata;
    });
  </script>
</body>
</html>
