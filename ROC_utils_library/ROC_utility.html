<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Costs and Benefits</title>
<style>
  body { font-family: sans-serif; margin: 20px; }
  .container { display: grid; grid-template-columns: 1fr 1fr; gap: 20px; }
  canvas { border: 1px solid #999; border-radius: 6px; }
  label { display: block; margin-top: 8px; }
  input[type=range] { width: 100%; }
  .tooltip { position: absolute; font-size: 12px; background: rgba(255,255,255,0.9); border: 1px solid #ccc; border-radius: 4px; padding: 3px 6px; pointer-events: none; }
  .payoff-grid { border-collapse: collapse; width: 100%; max-width: 360px; }
  .payoff-grid th, .payoff-grid td { border: 1px solid #ccc; padding: 6px; text-align: center; }
  .payoff-grid th { background: #f5f5f5; font-weight: 600; }
  .payoff-cell { display: flex; flex-direction: column; align-items: center; gap: 4px; }
  .slider-input-row { display: flex; align-items: center; gap: 10px; width: 100%; }
  .slider-input-column { display: flex; flex-direction: column; gap: 6px; width: 100%; align-items: stretch; }
  .payoff-cell-label { font-size: 12px; font-weight: 600; }
  .payoff-input-number { width: 80px; }
  .control-container { max-width: 360px; width: 100%; margin: 0 auto; }
  #plotGrid { display: grid; gap: 20px; }
  .grid-area { position: relative; }
  .plot-container { display: flex; flex-direction: column; gap: 10px; }
  .plot-title { font-weight: bold; text-align: center; }
</style>
</head>
<body>
<h1 id="appTitle">Costs and Benefits</h1>
<div id="plotGrid">
  <div id="controlsContainer" class="plot-container">
    <div class="plot-title" id="controlsTitle"></div>
    <div id="controlsContent">
      <label id="dropdownLabel"><span id="dropdownLabelText">Reference model</span>
        <select id="rocSelect"></select>
      </label>
      <div id="importControls" style="margin-top:12px; display:flex; flex-direction:column; gap:6px;">
        <label><span id="importLabelText">Import ROC Data</span>
          <input type="file" id="rocFileInput" accept=".csv,.json,application/json,text/csv">
        </label>
        <button type="button" id="downloadCurveBtn">Download Selected Curve JSON</button>
      </div>
      <div id="slidersSection">
        <div id="priorControls"></div>
        <div id="payoffGridSection" style="margin-top:12px;"></div>
      </div>
      <div id="bestUtility" style="margin-top:1em;font-weight:bold;"></div>
    </div>
  </div>

  <div id="confusionContainer" class="plot-container">
    <div class="plot-title" id="confusionTitle"></div>
    <div id="confusionMatrixContainer" style="margin-top:12px;"></div>
  </div>

  <div id="rocContainer" class="plot-container">
    <div class="plot-title" id="rocPlotTitle"></div>
    <div id="rocElements">
      <canvas id="canvas" width="600" height="600" style="border:1px solid #999; border-radius:6px;"></canvas>
      <div id="tooltip" class="tooltip" style="display:none;"></div>
    </div>
  </div>

  <div id="tocContainer" class="plot-container">
    <div class="plot-title" id="tocPlotTitle"></div>
    <canvas id="tocCanvas" width="600" height="600" style="border:1px solid #999; border-radius:6px;"></canvas>
  </div>

  <div id="prContainer" class="plot-container">
    <div class="plot-title" id="prPlotTitle"></div>
    <canvas id="prCanvas" width="600" height="600" style="border:1px solid #999; border-radius:6px;"></canvas>
  </div>

  <div id="thresholdContainer" class="plot-container">
    <div class="plot-title" id="thresholdPlotTitle"></div>
    <canvas id="thresholdCanvas" width="600" height="600" style="border:1px solid #999; border-radius:6px;"></canvas>
  </div>
</div>
<script src="ROC_utils.js"></script>
<script>
const defaultConfig = {
  strings: {
    pageTitle: "ROC Utility",
    appTitle: "Costs and Benefits",
    dropdownLabel: "Reference model",
    importLabel: "Import ROC Data",
    downloadButton: "Download Selected Curve JSON",
    thresholdTitle: "Payoff vs Threshold",
    bestUtilityPrefix: "Best utility = ",
    bestUtilityUnavailable: "Best utility = —",
    noThresholdData: "No threshold data available for payoff plot.",
    axisThreshold: "Threshold",
    axisUtility: "Expected Utility",
    legendSelectedSuffix: " (selected)",
    legendDerivedSuffix: " (derived thresholds)",
    variantLabelFormat: "{original} ({source})",
    variantSourceFallback: "variant",
    tooltipFormat: "FPR: {fpr}, TPR: {tpr}, U: {utility}",
    controls: {
      title: "Controls"
    },
    payoffGrid: {
      actualPositive: "Actual Positive",
      actualNegative: "Actual Negative",
      predictedPositive: "Predicted Positive",
      predictedNegative: "Predicted Negative",
      TP: "True Positive",
      FN: "False Negative",
      FP: "False Positive",
      TN: "True Negative"
    },
    confusionMatrix: {
      title: "Confusion Matrix (best operating point)"
    },
    plots: {
      roc: {
        title: "Receiver Operating Characteristic Curve",
        xAxisLabel: "False Positive Rate",
        yAxisLabel: "True Positive Rate"
      },
    toc: {
      title: "Total Operating Characteristic Curve",
      xLabel: "Predicted Positives",
      yLabel: "True Positives"
    },
      pr: {
        title: "Precision–Recall Curve",
        xAxisLabel: "Recall",
        yAxisLabel: "Precision"
      },
      threshold: {
        title: "Utility Curves"
      }
    },
    alerts: {
      noCurvesFound: "No ROC curves found in the selected file.",
      failImport: "Failed to import ROC data: {message}",
      failRead: "Unable to read the selected file.",
      noCurveSelectedDownload: "No ROC curve selected to download.",
      failStaticLoad: "Failed to load static ROC file \"{path}\": {message}",
      failConfigLoad: "Failed to load configuration: {message}"
    }
  },
  ui: {
    showRocPlot: true,
    showThresholdPlot: true,
    showSliders: true,
    showImport: true,
    showDownloadButton: true,
    showBestUtility: true,
    showTocPlot: true,
    showPRPlot: true,
    showConfusionMatrix: true,
    thresholdXAxisMode: "quantile", // "threshold" or "quantile"
    showAllCurvesInThresholdPlot: true,
    payoffInputMode: "slider"
  },
  sliders: {
    P_POS: {label: "Proportion positive", min: 0.01, max: 0.99, step: 0.01, value: 0.5},
    N: {label: "Number of units (N)", min: 10, max: 100000, step: 10, value: 1000}
  },
  payoffs: {
    TP: {label: "TP", value: 50, min: -100, max: 100, step: 1},
    FP: {label: "FP", value: -70, min: -100, max: 100, step: 1},
    TN: {label: "TN", value: 0, min: -100, max: 100, step: 1},
    FN: {label: "FN", value: 0, min: -100, max: 100, step: 1}
  },
  data: {
    manifestPath: 'roc_data/roc_manifest.json'
  },
  layout: {
    gridTemplateRows: ["auto", "auto"],
    gridTemplateColumns: ["320px", "1fr", "1fr"],
    areas: [
      ["controls",  "roc",       "toc"],
      ["confusion", "pr",        "threshold"]
    ]
  }
};

const HARDCODED_FALLBACK_CURVES = {
  random_forest_baseline: {
    name: 'random_forest_baseline',
    type: 'ROC',
    fpr: [0, 0.2, 0.4, 0.6, 0.8, 1],
    tpr: [0, 0.5, 0.7, 0.85, 0.9, 1],
    metadata: {source: 'embedded', note: 'Random forest demo curve'}
  },
  logistic_baseline: {
    name: 'logistic_baseline',
    type: 'ROC',
    fpr: [0, 0.2, 0.4, 0.6, 0.8, 1],
    tpr: [0, 0.4, 0.65, 0.8, 0.9, 1],
    metadata: {source: 'embedded', note: 'Logistic regression demo curve'}
  },
  bayesian_model_baseline: {
    name: 'bayesian_model_baseline',
    type: 'ROC',
    fpr: [0, 0.2, 0.4, 0.6, 0.8, 1],
    tpr: [0, 0.45, 0.7, 0.85, 0.9, 1],
    bands: [
      {
        level: 0.95,
        lower: [0, 0.35, 0.6, 0.75, 0.85, 0.95],
        upper: [0, 0.55, 0.8, 0.9, 0.95, 1]
      }
    ],
    metadata: {source: 'embedded', note: 'Bayesian model demo curve'}
  }
};

let rocCurves = {};
let appConfig = cloneDeep(defaultConfig);
let strings = appConfig.strings;
let uiSettings = appConfig.ui;
let lastRocBestUtility = null;
let lastRocBestIdx = null;
let tocPlotCache = {points:[], geometry:null};
let lastBestPoint = {fpr:null,tpr:null};

const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
const thresholdCanvas = document.getElementById('thresholdCanvas');
const thresholdCtx = thresholdCanvas ? thresholdCanvas.getContext('2d') : null;
const tooltip = document.getElementById('tooltip');
const rocSelect = document.getElementById('rocSelect');
const priorControls = document.getElementById('priorControls');
const payoffGridSection = document.getElementById('payoffGridSection');
const tocCanvas = document.getElementById('tocCanvas');
const tocCtx = tocCanvas ? tocCanvas.getContext('2d') : null;
const prCanvas = document.getElementById('prCanvas');
const prCtx = prCanvas ? prCanvas.getContext('2d') : null;
const rocFileInput = document.getElementById('rocFileInput');
const downloadCurveBtn = document.getElementById('downloadCurveBtn');
const bestUtilityDiv = document.getElementById('bestUtility');
const appTitleEl = document.getElementById('appTitle');
const dropdownLabelText = document.getElementById('dropdownLabelText');
const importControls = document.getElementById('importControls');
const importLabelText = document.getElementById('importLabelText');
const slidersSection = document.getElementById('slidersSection');
const confusionMatrixContainer = document.getElementById('confusionMatrixContainer');
const tocContainer = document.getElementById('tocContainer');
let rocPlotContainer = null;
let thresholdSection = null;
let thresholdTitleEl = document.getElementById('thresholdTitle');

const values = {};
const isFileProtocol = typeof location !== 'undefined' && location.protocol === 'file:';

function cloneDeep(obj){
  return JSON.parse(JSON.stringify(obj));
}

function mergeDeep(target, source){
  if(!source || typeof source !== 'object') return target;
  Object.keys(source).forEach(key=>{
    const sourceValue = source[key];
    if(Array.isArray(sourceValue)){
      target[key] = sourceValue.slice();
    }else if(sourceValue && typeof sourceValue === 'object'){
      if(!target[key] || typeof target[key] !== 'object'){
        target[key] = {};
      }
      mergeDeep(target[key], sourceValue);
    }else{
      target[key] = sourceValue;
    }
  });
  return target;
}

function formatString(template, replacements = {}){
  if(!template || typeof template !== 'string') return '';
  return template.replace(/\{([^}]+)\}/g, (_, key)=>{
    const value = key in replacements ? replacements[key] : '';
    return value === undefined || value === null ? '' : String(value);
  });
}

function getPrimaryCurveBand(curve){
  if(!curve || !Array.isArray(curve.bands) || !curve.bands.length) return null;
  const validBands = curve.bands.filter(b=>{
    if(!b || !Array.isArray(b.lower) || !Array.isArray(b.upper)) return false;
    if(!b.lower.length || b.lower.length !== b.upper.length) return false;
    const lengthsMatch = Array.isArray(curve.fpr) ? b.lower.length === curve.fpr.length : true;
    if(!lengthsMatch) return false;
    return b.lower.every(Number.isFinite) && b.upper.every(Number.isFinite);
  });
  if(!validBands.length) return null;
  validBands.sort((a,b)=>{
    const aVal = typeof a.level === 'number' ? a.level : parseFloat(a.level) || 0;
    const bVal = typeof b.level === 'number' ? b.level : parseFloat(b.level) || 0;
    return aVal - bVal;
  });
  return validBands[validBands.length - 1];
}

function updateConfigReferences(){
  strings = appConfig && appConfig.strings ? appConfig.strings : defaultConfig.strings;
  uiSettings = appConfig && appConfig.ui ? appConfig.ui : defaultConfig.ui;
}

updateConfigReferences();

function getAlertTemplate(key){
  const primary = (strings && strings.alerts) ? strings.alerts : {};
  const fallback = (defaultConfig.strings && defaultConfig.strings.alerts) ? defaultConfig.strings.alerts : {};
  return primary[key] || fallback[key] || key;
}

function alertFromConfig(key, params = {}){
  const template = getAlertTemplate(key);
  alert(formatString(template, params));
}

function warnFromConfig(key, params = {}){
  const template = getAlertTemplate(key);
  console.warn(formatString(template, params));
}

function applyConfigToUI(){
  if(strings.pageTitle || strings.appTitle){
    document.title = strings.pageTitle || strings.appTitle;
  }
  if(appTitleEl) appTitleEl.textContent = strings.appTitle || defaultConfig.strings.appTitle;
  if(dropdownLabelText) dropdownLabelText.textContent = strings.dropdownLabel || defaultConfig.strings.dropdownLabel;
  if(importLabelText) importLabelText.textContent = strings.importLabel || defaultConfig.strings.importLabel;
  if(downloadCurveBtn) downloadCurveBtn.textContent = strings.downloadButton || defaultConfig.strings.downloadButton;
  if(thresholdTitleEl) thresholdTitleEl.textContent = strings.thresholdTitle || defaultConfig.strings.thresholdTitle;
  if(importControls) importControls.style.display = isImportVisible() ? 'flex' : 'none';
  if(downloadCurveBtn) downloadCurveBtn.style.display = isDownloadVisible() ? 'inline-block' : 'none';
  if(slidersSection) slidersSection.style.display = isSlidersVisible() ? 'block' : 'none';
  if(rocPlotContainer) rocPlotContainer.style.display = isRocPlotVisible() ? 'block' : 'none';
  if(tocContainer) tocContainer.style.display = isTocPlotVisible() ? 'block' : 'none';
  if(prContainer) prContainer.style.display = isPRPlotVisible() ? 'block' : 'none';
  if(thresholdSection) thresholdSection.style.display = isThresholdPlotVisible() ? 'block' : 'none';
  if(confusionMatrixContainer) confusionMatrixContainer.style.display = (uiSettings && uiSettings.showConfusionMatrix===false) ? 'none' : 'block';
  const controlsContainer = document.getElementById('controlsContainer');
  const confusionContainer = document.getElementById('confusionContainer');
  if(confusionContainer) confusionContainer.style.display = (uiSettings && uiSettings.showConfusionMatrix===false) ? 'none' : 'block';
  if(controlsContainer) controlsContainer.style.display = 'block';
  if(canvas) canvas.style.display = isRocPlotVisible() ? 'block' : 'none';
  if(tocCanvas) tocCanvas.style.display = isTocPlotVisible() ? 'block' : 'none';
  if(prCanvas) prCanvas.style.display = isPRPlotVisible() ? 'block' : 'none';
  if(thresholdSection) thresholdSection.style.display = isThresholdPlotVisible() ? 'block' : 'none';
  if(confusionMatrixContainer) confusionMatrixContainer.style.display = (uiSettings && uiSettings.showConfusionMatrix===false) ? 'none' : 'block';
  if(bestUtilityDiv){
    if(isBestUtilityVisible()){
      bestUtilityDiv.style.display = '';
      if(!bestUtilityDiv.textContent){
        bestUtilityDiv.textContent = strings.bestUtilityUnavailable || defaultConfig.strings.bestUtilityUnavailable;
      }
    }else{
      bestUtilityDiv.style.display = 'none';
      bestUtilityDiv.textContent = '';
    }
  }
}

async function loadAppConfig(){
  if(isFileProtocol){
    appConfig = cloneDeep(defaultConfig);
    updateConfigReferences();
    applyConfigToUI();
    buildControlPanels();
    return;
  }
  let fetchedConfig = null;
  try{
    const response = await fetch('roc_config.json');
    if(!response.ok) throw new Error(`HTTP ${response.status}`);
    fetchedConfig = await response.json();
  }catch(err){
    warnFromConfig('failConfigLoad', {message: err.message || err});
  }
  appConfig = cloneDeep(defaultConfig);
  if(fetchedConfig){
    mergeDeep(appConfig, fetchedConfig);
  }
  updateConfigReferences();
  applyConfigToUI();
  buildControlPanels();
}

function isRocPlotVisible(){ return !(uiSettings && uiSettings.showRocPlot === false); }
function isThresholdPlotVisible(){ return !(uiSettings && uiSettings.showThresholdPlot === false); }
function isTocPlotVisible(){ return !(uiSettings && uiSettings.showTocPlot === false); }
function isPRPlotVisible(){ return !(uiSettings && uiSettings.showPRPlot === false); }
function isSlidersVisible(){ return !(uiSettings && uiSettings.showSliders === false); }
function isImportVisible(){ return !(uiSettings && uiSettings.showImport === false); }
function isDownloadVisible(){ return !(uiSettings && uiSettings.showDownloadButton === false); }
function isBestUtilityVisible(){ return !(uiSettings && uiSettings.showBestUtility === false); }

function resolveVariantLabel(curveId, meta){
  if(!meta || !meta.original_curve_id || meta.original_curve_id === curveId) return curveId;
  const format = strings.variantLabelFormat || "{original} ({source})";
  const sourceLabel = meta.loaded_via || meta.source || strings.variantSourceFallback || defaultConfig.strings.variantSourceFallback;
  return formatString(format, {original: meta.original_curve_id, source: sourceLabel});
}

function loadROCData(data, preferredSelection) {
  const previousSelection = preferredSelection || rocSelect.value;
  rocCurves = data;
  rocSelect.innerHTML = '';
  const curveNames = Object.keys(rocCurves).sort((a,b)=>a.localeCompare(b));
  curveNames.forEach(k => {
    const opt = document.createElement('option');
    opt.value = k;
    const curve = rocCurves[k];
    const meta = curve && curve.metadata;
    opt.textContent = resolveVariantLabel(k, meta);
    rocSelect.appendChild(opt);
  });
  if (previousSelection && rocCurves[previousSelection]) {
    rocSelect.value = previousSelection;
  } else if (rocSelect.options.length) {
    rocSelect.selectedIndex = 0;
  }
  drawAll();
}

function getPayoffParams(){
  return {
    P_POS: values.P_POS,
    TP: values.TP,
    FP: values.FP,
    TN: values.TN,
    FN: values.FN
  };
}

function formatCount(val){
  if(!Number.isFinite(val)) return '—';
  const fixed = val.toFixed(3);
  return fixed.replace(/\.?0+$/,'');
}

function renderConfusionMatrixCounts(opts){
  if(!confusionMatrixContainer) return;
  if(uiSettings && uiSettings.showConfusionMatrix===false){
    confusionMatrixContainer.innerHTML='';
    return;
  }
  const {tp, fp, tn, fn} = opts || {};
  const gridStrings = strings.payoffGrid || defaultConfig.strings.payoffGrid || {};
  const confusionStrings = (strings && strings.confusionMatrix) || (defaultConfig.strings && defaultConfig.strings.confusionMatrix) || {};
  const title = confusionStrings.title || (defaultConfig.strings && defaultConfig.strings.confusionMatrix && defaultConfig.strings.confusionMatrix.title) || 'Confusion Matrix';
  confusionMatrixContainer.innerHTML = '';
  const titleEl = document.createElement('h3');
  titleEl.textContent = title;
  confusionMatrixContainer.appendChild(titleEl);

  const table = document.createElement('table');
  table.className = 'payoff-grid';
  const thead = document.createElement('thead');
  const headerRow = document.createElement('tr');
  headerRow.appendChild(document.createElement('th'));
  const colPos = document.createElement('th');
  colPos.textContent = gridStrings.predictedPositive || 'Predicted Positive';
  const colNeg = document.createElement('th');
  colNeg.textContent = gridStrings.predictedNegative || 'Predicted Negative';
  headerRow.appendChild(colPos);
  headerRow.appendChild(colNeg);
  thead.appendChild(headerRow);
  table.appendChild(thead);

  const tbody = document.createElement('tbody');
  const rowPos = document.createElement('tr');
  const rowPosHeader = document.createElement('th');
  rowPosHeader.textContent = gridStrings.actualPositive || 'Actual Positive';
  rowPos.appendChild(rowPosHeader);
  const tpCell = document.createElement('td');
  tpCell.textContent = formatCount(tp);
  const fnCell = document.createElement('td');
  fnCell.textContent = formatCount(fn);
  rowPos.appendChild(tpCell);
  rowPos.appendChild(fnCell);
  tbody.appendChild(rowPos);

  const rowNeg = document.createElement('tr');
  const rowNegHeader = document.createElement('th');
  rowNegHeader.textContent = gridStrings.actualNegative || 'Actual Negative';
  rowNeg.appendChild(rowNegHeader);
  const fpCell = document.createElement('td');
  fpCell.textContent = formatCount(fp);
  const tnCell = document.createElement('td');
  tnCell.textContent = formatCount(tn);
  rowNeg.appendChild(fpCell);
  rowNeg.appendChild(tnCell);
  tbody.appendChild(rowNeg);

  table.appendChild(tbody);
  confusionMatrixContainer.appendChild(table);
}

function updateConfusionMatrix(){
  if(!confusionMatrixContainer || (uiSettings && uiSettings.showConfusionMatrix===false)){
    return;
  }
  const rocName=rocSelect.value;
  if(!rocName || !rocCurves[rocName] || lastBestPoint.tpr===null || lastBestPoint.fpr===null){
    renderConfusionMatrixCounts({tp:null,fp:null,tn:null,fn:null});
    return;
  }
  const payoffs=getPayoffParams();
  const pPos=payoffs.P_POS;
  const N=getPopulationSize();
  const tpr=lastBestPoint.tpr;
  const fpr=lastBestPoint.fpr;
  const tp = tpr * pPos * N;
  const fn = (1 - tpr) * pPos * N;
  const fp = fpr * (1 - pPos) * N;
  const tn = (1 - fpr) * (1 - pPos) * N;
  renderConfusionMatrixCounts({tp,fp,tn,fn});
}

function getPopulationSize(){
  const sampleCfg = getSampleSizeConfig();
  const defaultVal = Number(sampleCfg && sampleCfg.value);
  ensureValue('N', Number.isFinite(defaultVal) ? defaultVal : 1000);
  return values.N;
}

function utilityAtRates(fpr,tpr,payoffs){
  if(!Number.isFinite(fpr) || !Number.isFinite(tpr)) return NaN;
  const {P_POS, TP, FP, TN, FN} = payoffs;
  const N = getPopulationSize();
  const ap = N * P_POS;
  const an = N * (1 - P_POS);
  const tp = tpr * ap;
  const fn = (1 - tpr) * ap;
  const fp = fpr * an;
  const tn = an - fp;
  return FP * fp + TN * tn + TP * tp + FN * fn;
}

function getIsoCoefficients(payoffs){
  const {P_POS, TP, FP, TN, FN} = payoffs;
  const N = getPopulationSize();
  const ap = N * P_POS;
  const an = N * (1 - P_POS);
  return {
    a: TN * an + FN * ap,
    b: FP * an - TN * an,
    c: TP * ap - FN * ap
  };
}

function getCurveColor(index,total){
  const hue = (index * 360 / Math.max(total, 1)) % 360;
  return `hsl(${hue},70%,45%)`;
}

function getPriorConfig(){
  const sliderDefs = (appConfig && appConfig.sliders) ? appConfig.sliders : defaultConfig.sliders;
  return sliderDefs && sliderDefs.P_POS ? sliderDefs.P_POS : defaultConfig.sliders.P_POS;
}

function getSampleSizeConfig(){
  const sliderDefs = (appConfig && appConfig.sliders) ? appConfig.sliders : defaultConfig.sliders;
  return sliderDefs && sliderDefs.N ? sliderDefs.N : defaultConfig.sliders.N;
}

function getPayoffConfig(){
  const base = defaultConfig.payoffs || {};
  const override = (appConfig && appConfig.payoffs) ? appConfig.payoffs : {};
  const keys = ['TP','FP','TN','FN'];
  const merged = {};
  keys.forEach(key=>{
    merged[key] = Object.assign({}, base[key] || {}, override[key] || {});
  });
  return merged;
}

function getDataConfig(){
  return (appConfig && appConfig.data) || (defaultConfig.data || {});
}

function getManifestPath(){
  const dataCfg = getDataConfig();
  return dataCfg.manifestPath || 'roc_data/roc_manifest.json';
}

function getPayoffInputMode(){
  const mode = uiSettings && uiSettings.payoffInputMode;
  return mode === 'text' ? 'text' : 'slider';
}

function ensureValue(key, defaultVal){
  if(!Number.isFinite(values[key])){
    values[key] = Number.isFinite(defaultVal) ? defaultVal : 0;
  }
}

function getPlotStrings(key){
  const plotGroup = (strings && strings.plots && strings.plots[key]) || null;
  const defaultGroup = (defaultConfig.strings && defaultConfig.strings.plots && defaultConfig.strings.plots[key]) || {};
  return plotGroup || defaultGroup || {};
}

function buildPlotGrid(){
  const plotGrid=document.getElementById('plotGrid');
  if(!plotGrid) return;
  const layoutCfg = (appConfig && appConfig.layout) ? appConfig.layout : (defaultConfig.layout || {});
  const rows = Array.isArray(layoutCfg.gridTemplateRows) ? layoutCfg.gridTemplateRows : ['auto'];
  const cols = Array.isArray(layoutCfg.gridTemplateColumns) ? layoutCfg.gridTemplateColumns : ['1fr'];
  const areas = Array.isArray(layoutCfg.areas) ? layoutCfg.areas : [];
  const controlsContainer = document.getElementById('controlsContainer');
  const confusionContainer = document.getElementById('confusionContainer');
  const rocContainer = document.getElementById('rocContainer');
  const tocContainer = document.getElementById('tocContainer');
  const prContainer = document.getElementById('prContainer');
  const thresholdContainer = document.getElementById('thresholdContainer');
  const knownContainers={controls:controlsContainer,confusion:confusionContainer,roc:rocContainer,toc:tocContainer,pr:prContainer,threshold:thresholdContainer};
  plotGrid.style.display='grid';
  plotGrid.style.gap='20px';
  plotGrid.style.gridTemplateRows=rows.join(' ');
  plotGrid.style.gridTemplateColumns=cols.join(' ');
  if(areas.length){
    const areaString=areas.map(row=>`"${row.join(' ')}"`).join(' ');
    plotGrid.style.gridTemplateAreas=areaString;
  }else{
    plotGrid.style.gridTemplateAreas='';
  }

  const controlsStrings = (strings && strings.controls) || (defaultConfig.strings && defaultConfig.strings.controls) || {};
  const confusionStrings = (strings && strings.confusionMatrix) || (defaultConfig.strings && defaultConfig.strings.confusionMatrix) || {};
  const rocStrings = getPlotStrings('roc');
  const tocStrings = getPlotStrings('toc');
  const prStrings = getPlotStrings('pr');
  const thresholdStrings = getPlotStrings('threshold');

  if(controlsContainer){ const t=document.getElementById('controlsTitle'); if(t) t.textContent = controlsStrings.title || 'Controls'; }
  if(confusionContainer){ const t=document.getElementById('confusionTitle'); if(t) t.textContent = confusionStrings.title || 'Confusion Matrix'; }
  if(rocContainer){ const t=document.getElementById('rocPlotTitle'); if(t) t.textContent = rocStrings.title || ''; }
  if(tocContainer){ const t=document.getElementById('tocPlotTitle'); if(t) t.textContent = tocStrings.title || ''; }
  if(prContainer){ const t=document.getElementById('prPlotTitle'); if(t) t.textContent = prStrings.title || ''; }
  if(thresholdContainer){ const t=document.getElementById('thresholdPlotTitle'); if(t) t.textContent = thresholdStrings.title || (strings.thresholdTitle || defaultConfig.strings.thresholdTitle); }

  // Re-append containers to match grid order
  plotGrid.innerHTML='';
  const addArea=(name)=>{
    const node=knownContainers[name];
    if(node){
      node.style.gridArea=name;
      plotGrid.appendChild(node);
    }
  };
  if(areas.length){
    areas.forEach(row=>{
      Array.isArray(row) && row.forEach(addArea);
    });
  }else{
    Object.keys(knownContainers).forEach(addArea);
  }

  rocPlotContainer = rocContainer || rocPlotContainer;
  thresholdSection = thresholdContainer || thresholdSection;
}

function clampValue(value, min, max){
  if(!Number.isFinite(value)) return null;
  const minNum = Number(min);
  const maxNum = Number(max);
  let result = value;
  if(Number.isFinite(minNum)) result = Math.max(result, minNum);
  if(Number.isFinite(maxNum)) result = Math.min(result, maxNum);
  return result;
}

function bindSliderWithNumber({slider, numberInput, valueSpan, key}){
  if(!slider || !numberInput) return;
  const updateFromSlider = ()=>{
    const val = Number(slider.value);
    values[key] = val;
    numberInput.value = slider.value;
    if(valueSpan) valueSpan.textContent = slider.value;
    drawAll();
  };
  const updateFromNumber = ()=>{
    const parsed = Number(numberInput.value);
    if(!Number.isFinite(parsed)) return;
    const clamped = clampValue(parsed, slider.min, slider.max);
    if(clamped === null) return;
    slider.value = clamped;
    numberInput.value = clamped;
    values[key] = clamped;
    if(valueSpan) valueSpan.textContent = slider.value;
    drawAll();
  };
  slider.addEventListener('input', updateFromSlider);
  numberInput.addEventListener('change', updateFromNumber);
  numberInput.addEventListener('input', ()=>{
    if(Number.isFinite(Number(numberInput.value))){
      updateFromNumber();
    }
  });
  numberInput.addEventListener('blur', ()=>{
    if(!Number.isFinite(Number(numberInput.value))){
      numberInput.value = slider.value;
      return;
    }
    updateFromNumber();
  });
  numberInput.value = slider.value;
  if(valueSpan) valueSpan.textContent = slider.value;
}

function buildControlPanels(){
  buildPriorSlider();
  buildPayoffGrid();
  updateConfusionMatrix();
}

function buildPriorSlider(){
  if(!priorControls) return;
  priorControls.innerHTML = '';
  const priorCfg = getPriorConfig();
  const defaultVal = Number(priorCfg && priorCfg.value);
  ensureValue('P_POS', Number.isFinite(defaultVal) ? defaultVal : 0.5);
  const sampleCfg = getSampleSizeConfig();
  const defaultSampleVal = Number(sampleCfg && sampleCfg.value);
  ensureValue('N', Number.isFinite(defaultSampleVal) ? defaultSampleVal : 1000);
  if(!isSlidersVisible()) return;

  const wrapper = document.createElement('div');
  wrapper.className = 'prior-slider';
  const headerRow = document.createElement('div');
  headerRow.style.display = 'flex';
  headerRow.style.justifyContent = 'space-between';
  headerRow.style.alignItems = 'center';

  const labelSpan = document.createElement('span');
  labelSpan.textContent = (priorCfg && priorCfg.label) || (defaultConfig.sliders.P_POS && defaultConfig.sliders.P_POS.label) || 'Proportion positive';

  const valueSpan = document.createElement('span');
  valueSpan.id = 'P_POSVal';
  valueSpan.textContent = values.P_POS;

  headerRow.appendChild(labelSpan);
  headerRow.appendChild(valueSpan);

  const range = document.createElement('input');
  range.type = 'range';
  range.id = 'P_POS';
  range.min = priorCfg && priorCfg.min !== undefined ? priorCfg.min : 0;
  range.max = priorCfg && priorCfg.max !== undefined ? priorCfg.max : 1;
  range.step = priorCfg && priorCfg.step !== undefined ? priorCfg.step : 0.01;
  range.value = values.P_POS;
  range.style.flex = '1';

  const numberInput = document.createElement('input');
  numberInput.type = 'number';
  numberInput.className = 'payoff-input-number';
  numberInput.min = range.min;
  numberInput.max = range.max;
  numberInput.step = range.step;
  numberInput.value = values.P_POS;

  const sliderRow = document.createElement('div');
  sliderRow.className = 'slider-input-row';
  sliderRow.appendChild(range);
  sliderRow.appendChild(numberInput);

  wrapper.appendChild(headerRow);
  wrapper.appendChild(sliderRow);
  bindSliderWithNumber({slider: range, numberInput, valueSpan, key: 'P_POS'});

  const nWrapper = document.createElement('div');
  nWrapper.style.marginTop = '12px';
  const nHeader = document.createElement('div');
  nHeader.style.display = 'flex';
  nHeader.style.justifyContent = 'space-between';
  nHeader.style.alignItems = 'center';
  const nLabel = document.createElement('span');
  nLabel.textContent = (sampleCfg && sampleCfg.label) || 'Sample size (N)';
  const nValueSpan = document.createElement('span');
  nValueSpan.id = 'NVal';
  nValueSpan.textContent = values.N;
  nHeader.appendChild(nLabel);
  nHeader.appendChild(nValueSpan);

  const nRange = document.createElement('input');
  nRange.type = 'range';
  nRange.id = 'N';
  nRange.min = sampleCfg && sampleCfg.min !== undefined ? sampleCfg.min : 10;
  nRange.max = sampleCfg && sampleCfg.max !== undefined ? sampleCfg.max : 100000;
  nRange.step = sampleCfg && sampleCfg.step !== undefined ? sampleCfg.step : 10;
  nRange.value = values.N;
  nRange.style.flex = '1';

  const nNumberInput = document.createElement('input');
  nNumberInput.type = 'number';
  nNumberInput.className = 'payoff-input-number';
  nNumberInput.min = nRange.min;
  nNumberInput.max = nRange.max;
  nNumberInput.step = nRange.step;
  nNumberInput.value = values.N;

  const nSliderRow = document.createElement('div');
  nSliderRow.className = 'slider-input-row';
  nSliderRow.appendChild(nRange);
  nSliderRow.appendChild(nNumberInput);

  nWrapper.appendChild(nHeader);
  nWrapper.appendChild(nSliderRow);
  bindSliderWithNumber({slider: nRange, numberInput: nNumberInput, valueSpan: nValueSpan, key: 'N'});

  priorControls.appendChild(wrapper);
  priorControls.appendChild(nWrapper);
}

function buildPayoffGrid(){
  if(!payoffGridSection) return;
  const payoffCfg = getPayoffConfig();
  const payoffKeys = ['TP','FN','FP','TN'];
  payoffKeys.forEach(key=>{
    const cfg = payoffCfg[key] || {};
    const defaultVal = Number(cfg.value);
    ensureValue(key, Number.isFinite(defaultVal) ? defaultVal : 0);
  });
  payoffGridSection.innerHTML = '';
  if(!isSlidersVisible()) return;

  const gridStrings = strings.payoffGrid || defaultConfig.strings.payoffGrid || {};
  const mode = getPayoffInputMode();

  const table = document.createElement('table');
  table.className = 'payoff-grid';

  const thead = document.createElement('thead');
  const headerRow = document.createElement('tr');
  headerRow.appendChild(document.createElement('th'));
  const colPos = document.createElement('th');
  colPos.textContent = gridStrings.predictedPositive || 'Predicted Positive';
  headerRow.appendChild(colPos);
  const colNeg = document.createElement('th');
  colNeg.textContent = gridStrings.predictedNegative || 'Predicted Negative';
  headerRow.appendChild(colNeg);
  thead.appendChild(headerRow);
  table.appendChild(thead);

  const tbody = document.createElement('tbody');

  const rowPos = document.createElement('tr');
  const rowPosHeader = document.createElement('th');
  rowPosHeader.textContent = gridStrings.actualPositive || 'Actual Positive';
  rowPos.appendChild(rowPosHeader);
  rowPos.appendChild(createPayoffCell('TP', payoffCfg, mode));
  rowPos.appendChild(createPayoffCell('FN', payoffCfg, mode));
  tbody.appendChild(rowPos);

  const rowNeg = document.createElement('tr');
  const rowNegHeader = document.createElement('th');
  rowNegHeader.textContent = gridStrings.actualNegative || 'Actual Negative';
  rowNeg.appendChild(rowNegHeader);
  rowNeg.appendChild(createPayoffCell('FP', payoffCfg, mode));
  rowNeg.appendChild(createPayoffCell('TN', payoffCfg, mode));
  tbody.appendChild(rowNeg);

  table.appendChild(tbody);
  payoffGridSection.appendChild(table);
}

function createPayoffCell(key, payoffCfg, mode){
  const cfg = payoffCfg[key] || {};
  const gridStrings = strings.payoffGrid || defaultConfig.strings.payoffGrid || {};
  const cell = document.createElement('td');
  const wrapper = document.createElement('div');
  wrapper.className = 'payoff-cell';

  const label = document.createElement('div');
  label.className = 'payoff-cell-label';
  label.textContent = cfg.label || gridStrings[key] || key;
  wrapper.appendChild(label);

  if(mode === 'text'){
    const input = document.createElement('input');
    input.type = 'number';
    input.className = 'payoff-input-number';
    if(cfg.min !== undefined) input.min = cfg.min;
    if(cfg.max !== undefined) input.max = cfg.max;
    if(cfg.step !== undefined) input.step = cfg.step;
    input.value = values[key];
    input.addEventListener('input',()=>{
      const parsed = Number(input.value);
      if(Number.isFinite(parsed)){
        values[key] = parsed;
        drawAll();
      }
    });
    input.addEventListener('blur',()=>{
      if(!Number.isFinite(Number(input.value))){
        input.value = values[key];
      }
    });
    wrapper.appendChild(input);
  }else{
    const range = document.createElement('input');
    range.type = 'range';
    range.min = cfg.min ?? -100;
    range.max = cfg.max ?? 100;
    range.step = cfg.step ?? 1;
    range.value = values[key];
    range.style.width = '100%';
    const numberInput = document.createElement('input');
    numberInput.type = 'number';
    numberInput.className = 'payoff-input-number';
    numberInput.min = range.min;
    numberInput.max = range.max;
    numberInput.step = range.step;
    numberInput.value = values[key];

    const sliderStack = document.createElement('div');
    sliderStack.className = 'slider-input-column';
    sliderStack.appendChild(range);
    sliderStack.appendChild(numberInput);

    wrapper.appendChild(sliderStack);
    bindSliderWithNumber({slider: range, numberInput, valueSpan: null, key});
  }

  cell.appendChild(wrapper);
  return cell;
}

rocSelect.onchange = () => drawAll();
rocFileInput.addEventListener('change', handleDataFileSelection);
downloadCurveBtn.addEventListener('click', downloadSelectedCurveAsJson);

function handleDataFileSelection(evt){
  const inputEl=evt.target;
  const file=inputEl.files && inputEl.files[0];
  if(!file) return;
  const reader=new FileReader();
  reader.onload=()=>{
    try{
      const text=reader.result;
      const ext=(file.name.split('.').pop()||'').toLowerCase();
      const {data:parsed, sourceType}=parseRocDataFromText(text, ext, file.name);
      if(!parsed || !Object.keys(parsed).length){
        alertFromConfig('noCurvesFound');
        return;
      }
      const mergedMetadataKey=file.name || (sourceType==='json'?'import.json':'import.csv');
      const merged={...rocCurves};
      const addedIds=addCurvesToCollection(merged, parsed, {sourceType, sourceFile: mergedMetadataKey});
      if(!addedIds.length){
        alertFromConfig('noCurvesFound');
        return;
      }
      loadROCData(merged,addedIds[0]);
    }catch(err){
      console.error(err);
      alertFromConfig('failImport', {message: err.message});
    }finally{
      inputEl.value='';
    }
  };
  reader.onerror=()=>{
    console.error(reader.error);
    alertFromConfig('failRead', {message: reader.error ? reader.error.message : ''});
    inputEl.value='';
  };
  reader.readAsText(file);
}

function downloadSelectedCurveAsJson(){
  const curveName=rocSelect.value;
  if(!curveName || !rocCurves[curveName]){
    alertFromConfig('noCurveSelectedDownload');
    return;
  }
  const curve=rocCurves[curveName];
  const serialized=JSON.stringify(curve,null,2);
  const blob=new Blob([serialized],{type:'application/json'});
  const url=URL.createObjectURL(blob);
  const link=document.createElement('a');
  link.href=url;
  link.download=`${curveName}.json`;
  document.body.appendChild(link);
  link.click();
  setTimeout(()=>{document.body.removeChild(link);URL.revokeObjectURL(url);},0);
}

function drawAll(){
  if(!rocPlotContainer || !thresholdSection){
    buildPlotGrid();
  }
  if(isRocPlotVisible()){
    drawRocPlot();
  }else{
    ctx.clearRect(0,0,canvas.width,canvas.height);
  }
  if(isTocPlotVisible()){
    drawTOCPlot();
  }else if(tocCtx){
    tocCtx.clearRect(0,0,tocCanvas.width,tocCanvas.height);
  }
  if(isPRPlotVisible()){
    drawPRPlot();
  }else if(prCtx){
    prCtx.clearRect(0,0,prCanvas.width,prCanvas.height);
  }
  updateConfusionMatrix();
  if(isThresholdPlotVisible()){
    drawThresholdPlot();
  }else if(thresholdCtx){
    thresholdCtx.clearRect(0,0,thresholdCanvas.width,thresholdCanvas.height);
  }
}

function deriveCurveNameFromSource(sourceName){
  if(!sourceName) return null;
  const trimmed=String(sourceName).split(/[\\/]/).pop();
  if(!trimmed) return null;
  const withoutExt=trimmed.replace(/\.[^.]+$/,'');
  return withoutExt || trimmed;
}

function parseRocDataFromText(text, extHint, sourceName){
  const defaultCurveName = deriveCurveNameFromSource(sourceName);
  const rocJsonOptions = defaultCurveName ? {defaultCurveName} : undefined;
  try{
    const parsed = ROCUtils.parseRocJsonText(text, rocJsonOptions);
    return {data: parsed, sourceType: 'json'};
  }catch(jsonErr){
    try{
      const parsed = ROCUtils.parseRocCsvText(text);
      return {data: parsed, sourceType: 'csv'};
    }catch(csvErr){
      const error = new Error(csvErr && csvErr.message ? csvErr.message : 'Failed to parse ROC data as JSON or CSV.');
      error.jsonError = jsonErr;
      error.csvError = csvErr;
      throw error;
    }
  }
}

function slugifyLabel(value){
  return String(value||'curve').toLowerCase().replace(/[^a-z0-9]+/g,'-').replace(/^-+|-+$/g,'')||'curve';
}

function addCurvesToCollection(target, parsed, {sourceType, sourceFile} = {}){
  const addedIds=[];
  if(!parsed || typeof parsed!=='object') return addedIds;
  const suffixRoot=slugifyLabel(sourceFile ? sourceFile.split('/').pop().replace(/\.[^.]+$/,'') : '');
  Object.keys(parsed).forEach(originalId=>{
    const baseCurve=parsed[originalId];
    if(!baseCurve) return;
    const curve={...baseCurve};
    const metadata={...(curve.metadata||{})};
    if(sourceType){
      metadata.loaded_via=sourceType;
      if(!metadata.source) metadata.source=sourceType;
    }
    if(sourceFile){
      metadata.source_file=sourceFile;
      metadata.loaded_file=sourceFile;
    }
    if(originalId && metadata.original_curve_id===undefined) metadata.original_curve_id=originalId;
    let baseId=curve.name || originalId || (suffixRoot || 'curve');
    baseId=String(baseId);
    let finalId=baseId;
    if(target[finalId]){
      const baseSlug=slugifyLabel(baseId);
      const suffixBaseRaw = (suffixRoot && suffixRoot !== baseSlug) ? suffixRoot : (sourceType ? slugifyLabel(sourceType) : 'alt');
      const suffixBase = suffixBaseRaw || 'alt';
      let candidate=`${baseId}__${suffixBase}`;
      let counter=2;
      while(target[candidate]){
        candidate=`${baseId}__${suffixBase}_${counter}`;
        counter++;
      }
      finalId=candidate;
    }
    curve.name=finalId;
    curve.metadata=metadata;
    target[finalId]=curve;
    addedIds.push(finalId);
  });
  return addedIds;
}

async function loadStaticRocFiles(){
  if(isFileProtocol){
    console.warn('Skipping static ROC file loads in file:// context; using embedded/fallback curves only.');
    return false;
  }
  const manifestPath = getManifestPath();
  let manifestEntries = [];
  try{
    const response = await fetch(manifestPath);
    if(!response.ok) throw new Error(`HTTP ${response.status}`);
    const manifestJson = await response.json();
    if(Array.isArray(manifestJson)){
      manifestEntries = manifestJson;
    }else if(manifestJson && Array.isArray(manifestJson.files)){
      manifestEntries = manifestJson.files;
    }else{
      manifestEntries = [];
    }
  }catch(err){
    console.error(err);
    warnFromConfig('failStaticLoad', {path: manifestPath, message: err.message || err});
    return false;
  }
  const fileList = manifestEntries.filter(entry=>typeof entry === 'string').map(entry=>entry.trim()).filter(Boolean);
  if(!fileList.length){
    return false;
  }
  let preferredSelection = null;
  let loadedAny = false;
  const merged = {...rocCurves};
  for(const filePath of fileList){
    const trimmedPath = filePath;
    try{
      const response = await fetch(trimmedPath);
      if(!response.ok) throw new Error(`HTTP ${response.status}`);
      const text = await response.text();
      const {data: parsed, sourceType} = parseRocDataFromText(text, trimmedPath.split('.').pop(), trimmedPath);
      const addedIds = addCurvesToCollection(merged, parsed, {sourceType, sourceFile: trimmedPath});
      if(addedIds.length){
        loadedAny = true;
        if(!preferredSelection) preferredSelection = addedIds[0];
      }
    }catch(err){
      console.error(err);
      warnFromConfig('failStaticLoad', {path: trimmedPath, message: err.message || err});
    }
  }
  if(loadedAny){
    loadROCData(merged, preferredSelection);
    return true;
  }
  return false;
}

function hslToRgb(h,s,l){const a=s*Math.min(l,1-l);const f=n=>{const k=(n+h*12)%12;const color=l-a*Math.max(Math.min(k-3,9-k,1),-1);return Math.round(255*color);};return [f(0),f(8),f(4)];}
function heatColor(s){const h=240-240*s;const [r,g,b]=hslToRgb(h/360,0.6,0.85);return [r,g,b];}

function marchingSquares(grid,width,height,levels){
  const segments=[];
  const lerp=(a,b,t)=>a+(b-a)*t;
  const sample=(i,j)=>grid[j*width+i];
  const toCoord=(i,j)=>({x:i/(width-1), y:1 - j/(height-1)});
  levels.forEach(level=>{
    for(let j=0;j<height-1;j++){
      for(let i=0;i<width-1;i++){
        const tl=sample(i,j)>=level;
        const tr=sample(i+1,j)>=level;
        const br=sample(i+1,j+1)>=level;
        const bl=sample(i,j+1)>=level;
        const idx=(tl<<3)|(tr<<2)|(br<<1)|bl;
        if(idx===0||idx===15) continue;
        const vTL=sample(i,j), vTR=sample(i+1,j), vBR=sample(i+1,j+1), vBL=sample(i,j+1);
        const leftT=lerp(j,j+1,(level-vTL)/((vBL-vTL)||1));
        const rightT=lerp(j,j+1,(level-vTR)/((vBR-vTR)||1));
        const topT=lerp(i,i+1,(level-vTL)/((vTR-vTL)||1));
        const bottomT=lerp(i,i+1,(level-vBL)/((vBR-vBL)||1));
        const pLeft=toCoord(i,leftT);
        const pRight=toCoord(i+1,rightT);
        const pTop=toCoord(topT,j);
        const pBottom=toCoord(bottomT,j+1);
        const addSeg=(a,b)=>segments.push([a,b]);
        switch(idx){
          case 1: addSeg(pLeft,pBottom); break;
          case 2: addSeg(pBottom,pRight); break;
          case 3: addSeg(pLeft,pRight); break;
          case 4: addSeg(pTop,pRight); break;
          case 5: addSeg(pTop,pBottom); addSeg(pLeft,pRight); break;
          case 6: addSeg(pTop,pBottom); break;
          case 7: addSeg(pTop,pLeft); break;
          case 8: addSeg(pTop,pLeft); break;
          case 9: addSeg(pTop,pBottom); break;
          case 10: addSeg(pTop,pRight); addSeg(pLeft,pBottom); break;
          case 11: addSeg(pTop,pRight); break;
          case 12: addSeg(pLeft,pRight); break;
          case 13: addSeg(pBottom,pRight); break;
          case 14: addSeg(pLeft,pBottom); break;
        }
      }
    }
  });
  return segments;
}

function getRocPlotGeometry(width,height){
  const marginLeft=0.08*width;
  const marginRight=0.05*width;
  const marginTop=0.12*height;
  const marginBottom=0.10*height;
  const availableW=width - marginLeft - marginRight;
  const availableH=height - marginTop - marginBottom;
  const plotSize=Math.min(availableW, availableH);
  const x0=marginLeft + (availableW-plotSize)/2;
  const y0=marginTop + (availableH-plotSize)/2;
  const plotW=plotSize;
  const plotH=plotSize;
  const titleY = marginTop * 0.5;
  const subtitleY = titleY + 18;
  return {x0,y0,plotW,plotH,titleY,subtitleY};
}

function drawRocPlot(){
  const rocName=rocSelect.value;
  if(!rocName || !rocCurves[rocName]){
    ctx.clearRect(0,0,canvas.width,canvas.height);
    if(bestUtilityDiv && isBestUtilityVisible()){
      bestUtilityDiv.textContent = strings.bestUtilityUnavailable || defaultConfig.strings.bestUtilityUnavailable;
    }
    return;
  }
  const roc=rocCurves[rocName];
  const fpr=roc.fpr, tpr=roc.tpr;
  const primaryBand=getPrimaryCurveBand(roc);
  const lower=primaryBand?primaryBand.lower:null;
  const upper=primaryBand?primaryBand.upper:null;
  const payoffs=getPayoffParams();
  const {P_POS: pPos, TP, FP, TN, FN} = payoffs;
  const width=canvas.width, height=canvas.height;

  const {x0,y0,plotW,plotH,titleY,subtitleY}=getRocPlotGeometry(width,height);
  const labelOffsetFactor = 0.6; const labelOffset = labelOffsetFactor * 0.05;
  const xScale=(xf)=>x0+xf*plotW; const yScale=(yt)=>y0+(1-yt)*plotH;
  const clamp01=(v)=>Math.max(0,Math.min(1,v));

  const {a,b,c}=getIsoCoefficients(payoffs);
  const isoEnabled=Number.isFinite(c) && Math.abs(c)>1e-9;

  ctx.clearRect(0,0,width,height);

  const rocStrings = getPlotStrings('roc');
  const titleText = rocStrings.title || '';
  const subtitleText = resolveVariantLabel(rocName, roc.metadata || {});
  ctx.fillStyle = '#000';
  ctx.textAlign = 'center';
  ctx.font = '16px sans-serif';
  ctx.fillText(titleText, width/2, titleY);
  ctx.font = '13px sans-serif';
  ctx.fillText(subtitleText, width/2, subtitleY);

  const iw=Math.max(2,Math.floor(plotW)); const ih=Math.max(2,Math.floor(plotH));
  const img=ctx.createImageData(iw,ih); const data=img.data; let minU=Infinity,maxU=-Infinity; const utilities=[];
  for(let j=0;j<ih;j++){
    const tprVal=1-j/(ih-1);
    for(let i=0;i<iw;i++){
      const fprVal=i/(iw-1);
      const u=utilityAtRates(fprVal,tprVal,payoffs);
      utilities.push(u);
      if(u<minU)minU=u;
      if(u>maxU)maxU=u;
    }
  }
  const scale=v=>(v-minU)/(maxU-minU||1);
  let k=0;for(let j=0;j<ih;j++){for(let i=0;i<iw;i++){const s=scale(utilities[j*iw+i]);const [r,g,b2]=heatColor(s);data[k++]=r;data[k++]=g;data[k++]=b2;data[k++]=255;}}
  ctx.putImageData(img,Math.round(x0),Math.round(y0));

  ctx.save();
  ctx.beginPath(); ctx.rect(x0,y0,plotW,plotH); ctx.clip();

  if(isoEnabled){
    const nLines=10;
    const step=(maxU-minU)/(nLines+1||1);
    ctx.strokeStyle='rgba(0,0,0,0.4)'; ctx.lineWidth=1; ctx.setLineDash([4,4]);
    ctx.font='12px sans-serif'; ctx.fillStyle='black'; ctx.textBaseline='middle';
    for(let i=1;i<=nLines;i++){
      const level=minU+i*step;
      const tpr0=(level-a-b*0)/c; const tpr1=(level-a-b*1)/c;
      if(!Number.isFinite(tpr0) || !Number.isFinite(tpr1)) continue;
      const yA=yScale(tpr0), yB=yScale(tpr1);
      ctx.beginPath(); ctx.moveTo(xScale(0),yA); ctx.lineTo(xScale(1),yB); ctx.stroke();

      const tprLeft=(level-a)/c;
      const fprBottom=(level-a)/b;
      const offsetX = labelOffset * plotW; const offsetY = labelOffset * plotH;
      if(Number.isFinite(tprLeft) && tprLeft>=0 && tprLeft<=1){
        const xL=xScale(0)+offsetX; const yL=yScale(tprLeft);
        ctx.fillText(Math.round(level),xL,yL);
      } else if(Number.isFinite(fprBottom) && fprBottom>=0 && fprBottom<=1){
        const xB=xScale(clamp01(fprBottom)); const yBtm=yScale(0)-offsetY;
        ctx.textAlign='center'; ctx.fillText(Math.round(level),xB,yBtm); ctx.textAlign='left';
      }
    }
    ctx.setLineDash([]);
  }
  else{
    ctx.setLineDash([]);
  }

  const denominator = (pPos*(TP-FN));
  if(denominator){
    const s=((1-pPos)*(TN-FP))/denominator;
    ctx.strokeStyle='limegreen'; ctx.lineWidth=3; ctx.setLineDash([10,10]);
    const drawOne=(intercept)=>{ctx.beginPath();ctx.moveTo(xScale(0),yScale(intercept));ctx.lineTo(xScale(1),yScale(s+intercept));ctx.stroke();};
    drawOne(0); drawOne(1-s); ctx.setLineDash([]);
  }

  ctx.restore();

  if(Array.isArray(lower) && Array.isArray(upper) && lower.length===fpr.length && upper.length===fpr.length){
    ctx.beginPath(); ctx.moveTo(xScale(fpr[0]),yScale(upper[0])); for(let i=1;i<fpr.length;i++)ctx.lineTo(xScale(fpr[i]),yScale(upper[i])); for(let i=fpr.length-1;i>=0;i--)ctx.lineTo(xScale(fpr[i]),yScale(lower[i])); ctx.closePath(); ctx.fillStyle='rgba(0,0,255,0.2)'; ctx.fill();
    ctx.beginPath(); ctx.strokeStyle='rgba(0,0,180,0.6)'; ctx.lineWidth=1;
    for(let i=0;i<fpr.length;i++){if(i===0)ctx.moveTo(xScale(fpr[i]),yScale(upper[i]));else ctx.lineTo(xScale(fpr[i]),yScale(upper[i]));} ctx.stroke();
    ctx.beginPath(); for(let i=0;i<fpr.length;i++){if(i===0)ctx.moveTo(xScale(fpr[i]),yScale(lower[i]));else ctx.lineTo(xScale(fpr[i]),yScale(lower[i]));} ctx.stroke();
  }

  let bestU=-Infinity,bestPt=null,bestIdx=-1;
  ctx.beginPath(); ctx.strokeStyle='blue'; ctx.lineWidth=2;
  let firstPoint=true;
  for(let i=0;i<fpr.length;i++){
    const fVal=Number(fpr[i]);
    const tVal=Number(tpr[i]);
    if(!Number.isFinite(fVal) || !Number.isFinite(tVal)) continue;
    const x=xScale(fVal),y=yScale(tVal);
    if(firstPoint){ctx.moveTo(x,y); firstPoint=false;} else ctx.lineTo(x,y);
    const u=utilityAtRates(fVal,tVal,payoffs);
    if(Number.isFinite(u) && u>bestU){bestU=u;bestPt={x,y};bestIdx=i;}
  }
  if(!firstPoint) ctx.stroke();
  if(bestPt){
    ctx.beginPath();ctx.arc(bestPt.x,bestPt.y,6,0,2*Math.PI);
    ctx.fillStyle='yellow';ctx.strokeStyle='red';ctx.fill();ctx.stroke();
    lastRocBestUtility = bestU;
    lastRocBestIdx = bestIdx;
    lastBestPoint = {fpr: Number(fpr[bestIdx]), tpr: Number(tpr[bestIdx])};
    if(bestUtilityDiv && isBestUtilityVisible()){
      const prefix = strings.bestUtilityPrefix || defaultConfig.strings.bestUtilityPrefix;
      bestUtilityDiv.textContent = `${prefix}${Math.round(bestU)}`;
    }
  } else if(bestUtilityDiv && isBestUtilityVisible()){
    bestUtilityDiv.textContent = strings.bestUtilityUnavailable || defaultConfig.strings.bestUtilityUnavailable;
  }

  ctx.strokeStyle='#666'; ctx.lineWidth=1; ctx.strokeRect(x0,y0,plotW,plotH);

  ctx.strokeStyle='#333'; ctx.fillStyle='#333'; ctx.lineWidth=1;
  ctx.font='11px sans-serif'; ctx.textAlign='center'; ctx.textBaseline='top';
  const tickCount=11;
  for(let i=0;i<tickCount;i++){
    const val=i/10;
    const x=xScale(val);
    const yBottom=yScale(0);
    ctx.beginPath(); ctx.moveTo(x,yBottom); ctx.lineTo(x,yBottom+6); ctx.stroke();
    ctx.fillText(val.toFixed(1), x, yBottom+8);
  }
  ctx.textAlign='right'; ctx.textBaseline='middle';
  for(let i=0;i<tickCount;i++){
    const val=i/10;
    const y=yScale(val);
    const xLeft=xScale(0);
    ctx.beginPath(); ctx.moveTo(xLeft-6,y); ctx.lineTo(xLeft,y); ctx.stroke();
    ctx.fillText(val.toFixed(1), xLeft-8, y);
  }

  ctx.font='13px sans-serif'; ctx.textAlign='center'; ctx.textBaseline='top';
  const xAxisLabel=rocStrings.xAxisLabel || '';
  ctx.fillText(xAxisLabel, x0 + plotW/2, y0 + plotH + 28);
  ctx.save();
  ctx.translate(x0 - 36, y0 + plotH/2);
  ctx.rotate(-Math.PI/2);
  const yAxisLabel=rocStrings.yAxisLabel || '';
  ctx.textBaseline='top'; ctx.fillText(yAxisLabel, 0, 0);
  ctx.restore();
}

function drawTOCPlot(){
  if(!tocCanvas || !tocCtx) return;
  const width=tocCanvas.width, height=tocCanvas.height;
  tocCtx.clearRect(0,0,width,height);
  if(!isTocPlotVisible()) return;
  const rocName=rocSelect.value;
  if(!rocName || !rocCurves[rocName]) return;
  const roc=rocCurves[rocName];
  const fprArr=roc.fpr, tprArr=roc.tpr;
  if(!Array.isArray(fprArr) || !Array.isArray(tprArr) || fprArr.length!==tprArr.length) return;
  const payoffs=getPayoffParams();
  const pPos=payoffs.P_POS;
  const Npop=getPopulationSize();
  const P=Math.max(0, pPos * Npop);
  const Nn=Math.max(0, (1 - pPos) * Npop);
  const xMax=Math.max(1, Npop);
  const yMax=Math.max(1, P||1);
  const tocStrings=getPlotStrings('toc');
  const {x0,y0,plotW,plotH,titleY,subtitleY}=getRocPlotGeometry(width,height);
  const xScale=(val)=>x0 + (val/xMax)*plotW;
  const yScale=(val)=>y0 + (1 - (val/(yMax||1)))*plotH;

  const poly=[{x:0,y:0},{x:Nn,y:0},{x:Nn+P,y:P},{x:P,y:P}];
  const steps=120;
  let minU=Infinity,maxU=-Infinity;
  const utilGrid=[];
  for(let j=0;j<=steps;j++){
    const yVal=(j/steps)*P;
    for(let i=0;i<=steps;i++){
      const xVal=(i/steps)*xMax;
      const tp=yVal;
      const fp=xVal - yVal;
      const reachable = fp>=-1e-9 && fp<=Nn+1e-9 && tp>=0 && tp<=P+1e-9 && tp>=xVal-Nn-1e-9 && tp<=Math.min(xVal,P)+1e-9;
      if(!reachable){
        utilGrid.push(null);
        continue;
      }
      const tpr = P>0 ? tp/P : 0;
      const fpr = Nn>0 ? Math.max(0,Math.min(1,fp/Nn)) : 0;
      const u=utilityAtRates(fpr,tpr,payoffs);
      utilGrid.push(u);
      if(Number.isFinite(u)){
        if(u<minU) minU=u;
        if(u>maxU) maxU=u;
      }
    }
  }
  const scale=v=>(v-minU)/(maxU-minU||1);
  tocCtx.save();
  tocCtx.beginPath();
  tocCtx.moveTo(xScale(poly[0].x), yScale(poly[0].y));
  for(let k=1;k<poly.length;k++) tocCtx.lineTo(xScale(poly[k].x), yScale(poly[k].y));
  tocCtx.closePath();
  tocCtx.clip();

  const cellW=plotW/steps;
  const cellH=plotH/steps;
  let idx=0;
  for(let j=0;j<=steps;j++){
    for(let i=0;i<=steps;i++){
      const u=utilGrid[idx++];
      if(u===null || !Number.isFinite(u)) continue;
      const s=scale(u);
      const [r,g,b]=heatColor(s);
      tocCtx.fillStyle=`rgb(${r},${g},${b})`;
      tocCtx.fillRect(x0 + i*cellW, y0 + (steps-j)*cellH, cellW+1, cellH+1);
    }
  }
  tocCtx.restore();

  tocCtx.fillStyle = '#000';
  tocCtx.textAlign = 'center';
  tocCtx.font = '16px sans-serif';
  const titleText = tocStrings.title || '';
  tocCtx.fillText(titleText, width/2, titleY);
  tocCtx.font = '13px sans-serif';
  const subtitleText = resolveVariantLabel(rocName, roc.metadata || {});
  tocCtx.fillText(subtitleText, width/2, subtitleY);

  const tocPoints=[];
  for(let i=0;i<fprArr.length;i++){
    const fpr=Number(fprArr[i]);
    const tpr=Number(tprArr[i]);
    if(!Number.isFinite(fpr) || !Number.isFinite(tpr)) continue;
    const tp=tpr*P;
    const fp=fpr*Nn;
    const x=tp+fp;
    const y=tp;
    tocPoints.push({x,y,fpr,tpr});
  }

  tocCtx.beginPath();
  tocCtx.moveTo(xScale(poly[0].x), yScale(poly[0].y));
  for(let k=1;k<poly.length;k++) tocCtx.lineTo(xScale(poly[k].x), yScale(poly[k].y));
  tocCtx.closePath();
  tocCtx.strokeStyle='#666';
  tocCtx.lineWidth=1;
  tocCtx.stroke();

  if(tocPoints.length){
    tocCtx.beginPath();
    tocPoints.forEach((pt,idx)=>{
      const px=xScale(pt.x);
      const py=yScale(pt.y);
      if(idx===0) tocCtx.moveTo(px,py); else tocCtx.lineTo(px,py);
    });
    tocCtx.strokeStyle='blue';
    tocCtx.lineWidth=2;
    tocCtx.stroke();
  }

  if(lastBestPoint && lastBestPoint.tpr!==null && lastBestPoint.fpr!==null){
    const tp=lastBestPoint.tpr*P;
    const fp=lastBestPoint.fpr*Nn;
    const bx=xScale(tp+fp);
    const by=yScale(tp);
    tocCtx.beginPath();
    tocCtx.arc(bx,by,6,0,Math.PI*2);
    tocCtx.fillStyle='yellow';
    tocCtx.strokeStyle='red';
    tocCtx.fill();
    tocCtx.stroke();
  }

  tocCtx.strokeStyle='#666'; tocCtx.lineWidth=1; tocCtx.strokeRect(x0,y0,plotW,plotH);

  tocCtx.strokeStyle='#333'; tocCtx.fillStyle='#333'; tocCtx.lineWidth=1;
  tocCtx.font='11px sans-serif'; tocCtx.textAlign='center'; tocCtx.textBaseline='top';
  const tickCount=6;
  for(let i=0;i<tickCount;i++){
    const val=i/(tickCount-1||1)*xMax;
    const x=xScale(val);
    const yBottom=yScale(0);
    tocCtx.beginPath(); tocCtx.moveTo(x,yBottom); tocCtx.lineTo(x,yBottom+6); tocCtx.stroke();
    tocCtx.fillText(val.toFixed(0), x, yBottom+8);
  }
  tocCtx.textAlign='right'; tocCtx.textBaseline='middle';
  for(let i=0;i<tickCount;i++){
    const val=i/(tickCount-1||1)*yMax;
    const y=yScale(val);
    const xLeft=xScale(0);
    tocCtx.beginPath(); tocCtx.moveTo(xLeft-6,y); tocCtx.lineTo(xLeft,y); tocCtx.stroke();
    tocCtx.fillText(val.toFixed(0), xLeft-8, y);
  }

  tocCtx.font='13px sans-serif'; tocCtx.textAlign='center'; tocCtx.textBaseline='top';
  const xAxisLabel=tocStrings.xLabel || '';
  tocCtx.fillText(xAxisLabel, x0 + plotW/2, y0 + plotH + 28);
  tocCtx.save();
  tocCtx.translate(x0 - 36, y0 + plotH/2);
  tocCtx.rotate(-Math.PI/2);
  const yAxisLabel=tocStrings.yLabel || '';
  tocCtx.textBaseline='top'; tocCtx.fillText(yAxisLabel, 0, 0);
  tocCtx.restore();

  tocPlotCache = {
    points: tocPoints,
    geometry: {x0,y0,plotW,plotH,xMax,yMax,P,Nn,Npop}
  };
}


function drawPRPlot(){
  if(!prCanvas || !prCtx) return;
  const width=prCanvas.width, height=prCanvas.height;
  prCtx.clearRect(0,0,width,height);
  if(!isPRPlotVisible()) return;
  const rocName=rocSelect.value;
  if(!rocName || !rocCurves[rocName]) return;
  const roc=rocCurves[rocName];
  const fprArr=roc.fpr, tprArr=roc.tpr;
  if(!Array.isArray(fprArr) || !Array.isArray(tprArr) || fprArr.length!==tprArr.length) return;
  const payoffs=getPayoffParams();
  const pPos=payoffs.P_POS;
  const {x0,y0,plotW,plotH,titleY,subtitleY}=getRocPlotGeometry(width,height);
  const xScale=(xf)=>x0+xf*plotW; const yScale=(yt)=>y0+(1-yt)*plotH;

  const iw=Math.max(2,Math.floor(plotW)); const ih=Math.max(2,Math.floor(plotH));
  const img=prCtx.createImageData(iw,ih); const data=img.data;
  let minU=Infinity,maxU=-Infinity;
  for(let j=0;j<ih;j++){
    const recall=1-j/(ih-1);
    for(let i=0;i<iw;i++){
      const precision=i/(iw-1);
      const denom=Math.max(1e-9,1-pPos);
      let fprVal=precision>0 ? (recall*(1/precision -1)*pPos)/denom : 1;
      fprVal=Math.max(0,Math.min(1,fprVal));
      const u=utilityAtRates(fprVal,recall,payoffs);
      const idx=j*iw+i;
      data[idx*4+3]=255;
      if(u<minU) minU=u;
      if(u>maxU) maxU=u;
    }
  }
  const scale=v=>(v-minU)/(maxU-minU||1);
  for(let j=0;j<ih;j++){
    for(let i=0;i<iw;i++){
      const recall=1-j/(ih-1);
      const precision=i/(iw-1);
      const denom=Math.max(1e-9,1-pPos);
      let fprVal=precision>0 ? (recall*(1/precision -1)*pPos)/denom : 1;
      fprVal=Math.max(0,Math.min(1,fprVal));
      const u=utilityAtRates(fprVal,recall,payoffs);
      const s=scale(u);
      const [r,g,b]=heatColor(s);
      const idx=j*iw+i;
      data[idx*4]=r; data[idx*4+1]=g; data[idx*4+2]=b; data[idx*4+3]=255;
    }
  }
  prCtx.putImageData(img,Math.round(x0),Math.round(y0));

  prCtx.fillStyle = '#000';
  prCtx.textAlign = 'center';
  prCtx.font = '16px sans-serif';
  const prStrings = getPlotStrings('pr');
  const titleText = prStrings.title || '';
  prCtx.fillText(titleText, width/2, titleY);
  prCtx.font = '13px sans-serif';
  const subtitleText = resolveVariantLabel(rocName, roc.metadata || {});
  prCtx.fillText(subtitleText, width/2, subtitleY);

  prCtx.save();
  prCtx.beginPath(); prCtx.rect(x0,y0,plotW,plotH); prCtx.clip();

  const prPoints=[];
  for(let i=0;i<fprArr.length;i++){
    const fprVal=Number(fprArr[i]);
    const tprVal=Number(tprArr[i]);
    if(!Number.isFinite(fprVal) || !Number.isFinite(tprVal)) continue;
    if(fprVal===0 && tprVal===0) continue;
    const precision = (tprVal*pPos)/Math.max(1e-9, tprVal*pPos + fprVal*(1-pPos));
    prPoints.push({recall:tprVal, precision});
  }
  prPoints.sort((a,b)=>a.recall-b.recall);
  if(prPoints.length){
    prCtx.beginPath();
    prPoints.forEach((pt,idx)=>{
      const px=xScale(pt.recall);
      const py=yScale(pt.precision);
      if(idx===0) prCtx.moveTo(px,py);
      else prCtx.lineTo(px,py);
    });
    prCtx.strokeStyle='blue';
    prCtx.lineWidth=2;
    prCtx.stroke();
  }

  prCtx.restore();

  prCtx.strokeStyle='#666'; prCtx.lineWidth=1; prCtx.strokeRect(x0,y0,plotW,plotH);

  prCtx.strokeStyle='#333'; prCtx.fillStyle='#333'; prCtx.lineWidth=1;
  prCtx.font='11px sans-serif'; prCtx.textAlign='center'; prCtx.textBaseline='top';
  const tickCount=11;
  for(let i=0;i<tickCount;i++){
    const val=i/10;
    const x=xScale(val);
    const yBottom=yScale(0);
    prCtx.beginPath(); prCtx.moveTo(x,yBottom); prCtx.lineTo(x,yBottom+6); prCtx.stroke();
    prCtx.fillText(val.toFixed(1), x, yBottom+8);
  }
  prCtx.textAlign='right'; prCtx.textBaseline='middle';
  for(let i=0;i<tickCount;i++){
    const val=i/10;
    const y=yScale(val);
    const xLeft=xScale(0);
    prCtx.beginPath(); prCtx.moveTo(xLeft-6,y); prCtx.lineTo(xLeft,y); prCtx.stroke();
    prCtx.fillText(val.toFixed(1), xLeft-8, y);
  }

  prCtx.font='13px sans-serif'; prCtx.textAlign='center'; prCtx.textBaseline='top';
  const xAxisLabel=prStrings.xAxisLabel || '';
  prCtx.fillText(xAxisLabel, x0 + plotW/2, y0 + plotH + 28);
  prCtx.save();
  prCtx.translate(x0 - 36, y0 + plotH/2);
  prCtx.rotate(-Math.PI/2);
  const yAxisLabel=prStrings.yAxisLabel || '';
  prCtx.textBaseline='top'; prCtx.fillText(yAxisLabel, 0, 0);
  prCtx.restore();
}

function drawThresholdPlot(){
  if(!thresholdCanvas || !thresholdCtx){
    return;
  }
  const width=thresholdCanvas.width;
  const height=thresholdCanvas.height;
  thresholdCtx.clearRect(0,0,width,height);
  if(!isThresholdPlotVisible()){
    return;
  }

  const payoffs=getPayoffParams();
  const pPos = payoffs.P_POS;
  const curveIds=Object.keys(rocCurves).sort((a,b)=>a.localeCompare(b));
  const selectedId=rocSelect.value;
  const showAll = !(uiSettings && uiSettings.showAllCurvesInThresholdPlot===false);
  const xMode = (uiSettings && uiSettings.thresholdXAxisMode==='quantile') ? 'quantile' : 'threshold';
  const curveIdsToPlot = showAll ? curveIds : (selectedId ? [selectedId] : []);

  const datasets=[];
  let minThreshold=Infinity,maxThreshold=-Infinity,minUtility=Infinity,maxUtility=-Infinity;

  const buildThresholdSeries=(curve,length)=>{
    if(Array.isArray(curve.threshold) && curve.threshold.length>=length){
      const values=[];
      let valid=true;
      for(let i=0;i<length;i++){
        const value=Number(curve.threshold[i]);
        if(Number.isFinite(value)){
          values.push(value);
        }else{
          valid=false;
          break;
        }
      }
      if(valid){
        return {values, synthetic:false, source:'threshold'};
      }
    }
    if(Array.isArray(curve.fpr) && curve.fpr.length>=length){
      const values=[];
      let valid=true;
      for(let i=0;i<length;i++){
        const value=Number(curve.fpr[i]);
        if(Number.isFinite(value)){
          values.push(value);
        }else{
          valid=false;
          break;
        }
      }
      if(valid){
        return {values, synthetic:true, source:'fpr'};
      }
    }
    const values=[];
    if(length<=1){
      values.push(0);
    }else{
      for(let i=0;i<length;i++){
        values.push(i/(length-1));
      }
    }
    return {values, synthetic:true, source:'index'};
  };

  curveIdsToPlot.forEach((curveId)=>{
    const curve=rocCurves[curveId];
    if(!curve) return;
    if(!Array.isArray(curve.fpr) || !Array.isArray(curve.tpr)) return;
    const length=Math.min(curve.fpr.length, curve.tpr.length);
    if(!length) return;
    const thresholdSeries=buildThresholdSeries(curve,length);
    const primaryBand=getPrimaryCurveBand(curve);
    const lower=primaryBand?primaryBand.lower:null;
    const upper=primaryBand?primaryBand.upper:null;
    const entries=[];
    const bandEntries=[];
    const colorIndex = Math.max(0, curveIds.indexOf(curveId));
    for(let i=0;i<length;i++){
      const fpr=Number(curve.fpr[i]);
      const tpr=Number(curve.tpr[i]);
      if(!Number.isFinite(fpr) || !Number.isFinite(tpr)) continue;
      const xVal = xMode==='quantile' ? (pPos*tpr + (1-pPos)*fpr) : Number(thresholdSeries.values[i]);
      if(!Number.isFinite(xVal)) continue;
      const utility=utilityAtRates(fpr,tpr,payoffs);
      if(!Number.isFinite(utility)) continue;
      let lowerUtility=null, upperUtility=null;
      if(Array.isArray(lower) && lower.length>i && Number.isFinite(Number(lower[i]))){
        lowerUtility=utilityAtRates(fpr, Number(lower[i]), payoffs);
      }
      if(Array.isArray(upper) && upper.length>i && Number.isFinite(Number(upper[i]))){
        upperUtility=utilityAtRates(fpr, Number(upper[i]), payoffs);
      }
      entries.push({x:xVal, utility, idx:i});
      bandEntries.push({x:xVal, lower:lowerUtility, upper:upperUtility});
    }
    if(!entries.length) return;
    entries.sort((a,b)=>a.x-b.x || a.utility-b.utility);
    bandEntries.sort((a,b)=>a.x-b.x);
    entries.forEach(pt=>{
      if(pt.x<minThreshold) minThreshold=pt.x;
      if(pt.x>maxThreshold) maxThreshold=pt.x;
      if(pt.utility<minUtility) minUtility=pt.utility;
      if(pt.utility>maxUtility) maxUtility=pt.utility;
    });
    bandEntries.forEach(pt=>{
      if(Number.isFinite(pt.lower)){
        if(pt.lower<minUtility) minUtility=pt.lower;
        if(pt.lower>maxUtility) maxUtility=pt.lower;
      }
      if(Number.isFinite(pt.upper)){
        if(pt.upper<minUtility) minUtility=pt.upper;
        if(pt.upper>maxUtility) maxUtility=pt.upper;
      }
    });
    const meta=curve.metadata||{};
    const baseLabel = resolveVariantLabel(curveId, meta);
    datasets.push({
      id:curveId,
      label:baseLabel,
      entries,
      bandEntries,
      color:getCurveColor(colorIndex, curveIds.length),
      isSelected: curveId===selectedId,
      synthetic: thresholdSeries.synthetic
    });
  });

  if(!datasets.length){
    thresholdCtx.fillStyle='#333';
    thresholdCtx.font='16px sans-serif';
    thresholdCtx.textAlign='center';
    thresholdCtx.textBaseline='middle';
    thresholdCtx.fillText(strings.noThresholdData || defaultConfig.strings.noThresholdData, width/2, height/2);
    return;
  }

  if(minThreshold===Infinity || maxThreshold===-Infinity){
    minThreshold=0;
    maxThreshold=1;
  }
  if(xMode==='quantile'){
    minThreshold=Math.max(0, minThreshold);
    maxThreshold=Math.min(1, Math.max(maxThreshold, minThreshold+1e-6));
  }
  if(minThreshold===maxThreshold){
    minThreshold-=0.5;
    maxThreshold+=0.5;
  }
  if(!Number.isFinite(minUtility) || !Number.isFinite(maxUtility)){
    minUtility=0;
    maxUtility=1;
  }
  if(minUtility===maxUtility){
    const adjust=Math.max(1, Math.abs(minUtility||1));
    minUtility-=adjust/2;
    maxUtility+=adjust/2;
  }

  const marginLeft=70;
  const marginRight=30;
  const marginTop=30;

  const legendPadding=8;
  const legendItemHeight=18;
  const legendHeight=datasets.length ? legendItemHeight*datasets.length+legendPadding*2 : 0;
  const marginBottom=40+legendHeight;

  const plotW=Math.max(10,width-marginLeft-marginRight);
  const plotH=Math.max(10,height-marginTop-marginBottom);
  const xScale=(threshold)=>marginLeft+((threshold-minThreshold)/(maxThreshold-minThreshold||1))*plotW;
  const yScale=(utility)=>marginTop+(1-((utility-minUtility)/(maxUtility-minUtility||1)))*plotH;

  thresholdCtx.fillStyle='#f8f8f8';
  thresholdCtx.fillRect(marginLeft,marginTop,plotW,plotH);
  thresholdCtx.strokeStyle='#ccc';
  thresholdCtx.lineWidth=1;
  thresholdCtx.strokeRect(marginLeft,marginTop,plotW,plotH);

  thresholdCtx.strokeStyle='#444';
  thresholdCtx.lineWidth=1.2;
  thresholdCtx.beginPath();
  thresholdCtx.moveTo(marginLeft, marginTop);
  thresholdCtx.lineTo(marginLeft, marginTop+plotH);
  thresholdCtx.lineTo(marginLeft+plotW, marginTop+plotH);
  thresholdCtx.stroke();

  thresholdCtx.fillStyle='#000';
  thresholdCtx.font='13px sans-serif';
  thresholdCtx.textAlign='center';
  const tocStrings = getPlotStrings('toc');
  const xAxisLabel = xMode==='quantile'
    ? (tocStrings.xLabel || defaultConfig.strings?.plots?.toc?.xLabel || 'Fraction of the Entire Test Set')
    : (strings.axisThreshold || defaultConfig.strings.axisThreshold);
  thresholdCtx.fillText(xAxisLabel, marginLeft + plotW/2, marginTop+plotH+28);
  thresholdCtx.save();
  thresholdCtx.translate(18, marginTop + plotH/2);
  thresholdCtx.rotate(-Math.PI/2);
  thresholdCtx.fillText(strings.axisUtility || defaultConfig.strings.axisUtility, 0,0);
  thresholdCtx.restore();

  thresholdCtx.fillStyle='#000';
  thresholdCtx.font='12px sans-serif';
  thresholdCtx.textAlign='center';
  const xTickCount=5;
  for(let i=0;i<xTickCount;i++){
    const t=minThreshold+(i/(xTickCount-1||1))*(maxThreshold-minThreshold);
    const x=xScale(t);
    thresholdCtx.beginPath();
    thresholdCtx.moveTo(x, marginTop+plotH);
    thresholdCtx.lineTo(x, marginTop+plotH+6);
    thresholdCtx.strokeStyle='#444';
    thresholdCtx.stroke();
    thresholdCtx.fillText(Number(t).toFixed(2), x, marginTop+plotH+20);
  }

  thresholdCtx.textAlign='right';
  const yTickCount=5;
  for(let i=0;i<yTickCount;i++){
    const frac=i/(yTickCount-1||1);
    const u=minUtility+frac*(maxUtility-minUtility);
    const y=yScale(u);
    thresholdCtx.beginPath();
    thresholdCtx.moveTo(marginLeft-6,y);
    thresholdCtx.lineTo(marginLeft,y);
    thresholdCtx.strokeStyle='#444';
    thresholdCtx.stroke();
    thresholdCtx.fillText(Math.round(u).toString(), marginLeft-8, y+4);
  }

  if(minUtility<0 && maxUtility>0){
    const zeroY=yScale(0);
    thresholdCtx.strokeStyle='rgba(0,0,0,0.2)';
    thresholdCtx.setLineDash([4,4]);
    thresholdCtx.beginPath();
    thresholdCtx.moveTo(marginLeft, zeroY);
    thresholdCtx.lineTo(marginLeft+plotW, zeroY);
    thresholdCtx.stroke();
    thresholdCtx.setLineDash([]);
  }

  datasets.forEach(dataset=>{
    const lineWidth = dataset.isSelected ? 4 : 2;
    const bandPts = (dataset.bandEntries || []).filter(pt=>Number.isFinite(pt.lower) || Number.isFinite(pt.upper));
    if(bandPts.length){
      const upperPath=[];
      const lowerPath=[];
      bandPts.forEach(pt=>{
        if(Number.isFinite(pt.upper)) upperPath.push({x:xScale(pt.x), y:yScale(pt.upper)});
      });
      for(let i=bandPts.length-1;i>=0;i--){
        const pt=bandPts[i];
        if(Number.isFinite(pt.lower)) lowerPath.push({x:xScale(pt.x), y:yScale(pt.lower)});
      }
      if(upperPath.length && lowerPath.length){
        thresholdCtx.save();
        thresholdCtx.beginPath();
        thresholdCtx.moveTo(upperPath[0].x, upperPath[0].y);
        upperPath.slice(1).forEach(p=>thresholdCtx.lineTo(p.x,p.y));
        lowerPath.forEach(p=>thresholdCtx.lineTo(p.x,p.y));
        thresholdCtx.closePath();
        thresholdCtx.fillStyle=dataset.color;
        thresholdCtx.globalAlpha=0.18;
        thresholdCtx.fill();
        thresholdCtx.restore();
      }
    }

    thresholdCtx.beginPath();
    dataset.entries.forEach((pt,idx)=>{
      const x=xScale(pt.x);
      const y=yScale(pt.utility);
      if(idx===0) thresholdCtx.moveTo(x,y);
      else thresholdCtx.lineTo(x,y);
    });
    thresholdCtx.strokeStyle=dataset.color;
    thresholdCtx.lineWidth=lineWidth;
    thresholdCtx.stroke();
    thresholdCtx.lineWidth=1;
    dataset.entries.forEach(pt=>{
      const x=xScale(pt.x);
      const y=yScale(pt.utility);
      thresholdCtx.beginPath();
      thresholdCtx.arc(x,y,dataset.isSelected?4:3,0,Math.PI*2);
      thresholdCtx.fillStyle=dataset.color;
      thresholdCtx.fill();
    });

    if(dataset.isSelected && Number.isInteger(lastRocBestIdx)){
      const match=dataset.entries.find(pt=>pt.idx===lastRocBestIdx);
      if(match){
        thresholdCtx.beginPath();
        thresholdCtx.arc(xScale(match.x), yScale(match.utility), 7, 0, Math.PI*2);
        thresholdCtx.fillStyle='yellow';
        thresholdCtx.strokeStyle='red';
        thresholdCtx.lineWidth=2;
        thresholdCtx.fill();
        thresholdCtx.stroke();
        thresholdCtx.lineWidth=1;
      }
    }
  });

  if(legendHeight>0){
    const legendWidth=Math.min(260, plotW);
    const legendX=marginLeft+(plotW-legendWidth)/2;
    const legendY=marginTop+plotH+10;
    thresholdCtx.fillStyle='rgba(255,255,255,0.9)';
    thresholdCtx.strokeStyle='rgba(0,0,0,0.15)';
    thresholdCtx.lineWidth=1;
    thresholdCtx.fillRect(legendX, legendY, legendWidth, legendHeight);
    thresholdCtx.strokeRect(legendX, legendY, legendWidth, legendHeight);
    thresholdCtx.font='12px sans-serif';
    thresholdCtx.textAlign='left';
    datasets.forEach((dataset,index)=>{
      const y=legendY+legendPadding+legendItemHeight*index+legendItemHeight/2;
      thresholdCtx.fillStyle=dataset.color;
      thresholdCtx.fillRect(legendX+10, y-5, 16, 10);
      thresholdCtx.fillStyle='#000';
      const label=dataset.label || dataset.id;
      const selectedSuffix = dataset.isSelected ? (strings.legendSelectedSuffix || defaultConfig.strings.legendSelectedSuffix || '') : '';
      const syntheticSuffix = dataset.synthetic ? (strings.legendDerivedSuffix || defaultConfig.strings.legendDerivedSuffix || '') : '';
      thresholdCtx.fillText(`${label}${selectedSuffix}${syntheticSuffix}`, legendX+32, y+4);
    });
  }
}

canvas.addEventListener('mousemove',e=>{
  if(!isRocPlotVisible()){
    tooltip.style.display='none';
    return;
  }
  const rect=canvas.getBoundingClientRect();
  const offsetX=e.clientX-rect.left;
  const offsetY=e.clientY-rect.top;
  const scaleX=canvas.width/rect.width;
  const scaleY=canvas.height/rect.height;
  const x=offsetX*scaleX;
  const y=offsetY*scaleY;
  const {x0,y0,plotW,plotH}=getRocPlotGeometry(canvas.width, canvas.height);
  if(x<x0||x>x0+plotW||y<y0||y>y0+plotH){tooltip.style.display='none';return;}
  const fpr=(x-x0)/plotW,tpr=1-(y-y0)/plotH;
  const payoffs=getPayoffParams();
  const pPos=payoffs.P_POS;
  const N=getPopulationSize();
  const ap=N*pPos,an=N*(1-pPos),tp=tpr*ap,fn=(1-tpr)*ap,fp=fpr*an,tn=an-fp;
  const u=utilityAtRates(fpr,tpr,payoffs);
  const tooltipWidth=140,tooltipHeight=48;
  tooltip.style.left=(offsetX-tooltipWidth-10)+'px';
  tooltip.style.top=(offsetY-tooltipHeight-10)+'px';
  const tooltipTemplate=strings.tooltipFormat || defaultConfig.strings.tooltipFormat;
  tooltip.textContent=formatString(tooltipTemplate,{
    fpr:fpr.toFixed(2),
    tpr:tpr.toFixed(2),
    utility: Math.round(u)
  });
  tooltip.style.display='block';
});
canvas.addEventListener('mouseleave',()=>tooltip.style.display='none');

if(tocCanvas){
  tocCanvas.addEventListener('mousemove',e=>{
    if(!isTocPlotVisible()){
      tooltip.style.display='none';
      return;
    }
    const cache=tocPlotCache || {};
    const geometry=cache.geometry;
    if(!geometry){
      tooltip.style.display='none';
      return;
    }
    const {x0,y0,plotW,plotH,xMax,yMax,P,Nn,Npop}=geometry;
    const rect=tocCanvas.getBoundingClientRect();
    const offsetX=e.clientX-rect.left;
    const offsetY=e.clientY-rect.top;
    const scaleX=tocCanvas.width/rect.width;
    const scaleY=tocCanvas.height/rect.height;
    const x=offsetX*scaleX;
    const y=offsetY*scaleY;
    if(x<x0||x>x0+plotW||y<y0||y>y0+plotH){tooltip.style.display='none';return;}
    const predictedPos = (x - x0)/plotW * (xMax||1);
    const truePos = (1 - (y - y0)/plotH) * (yMax||1);
    const fp = predictedPos - truePos;
    const payoffs=getPayoffParams();
    const totalPos = P ?? (payoffs.P_POS * getPopulationSize());
    const totalNeg = Nn ?? ((1 - payoffs.P_POS) * getPopulationSize());
    const tpr = totalPos>0 ? Math.max(0,Math.min(1,truePos/totalPos)) : 0;
    const fpr = totalNeg>0 ? Math.max(0,Math.min(1,fp/totalNeg)) : 0;
    const util=utilityAtRates(fpr,tpr,payoffs);
    const parts=[];
    const popCount = Npop ?? getPopulationSize();
    const popFrac = popCount>0 ? predictedPos/popCount : 0;
    parts.push(`Predicted+: ${predictedPos.toFixed(2)}`);
    parts.push(`TP: ${truePos.toFixed(2)}`);
    parts.push(`Pop frac: ${popFrac.toFixed(2)}`);
    parts.push(`TPR: ${tpr.toFixed(2)}`);
    parts.push(`FPR: ${fpr.toFixed(2)}`);
    parts.push(`Utility: ${Math.round(util)}`);
    tooltip.textContent=parts.join(', ');
    tooltip.style.left=(offsetX-140)+'px';
    tooltip.style.top=(offsetY-60)+'px';
    tooltip.style.display='block';
  });
  tocCanvas.addEventListener('mouseleave',()=>tooltip.style.display='none');
}

window.addEventListener('DOMContentLoaded',async()=>{
  await loadAppConfig();
  const loaded=await loadStaticRocFiles();
  if(!loaded){
    const fallbackSelection=Object.keys(HARDCODED_FALLBACK_CURVES)[0]||null;
    loadROCData({...HARDCODED_FALLBACK_CURVES},fallbackSelection);
  }
  if(isBestUtilityVisible() && bestUtilityDiv && !bestUtilityDiv.textContent){
    bestUtilityDiv.textContent = strings.bestUtilityUnavailable || defaultConfig.strings.bestUtilityUnavailable;
  }
  buildPlotGrid();
  applyConfigToUI();
  drawAll();
});
</script>
</body>
</html>
