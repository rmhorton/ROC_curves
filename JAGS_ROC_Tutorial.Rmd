---
title: "Bayesian ROC Analysis: Binormal, Bibeta, and Nonparametric (Bayesian Bootstrap)"
author: ""
date: "`r format(Sys.Date())`"
output:
  html_document:
    toc: true
    toc_depth: 3
    toc_float: true
  pdf_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.width = 7,
  fig.height = 5,
  dpi = 120
)
set.seed(1)
```

# Introduction

This document brings together three Bayesian approaches to ROC analysis with full posterior uncertainty:

1. **Parametric binormal model** (scores for negatives and positives are Normal with different mean and variance). The ROC and AUC are computed inside the JAGS model using the Normal CDF.
2. **Parametric bibeta model** (scores lie in [0,1] and follow Beta distributions by class). The ROC and AUC are computed in R from posterior draws.
3. **Nonparametric Bayesian bootstrap** (no distributional assumptions). We put Dirichlet(1,...,1) priors on empirical weights and propagate uncertainty to ROC and AUC.

Convention: **higher scores imply the positive class**. If your direction is reversed, negate the scores or swap definitions accordingly.

---

# Data and Notation

Let \(y_0 = (y_{0j})_{j=1}^{N_0}\) be scores for the **negative** class and \(y_1 = (y_{1i})_{i=1}^{N_1}\) for the **positive** class. For threshold \(t\):

- \(\mathrm{TPR}(t) = \Pr(y_1 > t)\)
- \(\mathrm{FPR}(t) = \Pr(y_0 > t)\)

The ROC is the set of pairs \((\mathrm{FPR}(t), \mathrm{TPR}(t))\) over all \(t\). The AUC equals \(\Pr(y_1 > y_0) + \tfrac12 \Pr(y_1 = y_0)\) (the Mann–Whitney probability with half credit for ties).

---

# 1) Binormal model in JAGS (ROC & AUC inside the model)

Assume

- \(y_0 \sim N(\mu_0, \sigma_0^2)\)
- \(y_1 \sim N(\mu_1, \sigma_1^2)\)

The binormal ROC has a closed-form AUC under this model.

## JAGS model file

Save as `bayes_roc_binormal.jags`.

```{r write-binormal-model, eval=TRUE}
binormal_model <- 'model {
  # Likelihood
  for (i in 1:N0) { y0[i] ~ dnorm(mu0, tau0) }
  for (j in 1:N1) { y1[j] ~ dnorm(mu1, tau1) }

  # Priors (weakly-informative)
  mu0    ~ dnorm(0, 1.0E-6)
  mu1    ~ dnorm(0, 1.0E-6)
  sigma0 ~ dunif(0, 1000)
  sigma1 ~ dunif(0, 1000)
  tau0 <- pow(sigma0, -2)
  tau1 <- pow(sigma1, -2)

  # ROC on a supplied grid of thresholds t[1:K]
  for (k in 1:K) {
    tpr[k] <- 1 - phi((t[k] - mu1) * sqrt(tau1))
    fpr[k] <- 1 - phi((t[k] - mu0) * sqrt(tau0))
  }

  # Binormal AUC (closed form)
  auc <- phi( (mu1 - mu0) / sqrt( (1 / tau0) + (1 / tau1) ) )

  # OPTIONAL: Youden\'s J argmax (no which_max in JAGS)
  for (k in 1:K) { youden[k] <- tpr[k] - fpr[k] }
  best[1] <- youden[1]
  idx[1]  <- 1
  for (k in 2:K) {
    better[k] <- step(youden[k] - best[k-1])
    best[k]   <- better[k]*youden[k] + (1-better[k])*best[k-1]
    idx[k]    <- better[k]*k + (1-better[k])*idx[k-1]
  }
  k_star <- idx[K]
  t_star <- t[k_star]
}'
writeLines(binormal_model, "bayes_roc_binormal.jags")
cat("Wrote bayes_roc_binormal.jags\n")
```

## R driver using jagsUI

```{r binormal-fit, message=TRUE, warning=FALSE}
library(jagsUI)
set.seed(123)

# Simulate binormal data (edit as needed)
N0 <- 150; N1 <- 120
y0 <- rnorm(N0, mean = 0,   sd = 1.0)
y1 <- rnorm(N1, mean = 1.0, sd = 1.2)

# Threshold grid covering the data
all_y <- c(y0, y1)
K     <- 101
tgrid <- seq(min(all_y) - 0.5*sd(all_y), max(all_y) + 0.5*sd(all_y), length.out = K)

# JAGS data & settings
jags_data <- list(N0=length(y0), N1=length(y1), y0=y0, y1=y1, K=K, t=tgrid)
params    <- c("mu0","mu1","sigma0","sigma1","auc","tpr","fpr","t_star","k_star")

inits <- function() list(
  mu0 = mean(y0), mu1 = mean(y1),
  sigma0 = sd(y0) + 0.1, sigma1 = sd(y1) + 0.1
)

fit_binormal <- jags(
  data = jags_data, inits = inits,
  parameters.to.save = params,
  model.file = "bayes_roc_binormal.jags",
  n.chains = 3, n.adapt = 1000, n.iter = 6000,
  n.burnin = 2000, n.thin = 2, parallel = TRUE
)

print(fit_binormal, digits = 3)

# Summaries for ROC
TPR_sims <- fit_binormal$sims.list$tpr
FPR_sims <- fit_binormal$sims.list$fpr
AUC_sims <- fit_binormal$sims.list$auc

# Direction check: if AUC<0.5, reflect ROC and AUC
if (mean(AUC_sims) < 0.5) {
  message("Detected reversed score orientation; reflecting ROC and AUC.")
  TPR_old <- TPR_sims; FPR_old <- FPR_sims
  TPR_sims <- 1 - FPR_old
  FPR_sims <- 1 - TPR_old
  AUC_sims <- 1 - AUC_sims
}

TPR_mean <- apply(TPR_sims, 2, mean)
TPR_lo   <- apply(TPR_sims, 2, quantile, 0.025)
TPR_hi   <- apply(TPR_sims, 2, quantile, 0.975)
FPR_mean <- apply(FPR_sims, 2, mean)

# Plot ROC with credible band
ord <- order(FPR_mean)
plot(FPR_mean[ord], TPR_mean[ord], type="l",
     xlab="False Positive Rate", ylab="True Positive Rate")
polygon(c(FPR_mean[ord], rev(FPR_mean[ord])),
        c(TPR_lo[ord],   rev(TPR_hi[ord])),
        border=NA, col=adjustcolor("gray80", 0.8))
lines(FPR_mean[ord], TPR_mean[ord])
abline(0,1,lty=3)

cat(sprintf("Binormal posterior mean AUC = %.3f (95%% CrI: %.3f–%.3f)\n",
            mean(AUC_sims), quantile(AUC_sims,0.025), quantile(AUC_sims,0.975)))
```

---

# 2) Bibeta model in JAGS (ROC & AUC computed in R)

Assume scores are in \([0,1]\) and follow Beta distributions by class. Use the mean–precision reparameterization: \(\alpha = m k\), \(\beta = (1-m)k\) with mean \(m \in (0,1)\) and precision \(k > 0\).

JAGS lacks a Beta CDF, so we compute ROC and AUC in R for each posterior draw using `pbeta` and `dbeta`.

## JAGS model file

Save as `bibeta_roc.jags`.

```{r write-bibeta-model, eval=TRUE}
bibeta_model <- 'model {
  for (i in 1:N0) { y0[i] ~ dbeta(alpha0, beta0) }
  for (j in 1:N1) { y1[j] ~ dbeta(alpha1, beta1) }

  m0 ~ dbeta(1,1)
  m1 ~ dbeta(1,1)
  k0 ~ dgamma(1.0, 0.1)
  k1 ~ dgamma(1.0, 0.1)

  alpha0 <- m0 * k0
  beta0  <- (1 - m0) * k0
  alpha1 <- m1 * k1
  beta1  <- (1 - m1) * k1
}'
writeLines(bibeta_model, "bibeta_roc.jags")
cat("Wrote bibeta_roc.jags\n")
```

## R driver using jagsUI

```{r bibeta-fit, message=TRUE, warning=FALSE}
# Simulate bibeta data (edit as needed)
set.seed(123)
N0 <- 200; N1 <- 180
m0_true <- 0.35; k0_true <- 20
m1_true <- 0.70; k1_true <- 25

a0_true <- m0_true * k0_true; b0_true <- (1 - m0_true) * k0_true
a1_true <- m1_true * k1_true; b1_true <- (1 - m1_true) * k1_true

y0 <- rbeta(N0, a0_true, b0_true)
y1 <- rbeta(N1, a1_true, b1_true)

# If real data contain exact 0/1, jitter slightly into (0,1)
# eps <- 1e-6; y0 <- pmin(pmax(y0, eps), 1-eps); y1 <- pmin(pmax(y1, eps), 1-eps)

jags_data2 <- list(N0=N0, N1=N1, y0=y0, y1=y1)
params2    <- c("m0","m1","k0","k1","alpha0","beta0","alpha1","beta1")

m0_start <- pmin(pmax(mean(y0), 1e-6), 1-1e-6)
m1_start <- pmin(pmax(mean(y1), 1e-6), 1-1e-6)
inits2 <- function() list(
  m0 = plogis(rnorm(1, qlogis(m0_start), 0.5)),
  m1 = plogis(rnorm(1, qlogis(m1_start), 0.5)),
  k0 = rgamma(1, 1, 0.1),
  k1 = rgamma(1, 1, 0.1)
)

fit_bibeta <- jags(
  data = jags_data2, inits = inits2,
  parameters.to.save = params2,
  model.file = "bibeta_roc.jags",
  n.chains = 3, n.adapt = 1000, n.iter = 6000,
  n.burnin = 2000, n.thin = 2, parallel = TRUE
)

print(fit_bibeta, digits = 3)

# Build ROC/AUC from posterior draws
S <- length(fit_bibeta$sims.list$m0)
tgrid <- seq(0, 1, length.out = 201)
TPR <- FPR <- matrix(NA_real_, nrow = S, ncol = length(tgrid))
AUC <- numeric(S)

x_int <- seq(0, 1, length.out = 1001)
dx    <- x_int[2] - x_int[1]

for (s in 1:S) {
  a0 <- fit_bibeta$sims.list$alpha0[s]; b0 <- fit_bibeta$sims.list$beta0[s]
  a1 <- fit_bibeta$sims.list$alpha1[s]; b1 <- fit_bibeta$sims.list$beta1[s]
  FPR[s, ] <- 1 - pbeta(tgrid, a0, b0)
  TPR[s, ] <- 1 - pbeta(tgrid, a1, b1)
  AUC[s] <- sum(dbeta(x_int, a1, b1) * (1 - pbeta(x_int, a0, b0))) * dx
}

# Direction check: if mean AUC < 0.5, reflect ROC and AUC
if (mean(AUC) < 0.5) {
  message("Detected reversed score orientation; reflecting ROC and AUC.")
  TPR_old <- TPR; FPR_old <- FPR
  TPR <- 1 - FPR_old
  FPR <- 1 - TPR_old
  AUC <- 1 - AUC
}

TPR_mean <- apply(TPR, 2, mean)
TPR_lo   <- apply(TPR, 2, quantile, 0.025)
TPR_hi   <- apply(TPR, 2, quantile, 0.975)
FPR_mean <- apply(FPR, 2, mean)

ord <- order(FPR_mean)
plot(FPR_mean[ord], TPR_mean[ord], type="l",
     xlab="False Positive Rate", ylab="True Positive Rate")
polygon(c(FPR_mean[ord], rev(FPR_mean[ord])),
        c(TPR_lo[ord],   rev(TPR_hi[ord])),
        border=NA, col=adjustcolor("gray80", 0.8))
lines(FPR_mean[ord], TPR_mean[ord])
abline(0,1,lty=3)

cat(sprintf("Bibeta posterior mean AUC = %.3f (95%% CrI: %.3f–%.3f)\n",
            mean(AUC), quantile(AUC,0.025), quantile(AUC,0.975)))
```

---

# 3) Nonparametric Bayesian ROC (Bayesian bootstrap)

This approach makes no parametric assumptions on the score distributions. We place independent Dirichlet(1,...,1) priors on class-specific empirical weights. Each posterior draw yields a weighted empirical ROC and AUC.

## R implementation

```{r bb-roc, message=FALSE}
# Utilities
rdirichlet1 <- function(n) { x <- rexp(n); x / sum(x) }

roc_step_weighted <- function(y0, y1, w0, w1) {
  stopifnot(length(y0) == length(w0), length(y1) == length(w1))
  w0 <- w0 / sum(w0); w1 <- w1 / sum(w1)
  y   <- c(y0, y1)
  lab <- c(rep(0L, length(y0)), rep(1L, length(y1)))
  w   <- c(w0, w1)
  o   <- order(y, decreasing = TRUE)
  y <- y[o]; lab <- lab[o]; w <- w[o]
  runs <- rle(y)
  idx_end <- cumsum(runs$lengths)
  idx_start <- c(1L, head(idx_end, -1L) + 1L)
  tp <- fp <- numeric(length(runs$lengths))
  for (g in seq_along(runs$lengths)) {
    sl <- idx_start[g]:idx_end[g]
    fp[g] <- sum(w[sl][lab[sl] == 0L])
    tp[g] <- sum(w[sl][lab[sl] == 1L])
  }
  FPR <- c(0, cumsum(fp))
  TPR <- c(0, cumsum(tp))
  FPR[length(FPR)] <- 1; TPR[length(TPR)] <- 1
  list(fpr = FPR, tpr = TPR)
}

auc_weighted <- function(y0, y1, w0, w1) {
  w0 <- w0 / sum(w0); w1 <- w1 / sum(w1)
  s_all <- sort(unique(c(y0, y1)))
  w0_at <- tapply(w0, factor(match(y0, s_all), levels = seq_along(s_all)), sum)
  w0_at[is.na(w0_at)] <- 0
  w1_at <- tapply(w1, factor(match(y1, s_all), levels = seq_along(s_all)), sum)
  w1_at[is.na(w1_at)] <- 0
  w0_cum_less <- c(0, head(cumsum(w0_at), -1))
  sum(w1_at * (w0_cum_less + 0.5 * w0_at))
}

# Example data (replace with your own)
set.seed(1)
N0 <- 200; N1 <- 180
y0 <- rnorm(N0, 0.0, 1.0)
y1 <- rnorm(N1, 0.7, 1.2)

# Posterior sampling
S <- 2000
fpr_grid <- seq(0, 1, length.out = 201)
TPR_mat <- matrix(NA_real_, nrow = S, ncol = length(fpr_grid))
AUC_vec <- numeric(S)

for (s in 1:S) {
  w0 <- rdirichlet1(length(y0))
  w1 <- rdirichlet1(length(y1))
  roc <- roc_step_weighted(y0, y1, w0, w1)
  TPR_mat[s, ] <- approx(x = roc$fpr, y = roc$tpr, xout = fpr_grid,
                         method = "linear", ties = "ordered", rule = 2)$y
  AUC_vec[s] <- auc_weighted(y0, y1, w0, w1)
}

# Direction check: if mean AUC < 0.5, reflect ROC and AUC
if (mean(AUC_vec) < 0.5) {
  message("Detected reversed score orientation; reflecting ROC and AUC.")
  TPR_mat <- 1 - TPR_mat[, ncol(TPR_mat):1, drop=FALSE]
  AUC_vec <- 1 - AUC_vec
}

TPR_mean <- apply(TPR_mat, 2, mean)
TPR_lo   <- apply(TPR_mat, 2, quantile, 0.025)
TPR_hi   <- apply(TPR_mat, 2, quantile, 0.975)

plot(fpr_grid, TPR_mean, type="l",
     xlab="False Positive Rate", ylab="True Positive Rate")
polygon(c(fpr_grid, rev(fpr_grid)),
        c(TPR_lo,   rev(TPR_hi)),
        border = NA, col = adjustcolor("gray80", 0.8))
lines(fpr_grid, TPR_mean)
abline(0,1,lty=3)

cat(sprintf("Bayesian-bootstrap posterior mean AUC = %.3f (95%% CrI: %.3f–%.3f)\n",
            mean(AUC_vec), quantile(AUC_vec, 0.025), quantile(AUC_vec, 0.975)))
```

---

# DAGs for JAGS models

## Binormal model DAG

```{r binormal-dag, message=FALSE, warning=FALSE}
library(DiagrammeR)

grViz('
digraph {
  graph [rankdir=LR, fontsize=10]
  node [shape=ellipse, style=filled, fontname=Helvetica]

  mu0    [fillcolor="#FDE0DC"]
  sigma0 [fillcolor="#FDE0DC"]
  tau0   [fillcolor="#FFF8CE"]
  y0     [label="y0[ ]", fillcolor="#D0E6FF"]

  mu1    [fillcolor="#FDE0DC"]
  sigma1 [fillcolor="#FDE0DC"]
  tau1   [fillcolor="#FFF8CE"]
  y1     [label="y1[ ]", fillcolor="#D0E6FF"]

  t      [label="t[ ]",  fillcolor="#D0E6FF"]
  tpr    [label="tpr[ ]", fillcolor="#FFF8CE"]
  fpr    [label="fpr[ ]", fillcolor="#FFF8CE"]
  auc    [label="auc", fillcolor="#FFF8CE"]

  mu0 -> y0
  sigma0 -> tau0
  tau0 -> y0
  mu1 -> y1
  sigma1 -> tau1
  tau1 -> y1

  mu0 -> fpr
  tau0 -> fpr
  mu1 -> tpr
  tau1 -> tpr
  t   -> fpr
  t   -> tpr

  mu0 -> auc
  mu1 -> auc
  tau0 -> auc
  tau1 -> auc
}
')
```

## Bibeta model DAG

```{r bibeta-dag, message=FALSE, warning=FALSE}
library(DiagrammeR)

grViz('
digraph {
  graph [rankdir=LR, fontsize=10]
  node [shape=ellipse, style=filled, fontname=Helvetica]

  m0 [fillcolor="#FDE0DC"]
  k0 [fillcolor="#FDE0DC"]
  m1 [fillcolor="#FDE0DC"]
  k1 [fillcolor="#FDE0DC"]

  alpha0 [fillcolor="#FFF8CE"]
  beta0  [fillcolor="#FFF8CE"]
  alpha1 [fillcolor="#FFF8CE"]
  beta1  [fillcolor="#FFF8CE"]

  y0   [label="y0[ ]", fillcolor="#D0E6FF"]
  y1   [label="y1[ ]", fillcolor="#D0E6FF"]

  m0 -> alpha0
  k0 -> alpha0
  m0 -> beta0
  k0 -> beta0
  alpha0 -> y0
  beta0  -> y0

  m1 -> alpha1
  k1 -> alpha1
  m1 -> beta1
  k1 -> beta1
  alpha1 -> y1
  beta1  -> y1
}
')
```

# Reproducibility

```{r session-info}
sessionInfo()
```

# Comments from Humans

## Bob

* Look into the [mcmcRocPrcGen](https://search.r-project.org/CRAN/refmans/BayesPostEst/html/mcmcRocPrcGen.html) R package.